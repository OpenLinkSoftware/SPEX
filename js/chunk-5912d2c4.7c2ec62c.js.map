{"version":3,"sources":["webpack:///./node_modules/@rdfjs/parser-jsonld/lib/ParserStream.js","webpack:///./node_modules/@rdfjs/parser-jsonld/index.js"],"names":["concat","jsonld","rdf","Readable","ParserStream","input","baseIRI","context","factory","super","objectMode","read","this","concatStream","encoding","data","parse","then","push","catch","err","emit","pipe","on","plainTerm","termType","value","startsWith","namedNode","slice","blankNode","substr","literal","language","datatype","defaultGraph","Error","toPlainObject","object","Object","keys","forEach","prefix","toRdfOptions","base","expandContext","promises","toRDF","plainQuads","plainQuad","quad","term","subject","predicate","graph","Promise","resolve","reject","JSON","module","exports","Sink","Parser","options"],"mappings":"qGAAA,MAAMA,EAAS,EAAQ,QACjBC,EAAS,EAAQ,QACjBC,EAAM,EAAQ,QACdC,EAAW,EAAQ,QAEzB,MAAMC,UAAqBD,EACzB,YAAaE,GAAO,QAAEC,EAAU,GAAE,QAAEC,EAAU,KAAI,QAAEC,EAAUN,GAAQ,IACpEO,MAAM,CACJC,YAAY,EACZC,KAAM,SAGRC,KAAKN,QAAUA,EACfM,KAAKL,QAAUA,EACfK,KAAKJ,QAAUA,EAEf,MAAMK,EAAeb,EAAO,CAAEc,SAAU,UAAaC,IAC9CA,EAMLH,KAAKI,MAAMD,GAAME,KAAK,KACpBL,KAAKM,KAAK,QACTC,MAAOC,IACRR,KAAKS,KAAK,QAASD,KARnBR,KAAKM,KAAK,QAYdb,EAAMiB,KAAKT,GAEXR,EAAMkB,GAAG,QAAUH,IACjBR,KAAKS,KAAK,QAASD,KAIvB,KAAMI,GACJ,OAAQA,EAAUC,UAChB,IAAK,YACH,OAAID,EAAUE,MAAMC,WAAW,UAEtBf,KAAKJ,QAAQoB,UAAUJ,EAAUE,MAAMG,MAAM,IAG/CjB,KAAKJ,QAAQoB,UAAUJ,EAAUE,OAC1C,IAAK,YACH,OAAOd,KAAKJ,QAAQsB,UAAUN,EAAUE,MAAMK,OAAO,IACvD,IAAK,UACH,OAAOnB,KAAKJ,QAAQwB,QAAQR,EAAUE,MAAOF,EAAUS,UAAYrB,KAAKJ,QAAQoB,UAAUJ,EAAUU,SAASR,QAC/G,IAAK,eACH,OAAOd,KAAKJ,QAAQ2B,eACtB,QACE,MAAMC,MAAM,qBAAuBZ,EAAUC,WAInD,MAAOV,GACL,OAAOX,EAAaiC,cAActB,GAAME,KAAMqB,IAEV,kBAAvBA,EAAO,aAChBC,OAAOC,KAAKF,EAAO,aAAaG,QAASC,IACvC9B,KAAKS,KAAK,SAAUqB,EAAQ9B,KAAKJ,QAAQoB,UAAUU,EAAO,YAAYI,OAK1E,MAAMC,EAAe,CAAEC,KAAMhC,KAAKN,SAAW,UAO7C,OAJIM,KAAKL,UACPoC,EAAaE,cAAgBjC,KAAKL,SAG7BN,EAAO6C,SAASC,MAAMT,EAAQK,KACpC1B,KAAK+B,IACNA,EAAWP,QAAQQ,IACjBrC,KAAKM,KAAKN,KAAKJ,QAAQ0C,KACrBtC,KAAKuC,KAAKF,EAAUG,SACpBxC,KAAKuC,KAAKF,EAAUI,WACpBzC,KAAKuC,KAAKF,EAAUX,QACpB1B,KAAKuC,KAAKF,EAAUK,aAK5B,qBAAsBvC,GACpB,MAAoB,kBAATA,EACF,IAAIwC,QAAQ,CAACC,EAASC,KAC3B,IACED,EAAQE,KAAK1C,MAAMD,IACnB,MAAOK,GACPqC,EAAOrC,MAKO,kBAATL,EACFwC,QAAQC,QAAQzC,GAGlBwC,QAAQE,OAAO,IAAIrB,MAAM,kBAIpCuB,EAAOC,QAAUxD,G,qBCzGjB,MAAMA,EAAe,EAAQ,QACvByD,EAAO,EAAQ,QAErB,MAAMC,UAAeD,EACnB,YAAaE,GACXtD,MAAML,EAAc2D,IAIxBJ,EAAOC,QAAUE","file":"js/chunk-5912d2c4.7c2ec62c.js","sourcesContent":["const concat = require('concat-stream')\nconst jsonld = require('jsonld')\nconst rdf = require('@rdfjs/data-model')\nconst Readable = require('readable-stream')\n\nclass ParserStream extends Readable {\n  constructor (input, { baseIRI = '', context = null, factory = rdf } = {}) {\n    super({\n      objectMode: true,\n      read: () => {}\n    })\n\n    this.baseIRI = baseIRI\n    this.context = context\n    this.factory = factory\n\n    const concatStream = concat({ encoding: 'string' }, (data) => {\n      if (!data) {\n        this.push(null)\n\n        return\n      }\n\n      this.parse(data).then(() => {\n        this.push(null)\n      }).catch((err) => {\n        this.emit('error', err)\n      })\n    })\n\n    input.pipe(concatStream)\n\n    input.on('error', (err) => {\n      this.emit('error', err)\n    })\n  }\n\n  term (plainTerm) {\n    switch (plainTerm.termType) {\n      case 'NamedNode':\n        if (plainTerm.value.startsWith('null:/')) {\n          // remove null:/ workaround for relative IRIs\n          return this.factory.namedNode(plainTerm.value.slice(6))\n        }\n\n        return this.factory.namedNode(plainTerm.value)\n      case 'BlankNode':\n        return this.factory.blankNode(plainTerm.value.substr(2))\n      case 'Literal':\n        return this.factory.literal(plainTerm.value, plainTerm.language || this.factory.namedNode(plainTerm.datatype.value))\n      case 'DefaultGraph':\n        return this.factory.defaultGraph()\n      default:\n        throw Error('unknown termType: ' + plainTerm.termType)\n    }\n  }\n\n  parse (data) {\n    return ParserStream.toPlainObject(data).then((object) => {\n      // forward context as prefixes if available\n      if (typeof object['@context'] === 'object') {\n        Object.keys(object['@context']).forEach((prefix) => {\n          this.emit('prefix', prefix, this.factory.namedNode(object['@context'][prefix]))\n        })\n      }\n\n      // use null:/ as workaround for relative IRIs\n      const toRdfOptions = { base: this.baseIRI || 'null:/' }\n\n      // use context from options if given\n      if (this.context) {\n        toRdfOptions.expandContext = this.context\n      }\n\n      return jsonld.promises.toRDF(object, toRdfOptions)\n    }).then(plainQuads => {\n      plainQuads.forEach(plainQuad => {\n        this.push(this.factory.quad(\n          this.term(plainQuad.subject),\n          this.term(plainQuad.predicate),\n          this.term(plainQuad.object),\n          this.term(plainQuad.graph)))\n      })\n    })\n  }\n\n  static toPlainObject (data) {\n    if (typeof data === 'string') {\n      return new Promise((resolve, reject) => {\n        try {\n          resolve(JSON.parse(data))\n        } catch (err) {\n          reject(err)\n        }\n      })\n    }\n\n    if (typeof data === 'object') {\n      return Promise.resolve(data)\n    }\n\n    return Promise.reject(new Error('unknown type'))\n  }\n}\n\nmodule.exports = ParserStream\n","const ParserStream = require('./lib/ParserStream')\nconst Sink = require('@rdfjs/sink')\n\nclass Parser extends Sink {\n  constructor (options) {\n    super(ParserStream, options)\n  }\n}\n\nmodule.exports = Parser\n"],"sourceRoot":""}