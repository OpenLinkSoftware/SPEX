{"version":3,"sources":["webpack:///./node_modules/@graphy/core.iso.stream/main.js","webpack:///./node_modules/uri-js/dist/es5/uri.all.js","webpack:///./node_modules/@graphy/content.trig.read/main.js"],"names":["Readable","stream","gc_readable","super","iterator","Error","s_event","b_return_stream","Promise","fk_until","fe_until","this","on","e_stream","once","a_args","s_encoding","g_readable","_readableState","objectMode","fk_bucket","fe_bucket","a_data","pipe","Writable","w_event","s_write_encoding","fk_write","push","a_chunks","fk_writev","s_data","setEncoding","decodeStrings","s_chunk","join","ab_data","Buffer","from","ab_chunk","concat","length","ds_source","w_chunk","write","end","e_read","emit","Duplex","Transform","e_destroy","z_chunk","Object","getPrototypeOf","apply","prototype","destroy","call","b_is_node","Function","B_BROWSER","B_BROWSERIFY","process","browser","versions","node","exec","version","fke_destroy","destroyed","_writableState","f_emit_close","emitClose","_destroy","e_destroy_re","nextTick","errorEmitted","QuadsToOther","gc_transform","writableObjectMode","readableObjectMode","_as_inputs","Set","ds_src","add","delete","ds_input","Quads_To_JSON_Transform","g_quad","fk_transform","JSON","stringify","isolate","Quads_To_Writable","type","value","module","exports","w_push","isBuffer","global","factory","merge","_len","arguments","sets","Array","_key","slice","xl","x","subexp","str","typeOf","o","undefined","toString","split","pop","shift","toLowerCase","toUpperCase","toArray","obj","setInterval","assign","target","source","key","buildExps","isIRI","ALPHA$$","DIGIT$$","HEXDIG$$","PCT_ENCODED$","GEN_DELIMS$$","SUB_DELIMS$$","RESERVED$$","UCSCHAR$$","IPRIVATE$$","UNRESERVED$$","SCHEME$","USERINFO$","DEC_OCTET_RELAXED$","IPV4ADDRESS$","H16$","LS32$","IPV6ADDRESS1$","IPV6ADDRESS2$","IPV6ADDRESS3$","IPV6ADDRESS4$","IPV6ADDRESS5$","IPV6ADDRESS6$","IPV6ADDRESS7$","IPV6ADDRESS8$","IPV6ADDRESS9$","IPV6ADDRESS$","ZONEID$","IPV6ADDRZ_RELAXED$","IPVFUTURE$","IP_LITERAL$","REG_NAME$","HOST$","PORT$","AUTHORITY$","PCHAR$","SEGMENT$","SEGMENT_NZ$","SEGMENT_NZ_NC$","PATH_ABEMPTY$","PATH_ABSOLUTE$","PATH_NOSCHEME$","PATH_ROOTLESS$","PATH_EMPTY$","QUERY$","FRAGMENT$","HIER_PART$","URI$","RELATIVE_PART$","RELATIVE$","NOT_SCHEME","RegExp","NOT_USERINFO","NOT_HOST","NOT_PATH","NOT_PATH_NOSCHEME","NOT_QUERY","NOT_FRAGMENT","ESCAPE","UNRESERVED","OTHER_CHARS","PCT_ENCODED","IPV4ADDRESS","IPV6ADDRESS","URI_PROTOCOL","IRI_PROTOCOL","slicedToArray","sliceIterator","arr","i","_arr","_n","_d","_e","_s","_i","Symbol","next","done","err","isArray","TypeError","toConsumableArray","arr2","maxInt","base","tMin","tMax","skew","damp","initialBias","initialN","delimiter","regexPunycode","regexNonASCII","regexSeparators","errors","baseMinusTMin","floor","Math","stringFromCharCode","String","fromCharCode","error$1","RangeError","map","array","fn","result","mapDomain","string","parts","replace","labels","encoded","ucs2decode","output","counter","charCodeAt","extra","ucs2encode","fromCodePoint","basicToDigit","codePoint","digitToBasic","digit","flag","adapt","delta","numPoints","firstTime","k","decode","input","inputLength","n","bias","basic","lastIndexOf","j","index","oldi","w","t","baseMinusT","out","splice","encode","_iteratorNormalCompletion","_didIteratorError","_iteratorError","_step","_iterator","_currentValue2","return","basicLength","handledCPCount","m","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","_step2","_iterator2","currentValue","handledCPCountPlusOne","_iteratorNormalCompletion3","_didIteratorError3","_iteratorError3","_step3","_iterator3","_currentValue","q","qMinusT","toUnicode","test","toASCII","punycode","SCHEMES","pctEncChar","chr","c","e","pctDecChars","newStr","il","parseInt","substr","c2","_c","c3","_normalizeComponentEncoding","components","protocol","decodeUnreserved","decStr","match","scheme","userinfo","host","path","query","fragment","_stripLeadingZeros","_normalizeIPv4","matches","_matches","address","_normalizeIPv6","_matches2","zone","_address$toLowerCase$","reverse","_address$toLowerCase$2","last","first","firstFields","lastFields","isLastFieldIPv4Address","fieldCount","lastFieldsStart","fields","allZeroFields","reduce","acc","field","lastLongest","longestZeroFields","sort","a","b","newHost","newFirst","newLast","URI_PARSE","NO_MATCH_IS_UNDEFINED","parse","uriString","options","iri","reference","port","isNaN","indexOf","error","schemeHandler","unicodeSupport","domainHost","_recomposeAuthority","uriTokens","_","$1","$2","RDS1","RDS2","RDS3","RDS5","removeDotSegments","im","s","serialize","authority","charAt","absolutePath","resolveComponents","relative","skipNormalization","tolerant","resolve","baseURI","relativeURI","schemelessOptions","normalize","uri","equal","uriA","uriB","escapeComponent","unescapeComponent","handler","secure","handler$1","isSecure","wsComponents","handler$2","resourceName","_wsComponents$resourc","_wsComponents$resourc2","handler$3","O","ATEXT$$","QTEXT$$","VCHAR$$","SOME_DELIMS$$","NOT_LOCAL_PART","NOT_HFNAME","NOT_HFVALUE","handler$4","mailtoComponents","to","unknownHeaders","headers","hfields","hfield","toAddrs","_x","_xl","subject","body","_x2","_xl2","addr","toAddr","atIdx","localPart","domain","name","URN_PARSE","handler$5","urnComponents","nid","nss","urnScheme","uriComponents","UUID","handler$6","uuidComponents","uuid","defineProperty","queueMicrotask","dp_resolve","fk","then","catch","e_callback","setTimeout","e_define","string_decoder","quad","_kt_subject","_kt_predicate","_kt_object","_kt_graph","RT_PREFIXED_NAME_NAMESPACE_VALID","RT_PREFIXED_NAME_LOCAL_NAME_VALID","RT_BLANK_NODE_VALID","RT_NAMED_NODE_VALID","RT_NAMED_NODE_ESCAPELESS_VALID","R_UNICODE_ANY","F_REPLACE_UNICODE_ANY","s_","s_4","s_8","OPHOP","hasOwnProperty","R_PREFIXED_NAME_QUICK","R_PREFIXED_NAME_ESCAPELESS","R_PREFIXED_NAME","R_PN_LOCAL_ESCAPES","R_BLANK_NODE_LABEL","R_BLANK_NODE_LABEL_TERMINAL","R_IRIREF_ESCAPELESS","R_IRIREF","R_NUMERIC_LITERAL","R_BOOLEAN_LITERAL","R_A","R_DOUBLE_CARET","R_WS","R_LANGTAG","R_PREFIX_KEYWORD","R_PREFIX_ID","R_BASE_KEYWORD","R_GRAPH_IRI_ESCAPELESS","R_GRAPH_PREFIXED_NAME","R_GRAPH_LABELED_BLANK_NODE","R_GRAPH_ANONYMOUS_BLANK_NODE","R_GRAPH_IRI","R_GRAPH","R_COMMENT","RT_IRI_ABSOLUTE","R_BASE_IRI","R_ANONYMOUS_BLANK_NODE","R_CHAR_BLANK_NODE","R_CHAR_COLLECTION","R_CHAR_KET","R_CHAR_OPEN","R_CHAR_CLOSE","R_CHAR_STOP","R_STRLIT_SHORT_DOUBLE_BREAK","R_STRLIT_SHORT_SINGLE_BREAK","R_STRLIT_LONG_DOUBLE_UNFINISHED_TERM","R_STRLIT_LONG_SINGLE_UNFINISHED_TERM","R_STRLIT_LONG_DOUBLE_BREAK","R_STRLIT_LONG_SINGLE_BREAK","F_REPLACE_STRLIT_CONTENTS","s_whitespace","s_auto","s_invalid","console","assert","R_STRLIT_SHORT_CONTENTS_ESCAPES_HARD","R_STRLIT_SHORT_CONTENTS_ESCAPES_SOFT","unescape_literal_short_hard","s_literal","unescape_literal_short_soft","m_incomplete","R_STRLIT_ESCAPE_INCOMPLETE","i_safe","R_STRLIT_LONG_CONTENTS_ESCAPES_HARD","R_STRLIT_LONG_CONTENTS_ESCAPES_SOFT","unescape_literal_long_hard","unescape_literal_long_soft","R_STRLIT_SHORT_DOUBLE_TERM","R_STRLIT_SHORT_SINGLE_TERM","R_STRLIT_LONG_DOUBLE_TERM","R_STRLIT_LONG_SINGLE_TERM","RegExp_$lookbehind_polyfill","s_input","m_match","i_start","mk_lookbehind_regex","e_compile","f_lookbehind","r_polyfill","f_polyfill","match_prefixed_name_escapeless","lastIndex","match_prefixed_name","Reader$syntax_error","k_self","si_state","s_info","i_off","min","abs","repeat","TriG_Reader","g_impls","flush","transform","ds_out","ds_dst","isGraphyWritable","quads_to_writable","quads_to_json","Reader","g_config","g_input","state","g_state","blank_node_index","i_anon","prefixes","h_prefixes","h_labels","dc_factory","adopt","dataFactory","data_factory","unfiltered","kt_default_graph","defaultGraph","create","kt_rdf_first","namedNode","blankNode","emit_data","ds_transform","pre","prepend","_b_debug","debug","_b_relax","relax","_dc_factory","_f_state","block","_h_prefixes","_b_destroyed","_s_base_url","_s_base_url_scheme","_s_base_url_root","_s_base_url_path","_s_literal","_kt_rdf_type","_kt_rdf_first","_kt_rdf_rest","_kt_rdf_nil","_kt_default_graph","_a_nested","_h_labels","event","data","restore_data","_a_queue_event","_b_expecting_full_stop","_s_temp_prefix_id","_b_trim_start","anonymous_blank_node","s_label","eos","after_end_of_statement","post_object","_n_max_token_length","max_token_length","maxTokenLength","_n_max_string_length","max_string_length","maxStringLength","Infinity","_b_byte_tracking","byte_tracking","byteTracking","_nb_seen","_nb_last","_nb_curr","relaxed","warn","stack","z_label_state","next_label","check_named_node","check_named_node_escapeless","p_iri","m_prefixed_name_e","im_prefixed_name_e","m_prefixed_name","im_prefixed_name","named_node","prefixed_name","si_prefix","s_suffix","p_set_base_uri","base_uri","baseUri","base_iri","baseIri","baseIRI","m_base_iri","base_url","baseUrl","baseURL","fke_chunk","safe_parse","fke_flush","eof","e_eof","_ds_input","b_byte_tracking","f_write","d_decoder","StringDecoder","f_write_track","nb_chunk","f_decode_write_track","f_decode_write","nb_post","ib_post","byteRange","emit_comments","s_captured","a_comments","s_comment","bind","f_sync","args","s_message","s_expected","b_eof","a_queue","h_event","parse_error","m_comment","prefix","enter","exit","comment","read","progress","finish","statement","equals","pairs","m_pnq_subject","s_prefix_id","m_iriref_e_subject","s_iri","aw_valid_this_match_prefixed_name_escapeless","m_prefixed_named_e_subject","im_prefixed_named_e_subject","m_blank_node_label_subject","blank_node","collection_subject","m_iriref_subject","aw_valid_this_match_prefixed_name","m_prefixed_named_subject","im_prefixed_named_subject","m_graph_iriref_e_graph","m_graph_prefixed_name","m_graph_anonymous_blank_node","m_graph_labeled_blank_node","m_iriref_e_graph_subject","graph_or_subject","graph_or_subject_property_list","m_prefix_keyword","prefix_id","m_base_keyword","m_graph_iriref_graph","graph_keyword","graph_or_subject_anon","m_prefixed_named_e_graph","im_prefixed_named_e_graph","graph_post_name","m_iriref_e_graph","m_blank_node_label_graph","m_iriref_graph","m_prefixed_named_graph","im_prefixed_named_graph","m_iriref_e_predicate","object_list","m_prefixed_named_e_predicate","im_prefixed_named_e_predicate","s_resume_state","m_iriref_predicate","m_prefixed_named_predicate","im_prefixed_named_predicate","string_literal_long_double","string_literal_short_double","m_pnq_object","m_iriref_e_object","m_prefixed_named_e_object","im_prefixed_named_e_object","string_literal_long_single","string_literal_short_single","m_numeric_literal","double","decimal","integer","m_boolean_literal","boolean","kt_blank_node","m_blank_node_label_object","collection_object","m_iriref_object","m_prefixed_named_object","im_prefixed_named_object","m_break","i_break","datatype_or_langtag","m_term","i_term","s_dirty","s_clean","s_incomplete","info_error","m_unfinished","string_literal","datatype","m_langtag","languagedLiteral","simpleLiteral","kt_datatype","m_pnq_datatype","m_iriref_e_datatype","p_datatype","m_prefixed_named_e_datatype","im_prefixed_named_e_datatype","m_iriref_datatype","m_prefixed_named_datatype","im_prefixed_named_datatype","datatypedLiteral","i_reset","s_peek","m_iriref_e_base","full_stop","m_iriref_base","m_prefix_id","prefix_iri","p_prefix_iri","m_iriref_e_prefix","b_relax","prefix_change","m_iriref_prefix","s_pointer_label","post_blank_subject","b_pushed","kt_blank_node_outer","w_object","booelan","a_recent","demolish","z_arg_0","pipeTo"],"mappings":"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","file":"js/chunk-ef895186.cc058e88.js","sourcesContent":["const stream = require('readable-stream');\n\n\n\nclass Readable extends stream.Readable {\n\tconstructor(gc_readable={}) {\n\t\tsuper(gc_readable);\n\n\t\t// use iterator\n\t\tif(gc_readable.iterator) {\n\t\t\tthrow new Error('readable stream iterator shortcut not yet implemented');\n\t\t}\n\t}\n\n\tuntil(s_event, b_return_stream) {\n\t\treturn new Promise((fk_until, fe_until) => {\n\t\t\t// convert error to rejected promise\n\t\t\tthis.on('error', (e_stream) => {\n\t\t\t\tfe_until(e_stream);\n\t\t\t});\n\n\t\t\t// special cases returns `this`\n\t\t\tif(b_return_stream) {\n\t\t\t\tthis.once(s_event, (...a_args) => {\n\t\t\t\t\tfk_until(this, ...a_args);\n\t\t\t\t});\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.once(s_event, fk_until);\n\t\t\t}\n\t\t});\n\t}\n\n\tbucket(s_encoding='utf8') {\n\t\tlet g_readable = this._readableState;\n\n\t\t// object mode\n\t\tif(g_readable.objectMode) {\n\t\t\t// async operation\n\t\t\treturn new Promise((fk_bucket, fe_bucket) => {\n\t\t\t\tlet a_data = [];\n\n\t\t\t\t// pipe to writable\n\t\t\t\tthis.pipe(new stream.Writable({\n\t\t\t\t\twrite(w_event, s_write_encoding, fk_write) {\n\t\t\t\t\t\ta_data.push(w_event);\n\t\t\t\t\t\tfk_write();\n\t\t\t\t\t},\n\n\t\t\t\t\twritev(a_chunks, fk_writev) {\n\t\t\t\t\t\ta_data.push(...a_chunks);\n\t\t\t\t\t\tfk_writev();\n\t\t\t\t\t},\n\t\t\t\t}))\n\t\t\t\t\t// error\n\t\t\t\t\t.on('error', (e_stream) => {\n\t\t\t\t\t\tfe_bucket(e_stream);\n\t\t\t\t\t})\n\t\t\t\t\t// wait for it to finish\n\t\t\t\t\t.on('finish', () => {\n\t\t\t\t\t\tfk_bucket(a_data);\n\t\t\t\t\t});\n\t\t\t});\n\t\t}\n\t\t// utf8-encoded strings\n\t\telse if('utf8' === s_encoding || 'utf-8' === s_encoding) {\n\t\t\t// async operation\n\t\t\treturn new Promise((fk_bucket, fe_bucket) => {\n\t\t\t\tlet s_data = '';\n\n\t\t\t\t// set encoding\n\t\t\t\tthis.setEncoding(s_encoding);\n\n\t\t\t\t// pipe to writable\n\t\t\t\tthis.pipe(new stream.Writable({\n\t\t\t\t\tdecodeStrings: false,\n\n\t\t\t\t\twrite(s_chunk, s_write_encoding, fk_write) {\n\t\t\t\t\t\ts_data += s_chunk;\n\t\t\t\t\t\tfk_write();\n\t\t\t\t\t},\n\n\t\t\t\t\twritev(a_chunks, fk_writev) {\n\t\t\t\t\t\ts_data += a_chunks.join('');\n\t\t\t\t\t\tfk_writev();\n\t\t\t\t\t},\n\t\t\t\t}))\n\t\t\t\t\t// error\n\t\t\t\t\t.on('error', (e_stream) => {\n\t\t\t\t\t\tfe_bucket(e_stream);\n\t\t\t\t\t})\n\t\t\t\t\t// wait for it to finish\n\t\t\t\t\t.on('finish', () => {\n\t\t\t\t\t\tfk_bucket(s_data);\n\t\t\t\t\t});\n\t\t\t});\n\t\t}\n\t\t// buffer\n\t\telse if('buffer' === s_encoding) {\n\t\t\t// async operation\n\t\t\treturn new Promise((fk_bucket, fe_bucket) => {\n\t\t\t\tlet ab_data = Buffer.from([]);\n\n\t\t\t\t// pipe to writable\n\t\t\t\tthis.pipe(new stream.Writable({\n\t\t\t\t\tdecodeStrings: true,\n\n\t\t\t\t\twrite(ab_chunk, s_write_encoding, fk_write) {\n\t\t\t\t\t\tab_data = Buffer.concat([ab_data, ab_chunk], ab_data.length+ab_chunk.length);\n\t\t\t\t\t\tfk_write();\n\t\t\t\t\t},\n\t\t\t\t}))\n\t\t\t\t\t// error\n\t\t\t\t\t.on('error', (e_stream) => {\n\t\t\t\t\t\tfe_bucket(e_stream);\n\t\t\t\t\t})\n\t\t\t\t\t// wait for it to finish\n\t\t\t\t\t.on('finish', () => {\n\t\t\t\t\t\tfk_bucket(ab_data);\n\t\t\t\t\t});\n\t\t\t});\n\t\t}\n\t}\n}\n\nclass Writable extends stream.Writable {\n\tuntil(s_event, b_return_stream) {\n\t\treturn new Promise((fk_until, fe_until) => {\n\t\t\t// convert error to rejected promise\n\t\t\tthis.on('error', (e_stream) => {\n\t\t\t\tfe_until(e_stream);\n\t\t\t});\n\n\t\t\t// special cases returns `this`\n\t\t\tif(b_return_stream) {\n\t\t\t\tthis.once(s_event, (...a_args) => {\n\t\t\t\t\tfk_until(this, ...a_args);\n\t\t\t\t});\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.once(s_event, fk_until);\n\t\t\t}\n\t\t});\n\t}\n\n\t// rdfjs impl\n\timport(ds_source) {\n\t\tds_source\n\t\t\t.on('data', w_chunk => this.write(w_chunk))\n\t\t\t.on('end', () => this.end())\n\t\t\t.on('error', e_read => this.emit('error', e_read));\n\n\t\treturn this;\n\t}\n}\n\nclass Duplex extends stream.Duplex {\n\tuntil(s_event, b_return_stream) {\n\t\treturn new Promise((fk_until, fe_until) => {\n\t\t\t// convert error to rejected promise\n\t\t\tthis.on('error', (e_stream) => {\n\t\t\t\tfe_until(e_stream);\n\t\t\t});\n\n\t\t\t// special cases returns `this`\n\t\t\tif(b_return_stream) {\n\t\t\t\tthis.once(s_event, (...a_args) => {\n\t\t\t\t\tfk_until(this, ...a_args);\n\t\t\t\t});\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.once(s_event, fk_until);\n\t\t\t}\n\t\t});\n\t}\n\n\tbucket(s_encoding='utf8') {\n\t\tlet g_readable = this._readableState;\n\n\t\t// object mode\n\t\tif(g_readable.objectMode) {\n\t\t\t// async operation\n\t\t\treturn new Promise((fk_bucket, fe_bucket) => {\n\t\t\t\tlet a_data = [];\n\n\t\t\t\t// pipe to writable\n\t\t\t\tthis.pipe(new stream.Writable({\n\t\t\t\t\twrite(w_event, s_write_encoding, fk_write) {\n\t\t\t\t\t\ta_data.push(w_event);\n\t\t\t\t\t\tfk_write();\n\t\t\t\t\t},\n\n\t\t\t\t\twritev(a_chunks, fk_writev) {\n\t\t\t\t\t\ta_data.push(...a_chunks);\n\t\t\t\t\t\tfk_writev();\n\t\t\t\t\t},\n\t\t\t\t}))\n\t\t\t\t\t// error\n\t\t\t\t\t.on('error', (e_stream) => {\n\t\t\t\t\t\tfe_bucket(e_stream);\n\t\t\t\t\t})\n\t\t\t\t\t// wait for it to finish\n\t\t\t\t\t.on('finish', () => {\n\t\t\t\t\t\tfk_bucket(a_data);\n\t\t\t\t\t});\n\t\t\t});\n\t\t}\n\t\t// utf8-encoded strings\n\t\telse if('utf8' === s_encoding || 'utf-8' === s_encoding) {\n\t\t\t// async operation\n\t\t\treturn new Promise((fk_bucket, fe_bucket) => {\n\t\t\t\tlet s_data = '';\n\n\t\t\t\t// set encoding\n\t\t\t\tthis.setEncoding(s_encoding);\n\n\t\t\t\t// pipe to writable\n\t\t\t\tthis.pipe(new stream.Writable({\n\t\t\t\t\tdecodeStrings: false,\n\n\t\t\t\t\twrite(s_chunk, s_write_encoding, fk_write) {\n\t\t\t\t\t\ts_data += s_chunk;\n\t\t\t\t\t\tfk_write();\n\t\t\t\t\t},\n\n\t\t\t\t\twritev(a_chunks, fk_writev) {\n\t\t\t\t\t\ts_data += a_chunks.join('');\n\t\t\t\t\t\tfk_writev();\n\t\t\t\t\t},\n\t\t\t\t}))\n\t\t\t\t\t// error\n\t\t\t\t\t.on('error', (e_stream) => {\n\t\t\t\t\t\tfe_bucket(e_stream);\n\t\t\t\t\t})\n\t\t\t\t\t// wait for it to finish\n\t\t\t\t\t.on('finish', () => {\n\t\t\t\t\t\tfk_bucket(s_data);\n\t\t\t\t\t});\n\t\t\t});\n\t\t}\n\t\t// buffer\n\t\telse if('buffer' === s_encoding) {\n\t\t\t// async operation\n\t\t\treturn new Promise((fk_bucket, fe_bucket) => {\n\t\t\t\tlet ab_data = Buffer.from([]);\n\n\t\t\t\t// pipe to writable\n\t\t\t\tthis.pipe(new stream.Writable({\n\t\t\t\t\tdecodeStrings: true,\n\n\t\t\t\t\twrite(ab_chunk, s_write_encoding, fk_write) {\n\t\t\t\t\t\tab_data = Buffer.concat([ab_data, ab_chunk], ab_data.length+ab_chunk.length);\n\t\t\t\t\t\tfk_write();\n\t\t\t\t\t},\n\t\t\t\t}))\n\t\t\t\t\t// error\n\t\t\t\t\t.on('error', (e_stream) => {\n\t\t\t\t\t\tfe_bucket(e_stream);\n\t\t\t\t\t})\n\t\t\t\t\t// wait for it to finish\n\t\t\t\t\t.on('finish', () => {\n\t\t\t\t\t\tfk_bucket(ab_data);\n\t\t\t\t\t});\n\t\t\t});\n\t\t}\n\t}\n}\n\nclass Transform extends stream.Transform {\n\tuntil(s_event, b_return_stream) {\n\t\treturn new Promise((fk_until, fe_until) => {\n\t\t\t// convert error to rejected promise\n\t\t\tthis.on('error', (e_stream) => {\n\t\t\t\tfe_until(e_stream);\n\t\t\t});\n\n\t\t\t// special cases returns `this`\n\t\t\tif(b_return_stream) {\n\t\t\t\tthis.once(s_event, (...a_args) => {\n\t\t\t\t\tfk_until(this, ...a_args);\n\t\t\t\t});\n\t\t\t}\n\t\t\telse {\n\t\t\t\tthis.once(s_event, fk_until);\n\t\t\t}\n\t\t});\n\t}\n\n\tbucket(s_encoding='utf8') {\n\t\tlet g_readable = this._readableState;\n\n\t\t// object mode\n\t\tif(g_readable.objectMode) {\n\t\t\t// async operation\n\t\t\treturn new Promise((fk_bucket, fe_bucket) => {\n\t\t\t\tlet a_data = [];\n\n\t\t\t\t// pipe to writable\n\t\t\t\tthis.pipe(new stream.Writable({\n\t\t\t\t\twrite(w_event, s_write_encoding, fk_write) {\n\t\t\t\t\t\ta_data.push(w_event);\n\t\t\t\t\t\tfk_write();\n\t\t\t\t\t},\n\n\t\t\t\t\twritev(a_chunks, fk_writev) {\n\t\t\t\t\t\ta_data.push(...a_chunks);\n\t\t\t\t\t\tfk_writev();\n\t\t\t\t\t},\n\t\t\t\t}))\n\t\t\t\t\t// error\n\t\t\t\t\t.on('error', (e_stream) => {\n\t\t\t\t\t\tfe_bucket(e_stream);\n\t\t\t\t\t})\n\t\t\t\t\t// wait for it to finish\n\t\t\t\t\t.on('finish', () => {\n\t\t\t\t\t\tfk_bucket(a_data);\n\t\t\t\t\t});\n\t\t\t});\n\t\t}\n\t\t// utf8-encoded strings\n\t\telse if('utf8' === s_encoding || 'utf-8' === s_encoding) {\n\t\t\t// async operation\n\t\t\treturn new Promise((fk_bucket, fe_bucket) => {\n\t\t\t\tlet s_data = '';\n\n\t\t\t\t// set encoding\n\t\t\t\tthis.setEncoding(s_encoding);\n\n\t\t\t\t// pipe to writable\n\t\t\t\tthis.pipe(new stream.Writable({\n\t\t\t\t\tdecodeStrings: false,\n\n\t\t\t\t\twrite(s_chunk, s_write_encoding, fk_write) {\n\t\t\t\t\t\ts_data += s_chunk;\n\t\t\t\t\t\tfk_write();\n\t\t\t\t\t},\n\n\t\t\t\t\twritev(a_chunks, fk_writev) {\n\t\t\t\t\t\ts_data += a_chunks.join('');\n\t\t\t\t\t\tfk_writev();\n\t\t\t\t\t},\n\t\t\t\t}))\n\t\t\t\t\t// error\n\t\t\t\t\t.on('error', (e_stream) => {\n\t\t\t\t\t\tfe_bucket(e_stream);\n\t\t\t\t\t})\n\t\t\t\t\t// wait for it to finish\n\t\t\t\t\t.on('finish', () => {\n\t\t\t\t\t\tfk_bucket(s_data);\n\t\t\t\t\t});\n\t\t\t});\n\t\t}\n\t\t// buffer\n\t\telse if('buffer' === s_encoding) {\n\t\t\t// async operation\n\t\t\treturn new Promise((fk_bucket, fe_bucket) => {\n\t\t\t\tlet ab_data = Buffer.from([]);\n\n\t\t\t\t// pipe to writable\n\t\t\t\tthis.pipe(new stream.Writable({\n\t\t\t\t\tdecodeStrings: true,\n\n\t\t\t\t\twrite(ab_chunk, s_write_encoding, fk_write) {\n\t\t\t\t\t\tab_data = Buffer.concat([ab_data, ab_chunk], ab_data.length+ab_chunk.length);\n\t\t\t\t\t\tfk_write();\n\t\t\t\t\t},\n\t\t\t\t}))\n\t\t\t\t\t// error\n\t\t\t\t\t.on('error', (e_stream) => {\n\t\t\t\t\t\tfe_bucket(e_stream);\n\t\t\t\t\t})\n\t\t\t\t\t// wait for it to finish\n\t\t\t\t\t.on('finish', () => {\n\t\t\t\t\t\tfk_bucket(ab_data);\n\t\t\t\t\t});\n\t\t\t});\n\t\t}\n\t}\n\n\t// rdfjs impl\n\timport(ds_source) {\n\t\tds_source\n\t\t\t.on('data', w_chunk => this.write(w_chunk))\n\t\t\t.on('end', () => this.end())\n\t\t\t.on('error', e_read => this.emit('error', e_read));\n\n\t\treturn this;\n\t}\n\n\tdemolish(e_destroy) {\n\t\t// do not allow to push\n\t\tthis.push = (z_chunk) => {\n\t\t\t// ignore eof signals from node core\n\t\t\tif(null === z_chunk) return;\n\n\t\t\t// anything else is bad\n\t\t\tthrow new Error(`[ERR_STREAM_DESTROYED]: Cannot push after stream was destroyed`);\n\t\t};\n\n\t\t// do not allow to emit 'end'\n\t\tthis.emit = function(s_event, ...a_args) {\n\t\t\tif('end' === s_event) return;\n\n\t\t\tObject.getPrototypeOf(this).emit.apply(this, [s_event, ...a_args]);\n\t\t};\n\n\t\t// an error was given, destroy the stream as well\n\t\tif(e_destroy) {\n\t\t\treturn stream.Transform.prototype.destroy.call(this, e_destroy);\n\t\t}\n\t}\n}\n\n// eslint-disable-next-line no-new-func\nconst b_is_node = (new Function(/* syntax: js */ `try {return this===global;}catch(e){return false;}`))();\n\n// deduce the runtime environment\nconst [B_BROWSER, B_BROWSERIFY] = (() => 'undefined' === typeof process\n\t? [true, false]\n\t: (process.browser\n\t\t? [true, true]\n\t\t: ('undefined' === process.versions || 'undefined' === process.versions.node\n\t\t\t? [true, false]\n\t\t\t: [false, false])))();\n\n// node.js or browserify; patch for node < v10\nif(B_BROWSERIFY || (b_is_node && (+(/^v(\\d+)/.exec(process.version)[1])) < 10)) {\n\t// override destroy methods\n\tTransform.prototype.destroy = Duplex.prototype.destroy = function(e_destroy, fke_destroy) {\n\t\tthis._readableState.destroyed = true;\n\t\tthis._writableState.destroyed = true;\n\n\t\tlet f_emit_close = () => {\n\t\t\tif(!this._writableState.emitClose) return;\n\t\t\tif(!this._readableState.emitClose) return;\n\t\t\tthis.emit('close');\n\t\t};\n\n\t\tthis._destroy(e_destroy || null, (e_destroy_re) => {\n\t\t\tif(!fke_destroy && e_destroy_re) {\n\t\t\t\tprocess.nextTick(() => {\n\t\t\t\t\tthis.emit('error', e_destroy_re);\n\t\t\t\t\tf_emit_close();\n\t\t\t\t});\n\t\t\t\tthis._writableState.errorEmitted = true;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tprocess.nextTick(f_emit_close);\n\t\t\t\tif(fke_destroy) fke_destroy(e_destroy_re);\n\t\t\t}\n\t\t});\n\n\t\treturn this;\n\t};\n\n\t// override default _destroy implementations\n\tTransform.prototype._destroy = Duplex.prototype._destroy = (e_destroy, fke_destroy) => fke_destroy(e_destroy);\n}\n\nclass QuadsToOther extends Transform {\n\tconstructor(gc_transform={}) {\n\t\tsuper({\n\t\t\t...gc_transform,\n\t\t\twritableObjectMode: true,\n\t\t\treadableObjectMode: true,\n\t\t});\n\n\t\tthis._as_inputs = new Set();\n\n\t\t// forward prefix and comment events\n\t\tthis.on('pipe', (ds_src) => {\n\t\t\tthis._as_inputs.add(ds_src);\n\n\t\t\tds_src\n\t\t\t\t.on('prefix', (...a_args) => {\n\t\t\t\t\tthis.emit('prefix', ...a_args);\n\t\t\t\t})\n\t\t\t\t.on('comment', (...a_args) => {\n\t\t\t\t\tthis.emit('comment', ...a_args);\n\t\t\t\t});\n\t\t});\n\n\t\tthis.on('unpipe', (ds_src) => {\n\t\t\tthis._as_inputs.delete(ds_src);\n\t\t});\n\t}\n\n\t_destroy() {\n\t\tfor(let ds_input of this._as_inputs) {\n\t\t\tds_input.destroy();\n\t\t}\n\t}\n}\n\nclass Quads_To_JSON_Transform extends QuadsToOther {\n\t// serializse json\n\t_transform(g_quad, s_encoding, fk_transform) {\n\t\tfk_transform(null, JSON.stringify(g_quad.isolate())+'\\n');\n\t}\n}\n\nclass Quads_To_Writable extends QuadsToOther {\n\t_transform(g_quad, s_encoding, fk_transform) {\n\t\tfk_transform(null, {\n\t\t\ttype: 'quad',\n\t\t\tvalue: g_quad,\n\t\t});\n\t}\n}\n\nTransform.QuadsToOther = QuadsToOther;\n\nmodule.exports = {\n\t...stream,\n\tReadable,\n\tWritable,\n\tDuplex,\n\tTransform,\n\n\tQuadsToOther,\n\n\t// create a transform from quad objects into JSON strings for trivial serialization\n\tquads_to_json() {\n\t\treturn new Quads_To_JSON_Transform();\n\t},\n\n\t// create a transform from quad objects into writable data events\n\tquads_to_writable() {\n\t\treturn new Quads_To_Writable();\n\t},\n\n\t// create a simple, single-event readable stream\n\tsource(w_push, s_encoding=null) {\n\t\t// encoding not explicit, string given; assume utf8\n\t\tif(!s_encoding && 'string' === typeof w_push) s_encoding = 'utf8';\n\n\t\t// readable\n\t\treturn new Readable({\n\t\t\tobjectMode: !s_encoding && 'string' !== typeof w_push && !Buffer.isBuffer(w_push),\n\n\t\t\tread() {\n\t\t\t\tthis.push(w_push, s_encoding);\n\t\t\t\tthis.push(null);\n\t\t\t},\n\t\t});\n\t},\n};\n","/** @license URI.js v4.4.1 (c) 2011 Gary Court. License: http://github.com/garycourt/uri-js */\n(function (global, factory) {\n\ttypeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) :\n\ttypeof define === 'function' && define.amd ? define(['exports'], factory) :\n\t(factory((global.URI = global.URI || {})));\n}(this, (function (exports) { 'use strict';\n\nfunction merge() {\n    for (var _len = arguments.length, sets = Array(_len), _key = 0; _key < _len; _key++) {\n        sets[_key] = arguments[_key];\n    }\n\n    if (sets.length > 1) {\n        sets[0] = sets[0].slice(0, -1);\n        var xl = sets.length - 1;\n        for (var x = 1; x < xl; ++x) {\n            sets[x] = sets[x].slice(1, -1);\n        }\n        sets[xl] = sets[xl].slice(1);\n        return sets.join('');\n    } else {\n        return sets[0];\n    }\n}\nfunction subexp(str) {\n    return \"(?:\" + str + \")\";\n}\nfunction typeOf(o) {\n    return o === undefined ? \"undefined\" : o === null ? \"null\" : Object.prototype.toString.call(o).split(\" \").pop().split(\"]\").shift().toLowerCase();\n}\nfunction toUpperCase(str) {\n    return str.toUpperCase();\n}\nfunction toArray(obj) {\n    return obj !== undefined && obj !== null ? obj instanceof Array ? obj : typeof obj.length !== \"number\" || obj.split || obj.setInterval || obj.call ? [obj] : Array.prototype.slice.call(obj) : [];\n}\nfunction assign(target, source) {\n    var obj = target;\n    if (source) {\n        for (var key in source) {\n            obj[key] = source[key];\n        }\n    }\n    return obj;\n}\n\nfunction buildExps(isIRI) {\n    var ALPHA$$ = \"[A-Za-z]\",\n        CR$ = \"[\\\\x0D]\",\n        DIGIT$$ = \"[0-9]\",\n        DQUOTE$$ = \"[\\\\x22]\",\n        HEXDIG$$ = merge(DIGIT$$, \"[A-Fa-f]\"),\n        //case-insensitive\n    LF$$ = \"[\\\\x0A]\",\n        SP$$ = \"[\\\\x20]\",\n        PCT_ENCODED$ = subexp(subexp(\"%[EFef]\" + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$) + \"|\" + subexp(\"%[89A-Fa-f]\" + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$) + \"|\" + subexp(\"%\" + HEXDIG$$ + HEXDIG$$)),\n        //expanded\n    GEN_DELIMS$$ = \"[\\\\:\\\\/\\\\?\\\\#\\\\[\\\\]\\\\@]\",\n        SUB_DELIMS$$ = \"[\\\\!\\\\$\\\\&\\\\'\\\\(\\\\)\\\\*\\\\+\\\\,\\\\;\\\\=]\",\n        RESERVED$$ = merge(GEN_DELIMS$$, SUB_DELIMS$$),\n        UCSCHAR$$ = isIRI ? \"[\\\\xA0-\\\\u200D\\\\u2010-\\\\u2029\\\\u202F-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFEF]\" : \"[]\",\n        //subset, excludes bidi control characters\n    IPRIVATE$$ = isIRI ? \"[\\\\uE000-\\\\uF8FF]\" : \"[]\",\n        //subset\n    UNRESERVED$$ = merge(ALPHA$$, DIGIT$$, \"[\\\\-\\\\.\\\\_\\\\~]\", UCSCHAR$$),\n        SCHEME$ = subexp(ALPHA$$ + merge(ALPHA$$, DIGIT$$, \"[\\\\+\\\\-\\\\.]\") + \"*\"),\n        USERINFO$ = subexp(subexp(PCT_ENCODED$ + \"|\" + merge(UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:]\")) + \"*\"),\n        DEC_OCTET$ = subexp(subexp(\"25[0-5]\") + \"|\" + subexp(\"2[0-4]\" + DIGIT$$) + \"|\" + subexp(\"1\" + DIGIT$$ + DIGIT$$) + \"|\" + subexp(\"[1-9]\" + DIGIT$$) + \"|\" + DIGIT$$),\n        DEC_OCTET_RELAXED$ = subexp(subexp(\"25[0-5]\") + \"|\" + subexp(\"2[0-4]\" + DIGIT$$) + \"|\" + subexp(\"1\" + DIGIT$$ + DIGIT$$) + \"|\" + subexp(\"0?[1-9]\" + DIGIT$$) + \"|0?0?\" + DIGIT$$),\n        //relaxed parsing rules\n    IPV4ADDRESS$ = subexp(DEC_OCTET_RELAXED$ + \"\\\\.\" + DEC_OCTET_RELAXED$ + \"\\\\.\" + DEC_OCTET_RELAXED$ + \"\\\\.\" + DEC_OCTET_RELAXED$),\n        H16$ = subexp(HEXDIG$$ + \"{1,4}\"),\n        LS32$ = subexp(subexp(H16$ + \"\\\\:\" + H16$) + \"|\" + IPV4ADDRESS$),\n        IPV6ADDRESS1$ = subexp(subexp(H16$ + \"\\\\:\") + \"{6}\" + LS32$),\n        //                           6( h16 \":\" ) ls32\n    IPV6ADDRESS2$ = subexp(\"\\\\:\\\\:\" + subexp(H16$ + \"\\\\:\") + \"{5}\" + LS32$),\n        //                      \"::\" 5( h16 \":\" ) ls32\n    IPV6ADDRESS3$ = subexp(subexp(H16$) + \"?\\\\:\\\\:\" + subexp(H16$ + \"\\\\:\") + \"{4}\" + LS32$),\n        //[               h16 ] \"::\" 4( h16 \":\" ) ls32\n    IPV6ADDRESS4$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,1}\" + H16$) + \"?\\\\:\\\\:\" + subexp(H16$ + \"\\\\:\") + \"{3}\" + LS32$),\n        //[ *1( h16 \":\" ) h16 ] \"::\" 3( h16 \":\" ) ls32\n    IPV6ADDRESS5$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,2}\" + H16$) + \"?\\\\:\\\\:\" + subexp(H16$ + \"\\\\:\") + \"{2}\" + LS32$),\n        //[ *2( h16 \":\" ) h16 ] \"::\" 2( h16 \":\" ) ls32\n    IPV6ADDRESS6$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,3}\" + H16$) + \"?\\\\:\\\\:\" + H16$ + \"\\\\:\" + LS32$),\n        //[ *3( h16 \":\" ) h16 ] \"::\"    h16 \":\"   ls32\n    IPV6ADDRESS7$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,4}\" + H16$) + \"?\\\\:\\\\:\" + LS32$),\n        //[ *4( h16 \":\" ) h16 ] \"::\"              ls32\n    IPV6ADDRESS8$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,5}\" + H16$) + \"?\\\\:\\\\:\" + H16$),\n        //[ *5( h16 \":\" ) h16 ] \"::\"              h16\n    IPV6ADDRESS9$ = subexp(subexp(subexp(H16$ + \"\\\\:\") + \"{0,6}\" + H16$) + \"?\\\\:\\\\:\"),\n        //[ *6( h16 \":\" ) h16 ] \"::\"\n    IPV6ADDRESS$ = subexp([IPV6ADDRESS1$, IPV6ADDRESS2$, IPV6ADDRESS3$, IPV6ADDRESS4$, IPV6ADDRESS5$, IPV6ADDRESS6$, IPV6ADDRESS7$, IPV6ADDRESS8$, IPV6ADDRESS9$].join(\"|\")),\n        ZONEID$ = subexp(subexp(UNRESERVED$$ + \"|\" + PCT_ENCODED$) + \"+\"),\n        //RFC 6874\n    IPV6ADDRZ$ = subexp(IPV6ADDRESS$ + \"\\\\%25\" + ZONEID$),\n        //RFC 6874\n    IPV6ADDRZ_RELAXED$ = subexp(IPV6ADDRESS$ + subexp(\"\\\\%25|\\\\%(?!\" + HEXDIG$$ + \"{2})\") + ZONEID$),\n        //RFC 6874, with relaxed parsing rules\n    IPVFUTURE$ = subexp(\"[vV]\" + HEXDIG$$ + \"+\\\\.\" + merge(UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:]\") + \"+\"),\n        IP_LITERAL$ = subexp(\"\\\\[\" + subexp(IPV6ADDRZ_RELAXED$ + \"|\" + IPV6ADDRESS$ + \"|\" + IPVFUTURE$) + \"\\\\]\"),\n        //RFC 6874\n    REG_NAME$ = subexp(subexp(PCT_ENCODED$ + \"|\" + merge(UNRESERVED$$, SUB_DELIMS$$)) + \"*\"),\n        HOST$ = subexp(IP_LITERAL$ + \"|\" + IPV4ADDRESS$ + \"(?!\" + REG_NAME$ + \")\" + \"|\" + REG_NAME$),\n        PORT$ = subexp(DIGIT$$ + \"*\"),\n        AUTHORITY$ = subexp(subexp(USERINFO$ + \"@\") + \"?\" + HOST$ + subexp(\"\\\\:\" + PORT$) + \"?\"),\n        PCHAR$ = subexp(PCT_ENCODED$ + \"|\" + merge(UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:\\\\@]\")),\n        SEGMENT$ = subexp(PCHAR$ + \"*\"),\n        SEGMENT_NZ$ = subexp(PCHAR$ + \"+\"),\n        SEGMENT_NZ_NC$ = subexp(subexp(PCT_ENCODED$ + \"|\" + merge(UNRESERVED$$, SUB_DELIMS$$, \"[\\\\@]\")) + \"+\"),\n        PATH_ABEMPTY$ = subexp(subexp(\"\\\\/\" + SEGMENT$) + \"*\"),\n        PATH_ABSOLUTE$ = subexp(\"\\\\/\" + subexp(SEGMENT_NZ$ + PATH_ABEMPTY$) + \"?\"),\n        //simplified\n    PATH_NOSCHEME$ = subexp(SEGMENT_NZ_NC$ + PATH_ABEMPTY$),\n        //simplified\n    PATH_ROOTLESS$ = subexp(SEGMENT_NZ$ + PATH_ABEMPTY$),\n        //simplified\n    PATH_EMPTY$ = \"(?!\" + PCHAR$ + \")\",\n        PATH$ = subexp(PATH_ABEMPTY$ + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_NOSCHEME$ + \"|\" + PATH_ROOTLESS$ + \"|\" + PATH_EMPTY$),\n        QUERY$ = subexp(subexp(PCHAR$ + \"|\" + merge(\"[\\\\/\\\\?]\", IPRIVATE$$)) + \"*\"),\n        FRAGMENT$ = subexp(subexp(PCHAR$ + \"|[\\\\/\\\\?]\") + \"*\"),\n        HIER_PART$ = subexp(subexp(\"\\\\/\\\\/\" + AUTHORITY$ + PATH_ABEMPTY$) + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_ROOTLESS$ + \"|\" + PATH_EMPTY$),\n        URI$ = subexp(SCHEME$ + \"\\\\:\" + HIER_PART$ + subexp(\"\\\\?\" + QUERY$) + \"?\" + subexp(\"\\\\#\" + FRAGMENT$) + \"?\"),\n        RELATIVE_PART$ = subexp(subexp(\"\\\\/\\\\/\" + AUTHORITY$ + PATH_ABEMPTY$) + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_NOSCHEME$ + \"|\" + PATH_EMPTY$),\n        RELATIVE$ = subexp(RELATIVE_PART$ + subexp(\"\\\\?\" + QUERY$) + \"?\" + subexp(\"\\\\#\" + FRAGMENT$) + \"?\"),\n        URI_REFERENCE$ = subexp(URI$ + \"|\" + RELATIVE$),\n        ABSOLUTE_URI$ = subexp(SCHEME$ + \"\\\\:\" + HIER_PART$ + subexp(\"\\\\?\" + QUERY$) + \"?\"),\n        GENERIC_REF$ = \"^(\" + SCHEME$ + \")\\\\:\" + subexp(subexp(\"\\\\/\\\\/(\" + subexp(\"(\" + USERINFO$ + \")@\") + \"?(\" + HOST$ + \")\" + subexp(\"\\\\:(\" + PORT$ + \")\") + \"?)\") + \"?(\" + PATH_ABEMPTY$ + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_ROOTLESS$ + \"|\" + PATH_EMPTY$ + \")\") + subexp(\"\\\\?(\" + QUERY$ + \")\") + \"?\" + subexp(\"\\\\#(\" + FRAGMENT$ + \")\") + \"?$\",\n        RELATIVE_REF$ = \"^(){0}\" + subexp(subexp(\"\\\\/\\\\/(\" + subexp(\"(\" + USERINFO$ + \")@\") + \"?(\" + HOST$ + \")\" + subexp(\"\\\\:(\" + PORT$ + \")\") + \"?)\") + \"?(\" + PATH_ABEMPTY$ + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_NOSCHEME$ + \"|\" + PATH_EMPTY$ + \")\") + subexp(\"\\\\?(\" + QUERY$ + \")\") + \"?\" + subexp(\"\\\\#(\" + FRAGMENT$ + \")\") + \"?$\",\n        ABSOLUTE_REF$ = \"^(\" + SCHEME$ + \")\\\\:\" + subexp(subexp(\"\\\\/\\\\/(\" + subexp(\"(\" + USERINFO$ + \")@\") + \"?(\" + HOST$ + \")\" + subexp(\"\\\\:(\" + PORT$ + \")\") + \"?)\") + \"?(\" + PATH_ABEMPTY$ + \"|\" + PATH_ABSOLUTE$ + \"|\" + PATH_ROOTLESS$ + \"|\" + PATH_EMPTY$ + \")\") + subexp(\"\\\\?(\" + QUERY$ + \")\") + \"?$\",\n        SAMEDOC_REF$ = \"^\" + subexp(\"\\\\#(\" + FRAGMENT$ + \")\") + \"?$\",\n        AUTHORITY_REF$ = \"^\" + subexp(\"(\" + USERINFO$ + \")@\") + \"?(\" + HOST$ + \")\" + subexp(\"\\\\:(\" + PORT$ + \")\") + \"?$\";\n    return {\n        NOT_SCHEME: new RegExp(merge(\"[^]\", ALPHA$$, DIGIT$$, \"[\\\\+\\\\-\\\\.]\"), \"g\"),\n        NOT_USERINFO: new RegExp(merge(\"[^\\\\%\\\\:]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\n        NOT_HOST: new RegExp(merge(\"[^\\\\%\\\\[\\\\]\\\\:]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\n        NOT_PATH: new RegExp(merge(\"[^\\\\%\\\\/\\\\:\\\\@]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\n        NOT_PATH_NOSCHEME: new RegExp(merge(\"[^\\\\%\\\\/\\\\@]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\n        NOT_QUERY: new RegExp(merge(\"[^\\\\%]\", UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:\\\\@\\\\/\\\\?]\", IPRIVATE$$), \"g\"),\n        NOT_FRAGMENT: new RegExp(merge(\"[^\\\\%]\", UNRESERVED$$, SUB_DELIMS$$, \"[\\\\:\\\\@\\\\/\\\\?]\"), \"g\"),\n        ESCAPE: new RegExp(merge(\"[^]\", UNRESERVED$$, SUB_DELIMS$$), \"g\"),\n        UNRESERVED: new RegExp(UNRESERVED$$, \"g\"),\n        OTHER_CHARS: new RegExp(merge(\"[^\\\\%]\", UNRESERVED$$, RESERVED$$), \"g\"),\n        PCT_ENCODED: new RegExp(PCT_ENCODED$, \"g\"),\n        IPV4ADDRESS: new RegExp(\"^(\" + IPV4ADDRESS$ + \")$\"),\n        IPV6ADDRESS: new RegExp(\"^\\\\[?(\" + IPV6ADDRESS$ + \")\" + subexp(subexp(\"\\\\%25|\\\\%(?!\" + HEXDIG$$ + \"{2})\") + \"(\" + ZONEID$ + \")\") + \"?\\\\]?$\") //RFC 6874, with relaxed parsing rules\n    };\n}\nvar URI_PROTOCOL = buildExps(false);\n\nvar IRI_PROTOCOL = buildExps(true);\n\nvar slicedToArray = function () {\n  function sliceIterator(arr, i) {\n    var _arr = [];\n    var _n = true;\n    var _d = false;\n    var _e = undefined;\n\n    try {\n      for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) {\n        _arr.push(_s.value);\n\n        if (i && _arr.length === i) break;\n      }\n    } catch (err) {\n      _d = true;\n      _e = err;\n    } finally {\n      try {\n        if (!_n && _i[\"return\"]) _i[\"return\"]();\n      } finally {\n        if (_d) throw _e;\n      }\n    }\n\n    return _arr;\n  }\n\n  return function (arr, i) {\n    if (Array.isArray(arr)) {\n      return arr;\n    } else if (Symbol.iterator in Object(arr)) {\n      return sliceIterator(arr, i);\n    } else {\n      throw new TypeError(\"Invalid attempt to destructure non-iterable instance\");\n    }\n  };\n}();\n\n\n\n\n\n\n\n\n\n\n\n\n\nvar toConsumableArray = function (arr) {\n  if (Array.isArray(arr)) {\n    for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) arr2[i] = arr[i];\n\n    return arr2;\n  } else {\n    return Array.from(arr);\n  }\n};\n\n/** Highest positive signed 32-bit float value */\n\nvar maxInt = 2147483647; // aka. 0x7FFFFFFF or 2^31-1\n\n/** Bootstring parameters */\nvar base = 36;\nvar tMin = 1;\nvar tMax = 26;\nvar skew = 38;\nvar damp = 700;\nvar initialBias = 72;\nvar initialN = 128; // 0x80\nvar delimiter = '-'; // '\\x2D'\n\n/** Regular expressions */\nvar regexPunycode = /^xn--/;\nvar regexNonASCII = /[^\\0-\\x7E]/; // non-ASCII chars\nvar regexSeparators = /[\\x2E\\u3002\\uFF0E\\uFF61]/g; // RFC 3490 separators\n\n/** Error messages */\nvar errors = {\n\t'overflow': 'Overflow: input needs wider integers to process',\n\t'not-basic': 'Illegal input >= 0x80 (not a basic code point)',\n\t'invalid-input': 'Invalid input'\n};\n\n/** Convenience shortcuts */\nvar baseMinusTMin = base - tMin;\nvar floor = Math.floor;\nvar stringFromCharCode = String.fromCharCode;\n\n/*--------------------------------------------------------------------------*/\n\n/**\n * A generic error utility function.\n * @private\n * @param {String} type The error type.\n * @returns {Error} Throws a `RangeError` with the applicable error message.\n */\nfunction error$1(type) {\n\tthrow new RangeError(errors[type]);\n}\n\n/**\n * A generic `Array#map` utility function.\n * @private\n * @param {Array} array The array to iterate over.\n * @param {Function} callback The function that gets called for every array\n * item.\n * @returns {Array} A new array of values returned by the callback function.\n */\nfunction map(array, fn) {\n\tvar result = [];\n\tvar length = array.length;\n\twhile (length--) {\n\t\tresult[length] = fn(array[length]);\n\t}\n\treturn result;\n}\n\n/**\n * A simple `Array#map`-like wrapper to work with domain name strings or email\n * addresses.\n * @private\n * @param {String} domain The domain name or email address.\n * @param {Function} callback The function that gets called for every\n * character.\n * @returns {Array} A new string of characters returned by the callback\n * function.\n */\nfunction mapDomain(string, fn) {\n\tvar parts = string.split('@');\n\tvar result = '';\n\tif (parts.length > 1) {\n\t\t// In email addresses, only the domain name should be punycoded. Leave\n\t\t// the local part (i.e. everything up to `@`) intact.\n\t\tresult = parts[0] + '@';\n\t\tstring = parts[1];\n\t}\n\t// Avoid `split(regex)` for IE8 compatibility. See #17.\n\tstring = string.replace(regexSeparators, '\\x2E');\n\tvar labels = string.split('.');\n\tvar encoded = map(labels, fn).join('.');\n\treturn result + encoded;\n}\n\n/**\n * Creates an array containing the numeric code points of each Unicode\n * character in the string. While JavaScript uses UCS-2 internally,\n * this function will convert a pair of surrogate halves (each of which\n * UCS-2 exposes as separate characters) into a single code point,\n * matching UTF-16.\n * @see `punycode.ucs2.encode`\n * @see <https://mathiasbynens.be/notes/javascript-encoding>\n * @memberOf punycode.ucs2\n * @name decode\n * @param {String} string The Unicode input string (UCS-2).\n * @returns {Array} The new array of code points.\n */\nfunction ucs2decode(string) {\n\tvar output = [];\n\tvar counter = 0;\n\tvar length = string.length;\n\twhile (counter < length) {\n\t\tvar value = string.charCodeAt(counter++);\n\t\tif (value >= 0xD800 && value <= 0xDBFF && counter < length) {\n\t\t\t// It's a high surrogate, and there is a next character.\n\t\t\tvar extra = string.charCodeAt(counter++);\n\t\t\tif ((extra & 0xFC00) == 0xDC00) {\n\t\t\t\t// Low surrogate.\n\t\t\t\toutput.push(((value & 0x3FF) << 10) + (extra & 0x3FF) + 0x10000);\n\t\t\t} else {\n\t\t\t\t// It's an unmatched surrogate; only append this code unit, in case the\n\t\t\t\t// next code unit is the high surrogate of a surrogate pair.\n\t\t\t\toutput.push(value);\n\t\t\t\tcounter--;\n\t\t\t}\n\t\t} else {\n\t\t\toutput.push(value);\n\t\t}\n\t}\n\treturn output;\n}\n\n/**\n * Creates a string based on an array of numeric code points.\n * @see `punycode.ucs2.decode`\n * @memberOf punycode.ucs2\n * @name encode\n * @param {Array} codePoints The array of numeric code points.\n * @returns {String} The new Unicode string (UCS-2).\n */\nvar ucs2encode = function ucs2encode(array) {\n\treturn String.fromCodePoint.apply(String, toConsumableArray(array));\n};\n\n/**\n * Converts a basic code point into a digit/integer.\n * @see `digitToBasic()`\n * @private\n * @param {Number} codePoint The basic numeric code point value.\n * @returns {Number} The numeric value of a basic code point (for use in\n * representing integers) in the range `0` to `base - 1`, or `base` if\n * the code point does not represent a value.\n */\nvar basicToDigit = function basicToDigit(codePoint) {\n\tif (codePoint - 0x30 < 0x0A) {\n\t\treturn codePoint - 0x16;\n\t}\n\tif (codePoint - 0x41 < 0x1A) {\n\t\treturn codePoint - 0x41;\n\t}\n\tif (codePoint - 0x61 < 0x1A) {\n\t\treturn codePoint - 0x61;\n\t}\n\treturn base;\n};\n\n/**\n * Converts a digit/integer into a basic code point.\n * @see `basicToDigit()`\n * @private\n * @param {Number} digit The numeric value of a basic code point.\n * @returns {Number} The basic code point whose value (when used for\n * representing integers) is `digit`, which needs to be in the range\n * `0` to `base - 1`. If `flag` is non-zero, the uppercase form is\n * used; else, the lowercase form is used. The behavior is undefined\n * if `flag` is non-zero and `digit` has no uppercase form.\n */\nvar digitToBasic = function digitToBasic(digit, flag) {\n\t//  0..25 map to ASCII a..z or A..Z\n\t// 26..35 map to ASCII 0..9\n\treturn digit + 22 + 75 * (digit < 26) - ((flag != 0) << 5);\n};\n\n/**\n * Bias adaptation function as per section 3.4 of RFC 3492.\n * https://tools.ietf.org/html/rfc3492#section-3.4\n * @private\n */\nvar adapt = function adapt(delta, numPoints, firstTime) {\n\tvar k = 0;\n\tdelta = firstTime ? floor(delta / damp) : delta >> 1;\n\tdelta += floor(delta / numPoints);\n\tfor (; /* no initialization */delta > baseMinusTMin * tMax >> 1; k += base) {\n\t\tdelta = floor(delta / baseMinusTMin);\n\t}\n\treturn floor(k + (baseMinusTMin + 1) * delta / (delta + skew));\n};\n\n/**\n * Converts a Punycode string of ASCII-only symbols to a string of Unicode\n * symbols.\n * @memberOf punycode\n * @param {String} input The Punycode string of ASCII-only symbols.\n * @returns {String} The resulting string of Unicode symbols.\n */\nvar decode = function decode(input) {\n\t// Don't use UCS-2.\n\tvar output = [];\n\tvar inputLength = input.length;\n\tvar i = 0;\n\tvar n = initialN;\n\tvar bias = initialBias;\n\n\t// Handle the basic code points: let `basic` be the number of input code\n\t// points before the last delimiter, or `0` if there is none, then copy\n\t// the first basic code points to the output.\n\n\tvar basic = input.lastIndexOf(delimiter);\n\tif (basic < 0) {\n\t\tbasic = 0;\n\t}\n\n\tfor (var j = 0; j < basic; ++j) {\n\t\t// if it's not a basic code point\n\t\tif (input.charCodeAt(j) >= 0x80) {\n\t\t\terror$1('not-basic');\n\t\t}\n\t\toutput.push(input.charCodeAt(j));\n\t}\n\n\t// Main decoding loop: start just after the last delimiter if any basic code\n\t// points were copied; start at the beginning otherwise.\n\n\tfor (var index = basic > 0 ? basic + 1 : 0; index < inputLength;) /* no final expression */{\n\n\t\t// `index` is the index of the next character to be consumed.\n\t\t// Decode a generalized variable-length integer into `delta`,\n\t\t// which gets added to `i`. The overflow checking is easier\n\t\t// if we increase `i` as we go, then subtract off its starting\n\t\t// value at the end to obtain `delta`.\n\t\tvar oldi = i;\n\t\tfor (var w = 1, k = base;; /* no condition */k += base) {\n\n\t\t\tif (index >= inputLength) {\n\t\t\t\terror$1('invalid-input');\n\t\t\t}\n\n\t\t\tvar digit = basicToDigit(input.charCodeAt(index++));\n\n\t\t\tif (digit >= base || digit > floor((maxInt - i) / w)) {\n\t\t\t\terror$1('overflow');\n\t\t\t}\n\n\t\t\ti += digit * w;\n\t\t\tvar t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;\n\n\t\t\tif (digit < t) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tvar baseMinusT = base - t;\n\t\t\tif (w > floor(maxInt / baseMinusT)) {\n\t\t\t\terror$1('overflow');\n\t\t\t}\n\n\t\t\tw *= baseMinusT;\n\t\t}\n\n\t\tvar out = output.length + 1;\n\t\tbias = adapt(i - oldi, out, oldi == 0);\n\n\t\t// `i` was supposed to wrap around from `out` to `0`,\n\t\t// incrementing `n` each time, so we'll fix that now:\n\t\tif (floor(i / out) > maxInt - n) {\n\t\t\terror$1('overflow');\n\t\t}\n\n\t\tn += floor(i / out);\n\t\ti %= out;\n\n\t\t// Insert `n` at position `i` of the output.\n\t\toutput.splice(i++, 0, n);\n\t}\n\n\treturn String.fromCodePoint.apply(String, output);\n};\n\n/**\n * Converts a string of Unicode symbols (e.g. a domain name label) to a\n * Punycode string of ASCII-only symbols.\n * @memberOf punycode\n * @param {String} input The string of Unicode symbols.\n * @returns {String} The resulting Punycode string of ASCII-only symbols.\n */\nvar encode = function encode(input) {\n\tvar output = [];\n\n\t// Convert the input in UCS-2 to an array of Unicode code points.\n\tinput = ucs2decode(input);\n\n\t// Cache the length.\n\tvar inputLength = input.length;\n\n\t// Initialize the state.\n\tvar n = initialN;\n\tvar delta = 0;\n\tvar bias = initialBias;\n\n\t// Handle the basic code points.\n\tvar _iteratorNormalCompletion = true;\n\tvar _didIteratorError = false;\n\tvar _iteratorError = undefined;\n\n\ttry {\n\t\tfor (var _iterator = input[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {\n\t\t\tvar _currentValue2 = _step.value;\n\n\t\t\tif (_currentValue2 < 0x80) {\n\t\t\t\toutput.push(stringFromCharCode(_currentValue2));\n\t\t\t}\n\t\t}\n\t} catch (err) {\n\t\t_didIteratorError = true;\n\t\t_iteratorError = err;\n\t} finally {\n\t\ttry {\n\t\t\tif (!_iteratorNormalCompletion && _iterator.return) {\n\t\t\t\t_iterator.return();\n\t\t\t}\n\t\t} finally {\n\t\t\tif (_didIteratorError) {\n\t\t\t\tthrow _iteratorError;\n\t\t\t}\n\t\t}\n\t}\n\n\tvar basicLength = output.length;\n\tvar handledCPCount = basicLength;\n\n\t// `handledCPCount` is the number of code points that have been handled;\n\t// `basicLength` is the number of basic code points.\n\n\t// Finish the basic string with a delimiter unless it's empty.\n\tif (basicLength) {\n\t\toutput.push(delimiter);\n\t}\n\n\t// Main encoding loop:\n\twhile (handledCPCount < inputLength) {\n\n\t\t// All non-basic code points < n have been handled already. Find the next\n\t\t// larger one:\n\t\tvar m = maxInt;\n\t\tvar _iteratorNormalCompletion2 = true;\n\t\tvar _didIteratorError2 = false;\n\t\tvar _iteratorError2 = undefined;\n\n\t\ttry {\n\t\t\tfor (var _iterator2 = input[Symbol.iterator](), _step2; !(_iteratorNormalCompletion2 = (_step2 = _iterator2.next()).done); _iteratorNormalCompletion2 = true) {\n\t\t\t\tvar currentValue = _step2.value;\n\n\t\t\t\tif (currentValue >= n && currentValue < m) {\n\t\t\t\t\tm = currentValue;\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// Increase `delta` enough to advance the decoder's <n,i> state to <m,0>,\n\t\t\t// but guard against overflow.\n\t\t} catch (err) {\n\t\t\t_didIteratorError2 = true;\n\t\t\t_iteratorError2 = err;\n\t\t} finally {\n\t\t\ttry {\n\t\t\t\tif (!_iteratorNormalCompletion2 && _iterator2.return) {\n\t\t\t\t\t_iterator2.return();\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tif (_didIteratorError2) {\n\t\t\t\t\tthrow _iteratorError2;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tvar handledCPCountPlusOne = handledCPCount + 1;\n\t\tif (m - n > floor((maxInt - delta) / handledCPCountPlusOne)) {\n\t\t\terror$1('overflow');\n\t\t}\n\n\t\tdelta += (m - n) * handledCPCountPlusOne;\n\t\tn = m;\n\n\t\tvar _iteratorNormalCompletion3 = true;\n\t\tvar _didIteratorError3 = false;\n\t\tvar _iteratorError3 = undefined;\n\n\t\ttry {\n\t\t\tfor (var _iterator3 = input[Symbol.iterator](), _step3; !(_iteratorNormalCompletion3 = (_step3 = _iterator3.next()).done); _iteratorNormalCompletion3 = true) {\n\t\t\t\tvar _currentValue = _step3.value;\n\n\t\t\t\tif (_currentValue < n && ++delta > maxInt) {\n\t\t\t\t\terror$1('overflow');\n\t\t\t\t}\n\t\t\t\tif (_currentValue == n) {\n\t\t\t\t\t// Represent delta as a generalized variable-length integer.\n\t\t\t\t\tvar q = delta;\n\t\t\t\t\tfor (var k = base;; /* no condition */k += base) {\n\t\t\t\t\t\tvar t = k <= bias ? tMin : k >= bias + tMax ? tMax : k - bias;\n\t\t\t\t\t\tif (q < t) {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tvar qMinusT = q - t;\n\t\t\t\t\t\tvar baseMinusT = base - t;\n\t\t\t\t\t\toutput.push(stringFromCharCode(digitToBasic(t + qMinusT % baseMinusT, 0)));\n\t\t\t\t\t\tq = floor(qMinusT / baseMinusT);\n\t\t\t\t\t}\n\n\t\t\t\t\toutput.push(stringFromCharCode(digitToBasic(q, 0)));\n\t\t\t\t\tbias = adapt(delta, handledCPCountPlusOne, handledCPCount == basicLength);\n\t\t\t\t\tdelta = 0;\n\t\t\t\t\t++handledCPCount;\n\t\t\t\t}\n\t\t\t}\n\t\t} catch (err) {\n\t\t\t_didIteratorError3 = true;\n\t\t\t_iteratorError3 = err;\n\t\t} finally {\n\t\t\ttry {\n\t\t\t\tif (!_iteratorNormalCompletion3 && _iterator3.return) {\n\t\t\t\t\t_iterator3.return();\n\t\t\t\t}\n\t\t\t} finally {\n\t\t\t\tif (_didIteratorError3) {\n\t\t\t\t\tthrow _iteratorError3;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t++delta;\n\t\t++n;\n\t}\n\treturn output.join('');\n};\n\n/**\n * Converts a Punycode string representing a domain name or an email address\n * to Unicode. Only the Punycoded parts of the input will be converted, i.e.\n * it doesn't matter if you call it on a string that has already been\n * converted to Unicode.\n * @memberOf punycode\n * @param {String} input The Punycoded domain name or email address to\n * convert to Unicode.\n * @returns {String} The Unicode representation of the given Punycode\n * string.\n */\nvar toUnicode = function toUnicode(input) {\n\treturn mapDomain(input, function (string) {\n\t\treturn regexPunycode.test(string) ? decode(string.slice(4).toLowerCase()) : string;\n\t});\n};\n\n/**\n * Converts a Unicode string representing a domain name or an email address to\n * Punycode. Only the non-ASCII parts of the domain name will be converted,\n * i.e. it doesn't matter if you call it with a domain that's already in\n * ASCII.\n * @memberOf punycode\n * @param {String} input The domain name or email address to convert, as a\n * Unicode string.\n * @returns {String} The Punycode representation of the given domain name or\n * email address.\n */\nvar toASCII = function toASCII(input) {\n\treturn mapDomain(input, function (string) {\n\t\treturn regexNonASCII.test(string) ? 'xn--' + encode(string) : string;\n\t});\n};\n\n/*--------------------------------------------------------------------------*/\n\n/** Define the public API */\nvar punycode = {\n\t/**\n  * A string representing the current Punycode.js version number.\n  * @memberOf punycode\n  * @type String\n  */\n\t'version': '2.1.0',\n\t/**\n  * An object of methods to convert from JavaScript's internal character\n  * representation (UCS-2) to Unicode code points, and back.\n  * @see <https://mathiasbynens.be/notes/javascript-encoding>\n  * @memberOf punycode\n  * @type Object\n  */\n\t'ucs2': {\n\t\t'decode': ucs2decode,\n\t\t'encode': ucs2encode\n\t},\n\t'decode': decode,\n\t'encode': encode,\n\t'toASCII': toASCII,\n\t'toUnicode': toUnicode\n};\n\n/**\n * URI.js\n *\n * @fileoverview An RFC 3986 compliant, scheme extendable URI parsing/validating/resolving library for JavaScript.\n * @author <a href=\"mailto:gary.court@gmail.com\">Gary Court</a>\n * @see http://github.com/garycourt/uri-js\n */\n/**\n * Copyright 2011 Gary Court. All rights reserved.\n *\n * Redistribution and use in source and binary forms, with or without modification, are\n * permitted provided that the following conditions are met:\n *\n *    1. Redistributions of source code must retain the above copyright notice, this list of\n *       conditions and the following disclaimer.\n *\n *    2. Redistributions in binary form must reproduce the above copyright notice, this list\n *       of conditions and the following disclaimer in the documentation and/or other materials\n *       provided with the distribution.\n *\n * THIS SOFTWARE IS PROVIDED BY GARY COURT ``AS IS'' AND ANY EXPRESS OR IMPLIED\n * WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND\n * FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL GARY COURT OR\n * CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\n * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR\n * SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON\n * ANY THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING\n * NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF\n * ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.\n *\n * The views and conclusions contained in the software and documentation are those of the\n * authors and should not be interpreted as representing official policies, either expressed\n * or implied, of Gary Court.\n */\nvar SCHEMES = {};\nfunction pctEncChar(chr) {\n    var c = chr.charCodeAt(0);\n    var e = void 0;\n    if (c < 16) e = \"%0\" + c.toString(16).toUpperCase();else if (c < 128) e = \"%\" + c.toString(16).toUpperCase();else if (c < 2048) e = \"%\" + (c >> 6 | 192).toString(16).toUpperCase() + \"%\" + (c & 63 | 128).toString(16).toUpperCase();else e = \"%\" + (c >> 12 | 224).toString(16).toUpperCase() + \"%\" + (c >> 6 & 63 | 128).toString(16).toUpperCase() + \"%\" + (c & 63 | 128).toString(16).toUpperCase();\n    return e;\n}\nfunction pctDecChars(str) {\n    var newStr = \"\";\n    var i = 0;\n    var il = str.length;\n    while (i < il) {\n        var c = parseInt(str.substr(i + 1, 2), 16);\n        if (c < 128) {\n            newStr += String.fromCharCode(c);\n            i += 3;\n        } else if (c >= 194 && c < 224) {\n            if (il - i >= 6) {\n                var c2 = parseInt(str.substr(i + 4, 2), 16);\n                newStr += String.fromCharCode((c & 31) << 6 | c2 & 63);\n            } else {\n                newStr += str.substr(i, 6);\n            }\n            i += 6;\n        } else if (c >= 224) {\n            if (il - i >= 9) {\n                var _c = parseInt(str.substr(i + 4, 2), 16);\n                var c3 = parseInt(str.substr(i + 7, 2), 16);\n                newStr += String.fromCharCode((c & 15) << 12 | (_c & 63) << 6 | c3 & 63);\n            } else {\n                newStr += str.substr(i, 9);\n            }\n            i += 9;\n        } else {\n            newStr += str.substr(i, 3);\n            i += 3;\n        }\n    }\n    return newStr;\n}\nfunction _normalizeComponentEncoding(components, protocol) {\n    function decodeUnreserved(str) {\n        var decStr = pctDecChars(str);\n        return !decStr.match(protocol.UNRESERVED) ? str : decStr;\n    }\n    if (components.scheme) components.scheme = String(components.scheme).replace(protocol.PCT_ENCODED, decodeUnreserved).toLowerCase().replace(protocol.NOT_SCHEME, \"\");\n    if (components.userinfo !== undefined) components.userinfo = String(components.userinfo).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_USERINFO, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n    if (components.host !== undefined) components.host = String(components.host).replace(protocol.PCT_ENCODED, decodeUnreserved).toLowerCase().replace(protocol.NOT_HOST, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n    if (components.path !== undefined) components.path = String(components.path).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(components.scheme ? protocol.NOT_PATH : protocol.NOT_PATH_NOSCHEME, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n    if (components.query !== undefined) components.query = String(components.query).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_QUERY, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n    if (components.fragment !== undefined) components.fragment = String(components.fragment).replace(protocol.PCT_ENCODED, decodeUnreserved).replace(protocol.NOT_FRAGMENT, pctEncChar).replace(protocol.PCT_ENCODED, toUpperCase);\n    return components;\n}\n\nfunction _stripLeadingZeros(str) {\n    return str.replace(/^0*(.*)/, \"$1\") || \"0\";\n}\nfunction _normalizeIPv4(host, protocol) {\n    var matches = host.match(protocol.IPV4ADDRESS) || [];\n\n    var _matches = slicedToArray(matches, 2),\n        address = _matches[1];\n\n    if (address) {\n        return address.split(\".\").map(_stripLeadingZeros).join(\".\");\n    } else {\n        return host;\n    }\n}\nfunction _normalizeIPv6(host, protocol) {\n    var matches = host.match(protocol.IPV6ADDRESS) || [];\n\n    var _matches2 = slicedToArray(matches, 3),\n        address = _matches2[1],\n        zone = _matches2[2];\n\n    if (address) {\n        var _address$toLowerCase$ = address.toLowerCase().split('::').reverse(),\n            _address$toLowerCase$2 = slicedToArray(_address$toLowerCase$, 2),\n            last = _address$toLowerCase$2[0],\n            first = _address$toLowerCase$2[1];\n\n        var firstFields = first ? first.split(\":\").map(_stripLeadingZeros) : [];\n        var lastFields = last.split(\":\").map(_stripLeadingZeros);\n        var isLastFieldIPv4Address = protocol.IPV4ADDRESS.test(lastFields[lastFields.length - 1]);\n        var fieldCount = isLastFieldIPv4Address ? 7 : 8;\n        var lastFieldsStart = lastFields.length - fieldCount;\n        var fields = Array(fieldCount);\n        for (var x = 0; x < fieldCount; ++x) {\n            fields[x] = firstFields[x] || lastFields[lastFieldsStart + x] || '';\n        }\n        if (isLastFieldIPv4Address) {\n            fields[fieldCount - 1] = _normalizeIPv4(fields[fieldCount - 1], protocol);\n        }\n        var allZeroFields = fields.reduce(function (acc, field, index) {\n            if (!field || field === \"0\") {\n                var lastLongest = acc[acc.length - 1];\n                if (lastLongest && lastLongest.index + lastLongest.length === index) {\n                    lastLongest.length++;\n                } else {\n                    acc.push({ index: index, length: 1 });\n                }\n            }\n            return acc;\n        }, []);\n        var longestZeroFields = allZeroFields.sort(function (a, b) {\n            return b.length - a.length;\n        })[0];\n        var newHost = void 0;\n        if (longestZeroFields && longestZeroFields.length > 1) {\n            var newFirst = fields.slice(0, longestZeroFields.index);\n            var newLast = fields.slice(longestZeroFields.index + longestZeroFields.length);\n            newHost = newFirst.join(\":\") + \"::\" + newLast.join(\":\");\n        } else {\n            newHost = fields.join(\":\");\n        }\n        if (zone) {\n            newHost += \"%\" + zone;\n        }\n        return newHost;\n    } else {\n        return host;\n    }\n}\nvar URI_PARSE = /^(?:([^:\\/?#]+):)?(?:\\/\\/((?:([^\\/?#@]*)@)?(\\[[^\\/?#\\]]+\\]|[^\\/?#:]*)(?:\\:(\\d*))?))?([^?#]*)(?:\\?([^#]*))?(?:#((?:.|\\n|\\r)*))?/i;\nvar NO_MATCH_IS_UNDEFINED = \"\".match(/(){0}/)[1] === undefined;\nfunction parse(uriString) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    var components = {};\n    var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;\n    if (options.reference === \"suffix\") uriString = (options.scheme ? options.scheme + \":\" : \"\") + \"//\" + uriString;\n    var matches = uriString.match(URI_PARSE);\n    if (matches) {\n        if (NO_MATCH_IS_UNDEFINED) {\n            //store each component\n            components.scheme = matches[1];\n            components.userinfo = matches[3];\n            components.host = matches[4];\n            components.port = parseInt(matches[5], 10);\n            components.path = matches[6] || \"\";\n            components.query = matches[7];\n            components.fragment = matches[8];\n            //fix port number\n            if (isNaN(components.port)) {\n                components.port = matches[5];\n            }\n        } else {\n            //IE FIX for improper RegExp matching\n            //store each component\n            components.scheme = matches[1] || undefined;\n            components.userinfo = uriString.indexOf(\"@\") !== -1 ? matches[3] : undefined;\n            components.host = uriString.indexOf(\"//\") !== -1 ? matches[4] : undefined;\n            components.port = parseInt(matches[5], 10);\n            components.path = matches[6] || \"\";\n            components.query = uriString.indexOf(\"?\") !== -1 ? matches[7] : undefined;\n            components.fragment = uriString.indexOf(\"#\") !== -1 ? matches[8] : undefined;\n            //fix port number\n            if (isNaN(components.port)) {\n                components.port = uriString.match(/\\/\\/(?:.|\\n)*\\:(?:\\/|\\?|\\#|$)/) ? matches[4] : undefined;\n            }\n        }\n        if (components.host) {\n            //normalize IP hosts\n            components.host = _normalizeIPv6(_normalizeIPv4(components.host, protocol), protocol);\n        }\n        //determine reference type\n        if (components.scheme === undefined && components.userinfo === undefined && components.host === undefined && components.port === undefined && !components.path && components.query === undefined) {\n            components.reference = \"same-document\";\n        } else if (components.scheme === undefined) {\n            components.reference = \"relative\";\n        } else if (components.fragment === undefined) {\n            components.reference = \"absolute\";\n        } else {\n            components.reference = \"uri\";\n        }\n        //check for reference errors\n        if (options.reference && options.reference !== \"suffix\" && options.reference !== components.reference) {\n            components.error = components.error || \"URI is not a \" + options.reference + \" reference.\";\n        }\n        //find scheme handler\n        var schemeHandler = SCHEMES[(options.scheme || components.scheme || \"\").toLowerCase()];\n        //check if scheme can't handle IRIs\n        if (!options.unicodeSupport && (!schemeHandler || !schemeHandler.unicodeSupport)) {\n            //if host component is a domain name\n            if (components.host && (options.domainHost || schemeHandler && schemeHandler.domainHost)) {\n                //convert Unicode IDN -> ASCII IDN\n                try {\n                    components.host = punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase());\n                } catch (e) {\n                    components.error = components.error || \"Host's domain name can not be converted to ASCII via punycode: \" + e;\n                }\n            }\n            //convert IRI -> URI\n            _normalizeComponentEncoding(components, URI_PROTOCOL);\n        } else {\n            //normalize encodings\n            _normalizeComponentEncoding(components, protocol);\n        }\n        //perform scheme specific parsing\n        if (schemeHandler && schemeHandler.parse) {\n            schemeHandler.parse(components, options);\n        }\n    } else {\n        components.error = components.error || \"URI can not be parsed.\";\n    }\n    return components;\n}\n\nfunction _recomposeAuthority(components, options) {\n    var protocol = options.iri !== false ? IRI_PROTOCOL : URI_PROTOCOL;\n    var uriTokens = [];\n    if (components.userinfo !== undefined) {\n        uriTokens.push(components.userinfo);\n        uriTokens.push(\"@\");\n    }\n    if (components.host !== undefined) {\n        //normalize IP hosts, add brackets and escape zone separator for IPv6\n        uriTokens.push(_normalizeIPv6(_normalizeIPv4(String(components.host), protocol), protocol).replace(protocol.IPV6ADDRESS, function (_, $1, $2) {\n            return \"[\" + $1 + ($2 ? \"%25\" + $2 : \"\") + \"]\";\n        }));\n    }\n    if (typeof components.port === \"number\" || typeof components.port === \"string\") {\n        uriTokens.push(\":\");\n        uriTokens.push(String(components.port));\n    }\n    return uriTokens.length ? uriTokens.join(\"\") : undefined;\n}\n\nvar RDS1 = /^\\.\\.?\\//;\nvar RDS2 = /^\\/\\.(\\/|$)/;\nvar RDS3 = /^\\/\\.\\.(\\/|$)/;\nvar RDS5 = /^\\/?(?:.|\\n)*?(?=\\/|$)/;\nfunction removeDotSegments(input) {\n    var output = [];\n    while (input.length) {\n        if (input.match(RDS1)) {\n            input = input.replace(RDS1, \"\");\n        } else if (input.match(RDS2)) {\n            input = input.replace(RDS2, \"/\");\n        } else if (input.match(RDS3)) {\n            input = input.replace(RDS3, \"/\");\n            output.pop();\n        } else if (input === \".\" || input === \"..\") {\n            input = \"\";\n        } else {\n            var im = input.match(RDS5);\n            if (im) {\n                var s = im[0];\n                input = input.slice(s.length);\n                output.push(s);\n            } else {\n                throw new Error(\"Unexpected dot segment condition\");\n            }\n        }\n    }\n    return output.join(\"\");\n}\n\nfunction serialize(components) {\n    var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};\n\n    var protocol = options.iri ? IRI_PROTOCOL : URI_PROTOCOL;\n    var uriTokens = [];\n    //find scheme handler\n    var schemeHandler = SCHEMES[(options.scheme || components.scheme || \"\").toLowerCase()];\n    //perform scheme specific serialization\n    if (schemeHandler && schemeHandler.serialize) schemeHandler.serialize(components, options);\n    if (components.host) {\n        //if host component is an IPv6 address\n        if (protocol.IPV6ADDRESS.test(components.host)) {}\n        //TODO: normalize IPv6 address as per RFC 5952\n\n        //if host component is a domain name\n        else if (options.domainHost || schemeHandler && schemeHandler.domainHost) {\n                //convert IDN via punycode\n                try {\n                    components.host = !options.iri ? punycode.toASCII(components.host.replace(protocol.PCT_ENCODED, pctDecChars).toLowerCase()) : punycode.toUnicode(components.host);\n                } catch (e) {\n                    components.error = components.error || \"Host's domain name can not be converted to \" + (!options.iri ? \"ASCII\" : \"Unicode\") + \" via punycode: \" + e;\n                }\n            }\n    }\n    //normalize encoding\n    _normalizeComponentEncoding(components, protocol);\n    if (options.reference !== \"suffix\" && components.scheme) {\n        uriTokens.push(components.scheme);\n        uriTokens.push(\":\");\n    }\n    var authority = _recomposeAuthority(components, options);\n    if (authority !== undefined) {\n        if (options.reference !== \"suffix\") {\n            uriTokens.push(\"//\");\n        }\n        uriTokens.push(authority);\n        if (components.path && components.path.charAt(0) !== \"/\") {\n            uriTokens.push(\"/\");\n        }\n    }\n    if (components.path !== undefined) {\n        var s = components.path;\n        if (!options.absolutePath && (!schemeHandler || !schemeHandler.absolutePath)) {\n            s = removeDotSegments(s);\n        }\n        if (authority === undefined) {\n            s = s.replace(/^\\/\\//, \"/%2F\"); //don't allow the path to start with \"//\"\n        }\n        uriTokens.push(s);\n    }\n    if (components.query !== undefined) {\n        uriTokens.push(\"?\");\n        uriTokens.push(components.query);\n    }\n    if (components.fragment !== undefined) {\n        uriTokens.push(\"#\");\n        uriTokens.push(components.fragment);\n    }\n    return uriTokens.join(\"\"); //merge tokens into a string\n}\n\nfunction resolveComponents(base, relative) {\n    var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};\n    var skipNormalization = arguments[3];\n\n    var target = {};\n    if (!skipNormalization) {\n        base = parse(serialize(base, options), options); //normalize base components\n        relative = parse(serialize(relative, options), options); //normalize relative components\n    }\n    options = options || {};\n    if (!options.tolerant && relative.scheme) {\n        target.scheme = relative.scheme;\n        //target.authority = relative.authority;\n        target.userinfo = relative.userinfo;\n        target.host = relative.host;\n        target.port = relative.port;\n        target.path = removeDotSegments(relative.path || \"\");\n        target.query = relative.query;\n    } else {\n        if (relative.userinfo !== undefined || relative.host !== undefined || relative.port !== undefined) {\n            //target.authority = relative.authority;\n            target.userinfo = relative.userinfo;\n            target.host = relative.host;\n            target.port = relative.port;\n            target.path = removeDotSegments(relative.path || \"\");\n            target.query = relative.query;\n        } else {\n            if (!relative.path) {\n                target.path = base.path;\n                if (relative.query !== undefined) {\n                    target.query = relative.query;\n                } else {\n                    target.query = base.query;\n                }\n            } else {\n                if (relative.path.charAt(0) === \"/\") {\n                    target.path = removeDotSegments(relative.path);\n                } else {\n                    if ((base.userinfo !== undefined || base.host !== undefined || base.port !== undefined) && !base.path) {\n                        target.path = \"/\" + relative.path;\n                    } else if (!base.path) {\n                        target.path = relative.path;\n                    } else {\n                        target.path = base.path.slice(0, base.path.lastIndexOf(\"/\") + 1) + relative.path;\n                    }\n                    target.path = removeDotSegments(target.path);\n                }\n                target.query = relative.query;\n            }\n            //target.authority = base.authority;\n            target.userinfo = base.userinfo;\n            target.host = base.host;\n            target.port = base.port;\n        }\n        target.scheme = base.scheme;\n    }\n    target.fragment = relative.fragment;\n    return target;\n}\n\nfunction resolve(baseURI, relativeURI, options) {\n    var schemelessOptions = assign({ scheme: 'null' }, options);\n    return serialize(resolveComponents(parse(baseURI, schemelessOptions), parse(relativeURI, schemelessOptions), schemelessOptions, true), schemelessOptions);\n}\n\nfunction normalize(uri, options) {\n    if (typeof uri === \"string\") {\n        uri = serialize(parse(uri, options), options);\n    } else if (typeOf(uri) === \"object\") {\n        uri = parse(serialize(uri, options), options);\n    }\n    return uri;\n}\n\nfunction equal(uriA, uriB, options) {\n    if (typeof uriA === \"string\") {\n        uriA = serialize(parse(uriA, options), options);\n    } else if (typeOf(uriA) === \"object\") {\n        uriA = serialize(uriA, options);\n    }\n    if (typeof uriB === \"string\") {\n        uriB = serialize(parse(uriB, options), options);\n    } else if (typeOf(uriB) === \"object\") {\n        uriB = serialize(uriB, options);\n    }\n    return uriA === uriB;\n}\n\nfunction escapeComponent(str, options) {\n    return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.ESCAPE : IRI_PROTOCOL.ESCAPE, pctEncChar);\n}\n\nfunction unescapeComponent(str, options) {\n    return str && str.toString().replace(!options || !options.iri ? URI_PROTOCOL.PCT_ENCODED : IRI_PROTOCOL.PCT_ENCODED, pctDecChars);\n}\n\nvar handler = {\n    scheme: \"http\",\n    domainHost: true,\n    parse: function parse(components, options) {\n        //report missing host\n        if (!components.host) {\n            components.error = components.error || \"HTTP URIs must have a host.\";\n        }\n        return components;\n    },\n    serialize: function serialize(components, options) {\n        var secure = String(components.scheme).toLowerCase() === \"https\";\n        //normalize the default port\n        if (components.port === (secure ? 443 : 80) || components.port === \"\") {\n            components.port = undefined;\n        }\n        //normalize the empty path\n        if (!components.path) {\n            components.path = \"/\";\n        }\n        //NOTE: We do not parse query strings for HTTP URIs\n        //as WWW Form Url Encoded query strings are part of the HTML4+ spec,\n        //and not the HTTP spec.\n        return components;\n    }\n};\n\nvar handler$1 = {\n    scheme: \"https\",\n    domainHost: handler.domainHost,\n    parse: handler.parse,\n    serialize: handler.serialize\n};\n\nfunction isSecure(wsComponents) {\n    return typeof wsComponents.secure === 'boolean' ? wsComponents.secure : String(wsComponents.scheme).toLowerCase() === \"wss\";\n}\n//RFC 6455\nvar handler$2 = {\n    scheme: \"ws\",\n    domainHost: true,\n    parse: function parse(components, options) {\n        var wsComponents = components;\n        //indicate if the secure flag is set\n        wsComponents.secure = isSecure(wsComponents);\n        //construct resouce name\n        wsComponents.resourceName = (wsComponents.path || '/') + (wsComponents.query ? '?' + wsComponents.query : '');\n        wsComponents.path = undefined;\n        wsComponents.query = undefined;\n        return wsComponents;\n    },\n    serialize: function serialize(wsComponents, options) {\n        //normalize the default port\n        if (wsComponents.port === (isSecure(wsComponents) ? 443 : 80) || wsComponents.port === \"\") {\n            wsComponents.port = undefined;\n        }\n        //ensure scheme matches secure flag\n        if (typeof wsComponents.secure === 'boolean') {\n            wsComponents.scheme = wsComponents.secure ? 'wss' : 'ws';\n            wsComponents.secure = undefined;\n        }\n        //reconstruct path from resource name\n        if (wsComponents.resourceName) {\n            var _wsComponents$resourc = wsComponents.resourceName.split('?'),\n                _wsComponents$resourc2 = slicedToArray(_wsComponents$resourc, 2),\n                path = _wsComponents$resourc2[0],\n                query = _wsComponents$resourc2[1];\n\n            wsComponents.path = path && path !== '/' ? path : undefined;\n            wsComponents.query = query;\n            wsComponents.resourceName = undefined;\n        }\n        //forbid fragment component\n        wsComponents.fragment = undefined;\n        return wsComponents;\n    }\n};\n\nvar handler$3 = {\n    scheme: \"wss\",\n    domainHost: handler$2.domainHost,\n    parse: handler$2.parse,\n    serialize: handler$2.serialize\n};\n\nvar O = {};\nvar isIRI = true;\n//RFC 3986\nvar UNRESERVED$$ = \"[A-Za-z0-9\\\\-\\\\.\\\\_\\\\~\" + (isIRI ? \"\\\\xA0-\\\\u200D\\\\u2010-\\\\u2029\\\\u202F-\\\\uD7FF\\\\uF900-\\\\uFDCF\\\\uFDF0-\\\\uFFEF\" : \"\") + \"]\";\nvar HEXDIG$$ = \"[0-9A-Fa-f]\"; //case-insensitive\nvar PCT_ENCODED$ = subexp(subexp(\"%[EFef]\" + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$) + \"|\" + subexp(\"%[89A-Fa-f]\" + HEXDIG$$ + \"%\" + HEXDIG$$ + HEXDIG$$) + \"|\" + subexp(\"%\" + HEXDIG$$ + HEXDIG$$)); //expanded\n//RFC 5322, except these symbols as per RFC 6068: @ : / ? # [ ] & ; =\n//const ATEXT$$ = \"[A-Za-z0-9\\\\!\\\\#\\\\$\\\\%\\\\&\\\\'\\\\*\\\\+\\\\-\\\\/\\\\=\\\\?\\\\^\\\\_\\\\`\\\\{\\\\|\\\\}\\\\~]\";\n//const WSP$$ = \"[\\\\x20\\\\x09]\";\n//const OBS_QTEXT$$ = \"[\\\\x01-\\\\x08\\\\x0B\\\\x0C\\\\x0E-\\\\x1F\\\\x7F]\";  //(%d1-8 / %d11-12 / %d14-31 / %d127)\n//const QTEXT$$ = merge(\"[\\\\x21\\\\x23-\\\\x5B\\\\x5D-\\\\x7E]\", OBS_QTEXT$$);  //%d33 / %d35-91 / %d93-126 / obs-qtext\n//const VCHAR$$ = \"[\\\\x21-\\\\x7E]\";\n//const WSP$$ = \"[\\\\x20\\\\x09]\";\n//const OBS_QP$ = subexp(\"\\\\\\\\\" + merge(\"[\\\\x00\\\\x0D\\\\x0A]\", OBS_QTEXT$$));  //%d0 / CR / LF / obs-qtext\n//const FWS$ = subexp(subexp(WSP$$ + \"*\" + \"\\\\x0D\\\\x0A\") + \"?\" + WSP$$ + \"+\");\n//const QUOTED_PAIR$ = subexp(subexp(\"\\\\\\\\\" + subexp(VCHAR$$ + \"|\" + WSP$$)) + \"|\" + OBS_QP$);\n//const QUOTED_STRING$ = subexp('\\\\\"' + subexp(FWS$ + \"?\" + QCONTENT$) + \"*\" + FWS$ + \"?\" + '\\\\\"');\nvar ATEXT$$ = \"[A-Za-z0-9\\\\!\\\\$\\\\%\\\\'\\\\*\\\\+\\\\-\\\\^\\\\_\\\\`\\\\{\\\\|\\\\}\\\\~]\";\nvar QTEXT$$ = \"[\\\\!\\\\$\\\\%\\\\'\\\\(\\\\)\\\\*\\\\+\\\\,\\\\-\\\\.0-9\\\\<\\\\>A-Z\\\\x5E-\\\\x7E]\";\nvar VCHAR$$ = merge(QTEXT$$, \"[\\\\\\\"\\\\\\\\]\");\nvar SOME_DELIMS$$ = \"[\\\\!\\\\$\\\\'\\\\(\\\\)\\\\*\\\\+\\\\,\\\\;\\\\:\\\\@]\";\nvar UNRESERVED = new RegExp(UNRESERVED$$, \"g\");\nvar PCT_ENCODED = new RegExp(PCT_ENCODED$, \"g\");\nvar NOT_LOCAL_PART = new RegExp(merge(\"[^]\", ATEXT$$, \"[\\\\.]\", '[\\\\\"]', VCHAR$$), \"g\");\nvar NOT_HFNAME = new RegExp(merge(\"[^]\", UNRESERVED$$, SOME_DELIMS$$), \"g\");\nvar NOT_HFVALUE = NOT_HFNAME;\nfunction decodeUnreserved(str) {\n    var decStr = pctDecChars(str);\n    return !decStr.match(UNRESERVED) ? str : decStr;\n}\nvar handler$4 = {\n    scheme: \"mailto\",\n    parse: function parse$$1(components, options) {\n        var mailtoComponents = components;\n        var to = mailtoComponents.to = mailtoComponents.path ? mailtoComponents.path.split(\",\") : [];\n        mailtoComponents.path = undefined;\n        if (mailtoComponents.query) {\n            var unknownHeaders = false;\n            var headers = {};\n            var hfields = mailtoComponents.query.split(\"&\");\n            for (var x = 0, xl = hfields.length; x < xl; ++x) {\n                var hfield = hfields[x].split(\"=\");\n                switch (hfield[0]) {\n                    case \"to\":\n                        var toAddrs = hfield[1].split(\",\");\n                        for (var _x = 0, _xl = toAddrs.length; _x < _xl; ++_x) {\n                            to.push(toAddrs[_x]);\n                        }\n                        break;\n                    case \"subject\":\n                        mailtoComponents.subject = unescapeComponent(hfield[1], options);\n                        break;\n                    case \"body\":\n                        mailtoComponents.body = unescapeComponent(hfield[1], options);\n                        break;\n                    default:\n                        unknownHeaders = true;\n                        headers[unescapeComponent(hfield[0], options)] = unescapeComponent(hfield[1], options);\n                        break;\n                }\n            }\n            if (unknownHeaders) mailtoComponents.headers = headers;\n        }\n        mailtoComponents.query = undefined;\n        for (var _x2 = 0, _xl2 = to.length; _x2 < _xl2; ++_x2) {\n            var addr = to[_x2].split(\"@\");\n            addr[0] = unescapeComponent(addr[0]);\n            if (!options.unicodeSupport) {\n                //convert Unicode IDN -> ASCII IDN\n                try {\n                    addr[1] = punycode.toASCII(unescapeComponent(addr[1], options).toLowerCase());\n                } catch (e) {\n                    mailtoComponents.error = mailtoComponents.error || \"Email address's domain name can not be converted to ASCII via punycode: \" + e;\n                }\n            } else {\n                addr[1] = unescapeComponent(addr[1], options).toLowerCase();\n            }\n            to[_x2] = addr.join(\"@\");\n        }\n        return mailtoComponents;\n    },\n    serialize: function serialize$$1(mailtoComponents, options) {\n        var components = mailtoComponents;\n        var to = toArray(mailtoComponents.to);\n        if (to) {\n            for (var x = 0, xl = to.length; x < xl; ++x) {\n                var toAddr = String(to[x]);\n                var atIdx = toAddr.lastIndexOf(\"@\");\n                var localPart = toAddr.slice(0, atIdx).replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_LOCAL_PART, pctEncChar);\n                var domain = toAddr.slice(atIdx + 1);\n                //convert IDN via punycode\n                try {\n                    domain = !options.iri ? punycode.toASCII(unescapeComponent(domain, options).toLowerCase()) : punycode.toUnicode(domain);\n                } catch (e) {\n                    components.error = components.error || \"Email address's domain name can not be converted to \" + (!options.iri ? \"ASCII\" : \"Unicode\") + \" via punycode: \" + e;\n                }\n                to[x] = localPart + \"@\" + domain;\n            }\n            components.path = to.join(\",\");\n        }\n        var headers = mailtoComponents.headers = mailtoComponents.headers || {};\n        if (mailtoComponents.subject) headers[\"subject\"] = mailtoComponents.subject;\n        if (mailtoComponents.body) headers[\"body\"] = mailtoComponents.body;\n        var fields = [];\n        for (var name in headers) {\n            if (headers[name] !== O[name]) {\n                fields.push(name.replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFNAME, pctEncChar) + \"=\" + headers[name].replace(PCT_ENCODED, decodeUnreserved).replace(PCT_ENCODED, toUpperCase).replace(NOT_HFVALUE, pctEncChar));\n            }\n        }\n        if (fields.length) {\n            components.query = fields.join(\"&\");\n        }\n        return components;\n    }\n};\n\nvar URN_PARSE = /^([^\\:]+)\\:(.*)/;\n//RFC 2141\nvar handler$5 = {\n    scheme: \"urn\",\n    parse: function parse$$1(components, options) {\n        var matches = components.path && components.path.match(URN_PARSE);\n        var urnComponents = components;\n        if (matches) {\n            var scheme = options.scheme || urnComponents.scheme || \"urn\";\n            var nid = matches[1].toLowerCase();\n            var nss = matches[2];\n            var urnScheme = scheme + \":\" + (options.nid || nid);\n            var schemeHandler = SCHEMES[urnScheme];\n            urnComponents.nid = nid;\n            urnComponents.nss = nss;\n            urnComponents.path = undefined;\n            if (schemeHandler) {\n                urnComponents = schemeHandler.parse(urnComponents, options);\n            }\n        } else {\n            urnComponents.error = urnComponents.error || \"URN can not be parsed.\";\n        }\n        return urnComponents;\n    },\n    serialize: function serialize$$1(urnComponents, options) {\n        var scheme = options.scheme || urnComponents.scheme || \"urn\";\n        var nid = urnComponents.nid;\n        var urnScheme = scheme + \":\" + (options.nid || nid);\n        var schemeHandler = SCHEMES[urnScheme];\n        if (schemeHandler) {\n            urnComponents = schemeHandler.serialize(urnComponents, options);\n        }\n        var uriComponents = urnComponents;\n        var nss = urnComponents.nss;\n        uriComponents.path = (nid || options.nid) + \":\" + nss;\n        return uriComponents;\n    }\n};\n\nvar UUID = /^[0-9A-Fa-f]{8}(?:\\-[0-9A-Fa-f]{4}){3}\\-[0-9A-Fa-f]{12}$/;\n//RFC 4122\nvar handler$6 = {\n    scheme: \"urn:uuid\",\n    parse: function parse(urnComponents, options) {\n        var uuidComponents = urnComponents;\n        uuidComponents.uuid = uuidComponents.nss;\n        uuidComponents.nss = undefined;\n        if (!options.tolerant && (!uuidComponents.uuid || !uuidComponents.uuid.match(UUID))) {\n            uuidComponents.error = uuidComponents.error || \"UUID is not valid.\";\n        }\n        return uuidComponents;\n    },\n    serialize: function serialize(uuidComponents, options) {\n        var urnComponents = uuidComponents;\n        //normalize UUID\n        urnComponents.nss = (uuidComponents.uuid || \"\").toLowerCase();\n        return urnComponents;\n    }\n};\n\nSCHEMES[handler.scheme] = handler;\nSCHEMES[handler$1.scheme] = handler$1;\nSCHEMES[handler$2.scheme] = handler$2;\nSCHEMES[handler$3.scheme] = handler$3;\nSCHEMES[handler$4.scheme] = handler$4;\nSCHEMES[handler$5.scheme] = handler$5;\nSCHEMES[handler$6.scheme] = handler$6;\n\nexports.SCHEMES = SCHEMES;\nexports.pctEncChar = pctEncChar;\nexports.pctDecChars = pctDecChars;\nexports.parse = parse;\nexports.removeDotSegments = removeDotSegments;\nexports.serialize = serialize;\nexports.resolveComponents = resolveComponents;\nexports.resolve = resolve;\nexports.normalize = normalize;\nexports.equal = equal;\nexports.escapeComponent = escapeComponent;\nexports.unescapeComponent = unescapeComponent;\n\nObject.defineProperty(exports, '__esModule', { value: true });\n\n})));\n//# sourceMappingURL=uri.all.js.map\n","\n\n\n// queueMicrotask shim\n{\n\t// not defined or not a function\n\tif('function' !== typeof queueMicrotask) {\n\t\t// create resolved promise\n\t\tlet dp_resolve = Promise.resolve();\n\n\t\t// try to redefine\n\t\ttry {\n\t\t\t// eslint-disable-next-line no-global-assign\n\t\t\tqueueMicrotask = fk => dp_resolve.then(fk)\n\t\t\t\t.catch(e_callback => setTimeout(() => {\n\t\t\t\t\tthrow e_callback;\n\t\t\t\t}, 0));\n\t\t}\n\t\t// oh well, at least we tried\n\t\tcatch(e_define) {}\n\t}\n}\n\n\n\nconst uri = require('uri-js');\nconst string_decoder = require('string_decoder');\n\nconst stream = require('@graphy/core.iso.stream');\nconst factory = require('@graphy/core.data.factory');\nconst quad = k => factory.quad(k._kt_subject, k._kt_predicate, k._kt_object, k._kt_graph);\n\n// eslint-disable-next-line no-misleading-character-class\nconst RT_PREFIXED_NAME_NAMESPACE_VALID = /^([A-Za-z\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u{02ff}\\u{0370}-\\u{037d}\\u{037f}-\\u{1fff}\\u{200c}-\\u{200d}\\u{2070}-\\u{218f}\\u{2c00}-\\u{2fef}\\u{3001}-\\u{d7ff}\\u{f900}-\\u{fdcf}\\u{fdf0}-\\u{fffd}\\u{10000}-\\u{effff}]([A-Za-z\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u{02ff}\\u{0370}-\\u{037d}\\u{037f}-\\u{1fff}\\u{200c}-\\u{200d}\\u{2070}-\\u{218f}\\u{2c00}-\\u{2fef}\\u{3001}-\\u{d7ff}\\u{f900}-\\u{fdcf}\\u{fdf0}-\\u{fffd}\\u{10000}-\\u{effff}_\\-0-9\\xb7\\u{0300}-\\u{036f}\\u{203f}-\\u{2040}.]*[A-Za-z\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u{02ff}\\u{0370}-\\u{037d}\\u{037f}-\\u{1fff}\\u{200c}-\\u{200d}\\u{2070}-\\u{218f}\\u{2c00}-\\u{2fef}\\u{3001}-\\u{d7ff}\\u{f900}-\\u{fdcf}\\u{fdf0}-\\u{fffd}\\u{10000}-\\u{effff}_\\-0-9\\xb7\\u{0300}-\\u{036f}\\u{203f}-\\u{2040}])?)?$/u;\n// eslint-disable-next-line no-misleading-character-class\nconst RT_PREFIXED_NAME_LOCAL_NAME_VALID = /^([A-Za-z\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u{02ff}\\u{0370}-\\u{037d}\\u{037f}-\\u{1fff}\\u{200c}-\\u{200d}\\u{2070}-\\u{218f}\\u{2c00}-\\u{2fef}\\u{3001}-\\u{d7ff}\\u{f900}-\\u{fdcf}\\u{fdf0}-\\u{fffd}\\u{10000}-\\u{effff}_:0-9]|%[A-Fa-f0-9]{2}|\\\\[_~.\\-!$&'()*+,;=/?#@%])(([A-Za-z\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u{02ff}\\u{0370}-\\u{037d}\\u{037f}-\\u{1fff}\\u{200c}-\\u{200d}\\u{2070}-\\u{218f}\\u{2c00}-\\u{2fef}\\u{3001}-\\u{d7ff}\\u{f900}-\\u{fdcf}\\u{fdf0}-\\u{fffd}\\u{10000}-\\u{effff}_\\-0-9\\xb7\\u{0300}-\\u{036f}\\u{203f}-\\u{2040}.:]|%[A-Fa-f0-9]{2}|\\\\[_~.\\-!$&'()*+,;=/?#@%])*([A-Za-z\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u{02ff}\\u{0370}-\\u{037d}\\u{037f}-\\u{1fff}\\u{200c}-\\u{200d}\\u{2070}-\\u{218f}\\u{2c00}-\\u{2fef}\\u{3001}-\\u{d7ff}\\u{f900}-\\u{fdcf}\\u{fdf0}-\\u{fffd}\\u{10000}-\\u{effff}_\\-0-9\\xb7\\u{0300}-\\u{036f}\\u{203f}-\\u{2040}:]|%[A-Fa-f0-9]{2}|\\\\[_~.\\-!$&'()*+,;=/?#@%]))?$/u;\n// eslint-disable-next-line no-misleading-character-class\nconst RT_BLANK_NODE_VALID = /^[A-Za-z\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u{02ff}\\u{0370}-\\u{037d}\\u{037f}-\\u{1fff}\\u{200c}-\\u{200d}\\u{2070}-\\u{218f}\\u{2c00}-\\u{2fef}\\u{3001}-\\u{d7ff}\\u{f900}-\\u{fdcf}\\u{fdf0}-\\u{fffd}\\u{10000}-\\u{effff}_0-9]([A-Za-z\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u{02ff}\\u{0370}-\\u{037d}\\u{037f}-\\u{1fff}\\u{200c}-\\u{200d}\\u{2070}-\\u{218f}\\u{2c00}-\\u{2fef}\\u{3001}-\\u{d7ff}\\u{f900}-\\u{fdcf}\\u{fdf0}-\\u{fffd}\\u{10000}-\\u{effff}_\\-0-9\\xb7\\u{0300}-\\u{036f}\\u{203f}-\\u{2040}.]*[A-Za-z\\xc0-\\xd6\\xd8-\\xf6\\xf8-\\u{02ff}\\u{0370}-\\u{037d}\\u{037f}-\\u{1fff}\\u{200c}-\\u{200d}\\u{2070}-\\u{218f}\\u{2c00}-\\u{2fef}\\u{3001}-\\u{d7ff}\\u{f900}-\\u{fdcf}\\u{fdf0}-\\u{fffd}\\u{10000}-\\u{effff}_\\-0-9\\xb7\\u{0300}-\\u{036f}\\u{203f}-\\u{2040}])?$/u;\nconst RT_NAMED_NODE_VALID = /^([^\\0-\\x20<>\"{}|^`\\\\]|\\\\u[A-Fa-f0-9]{4}|\\\\U[A-Fa-f0-9]{8})*$/;\nconst RT_NAMED_NODE_ESCAPELESS_VALID = /^([^\\0-\\x20<>\"{}|^`])*$/;\n\nconst RT_LITERAL_CONTENTS_VALID = /^(?:[^\\\\]|\\\\[tbnrf\"'\\\\]|\\\\u[A-Fa-f0-9]{4}|\\\\U[A-Fa-f0-9]{8})*$/;\n\nconst R_UNICODE_ANY = /\\\\u([0-9A-Fa-f]{4})|\\\\U([0-9A-Fa-f]{8})/g;\n\nconst F_REPLACE_UNICODE_ANY = \t(s_, s_4, s_8) => String.fromCodePoint(parseInt(s_4 || s_8, 16));\n\nconst OPHOP = Object.prototype.hasOwnProperty;\n\n\n\nconst R_PREFIXED_NAME_QUICK = /([A-Za-z][A-Za-z0-9_-]*)?:([A-Za-z_0-9:][A-Za-z0-9_:-]*)(?:\\s+|(?=\\.?[<[(\"';,)\\]#{}]|\\.[\\s\\0]))/y;\n\n\nconst R_PREFIXED_NAME_ESCAPELESS = /([^\\s#@<[(\"':_{}][^\\s#@<[(\"':{}]*)?:((?:[^\\s#@<[(\"'.;,{})\\]\\\\](?:[^\\s#@<[(\"';,{})\\]\\\\]*[^\\s#@<[(\"'.;,{})\\]\\\\])?)?)(?:\\s+|(?=\\.?[<[(\"';,)\\]#{}]|\\.[\\s\\0]))/y;\n\n\n\nconst R_PREFIXED_NAME = /([^\\s#@<[(\"':_{}][^\\s#@<[(\"':{}]*)?:((?:(?:[^\\s#@<[(\"'.;,{})\\]\\\\]|\\\\(?:%[0-9A-Fa-f][0-9A-Fa-f]|[^\\s\"]))(?:(?:[^\\s#@<[(\"';,{})\\]\\\\]|\\\\(?:%[0-9A-Fa-f][0-9A-Fa-f]|[^\\s\"]))*(?:[^\\s#@<[(\"'.;,{})\\]\\\\]|\\\\(?:%[0-9A-Fa-f][0-9A-Fa-f]|[^\\s\"])))?)?)(?:\\s+|(?=\\.?[<[(\"';,)\\]#{}]|\\.[\\s\\0]))/y;\n\nconst R_PN_LOCAL_ESCAPES = /\\\\(.)/g;\n\n\nconst R_BLANK_NODE_LABEL = /_:(.(?:[^\\s:<;,)\\]#}]*[^\\s:<.;,)\\]#}])?)(?:\\s+|(?=[<:{,;\\])#]))/y;\nconst R_BLANK_NODE_LABEL_TERMINAL = /_:(.(?:[^\\s:<;,)\\]#}]*[^\\s:<.;,)\\]#}])?)(?:\\s+|(?=\\.?[<:{,;\\])#])|(?=\\.[\\s@#<({[}]))/y;\n\nconst R_IRIREF_ESCAPELESS = /<([^\\\\>]*)>\\s*/y;\nconst R_IRIREF = /<([^>]*)>\\s*/y;\n\nconst R_NUMERIC_LITERAL = /([+-]?(?:[0-9]+(\\.[0-9]+)?|(\\.[0-9]+))(\\.?[eE][+-]?[0-9]+)?)(?:\\s+|(?=\\.[^eE0-9]|[;,)\\]]))/y;\nconst R_BOOLEAN_LITERAL = /(?:(true|TRUE)|false|FALSE)\\s*/y;\nconst R_A = /a(?:\\s+|(?=[[(\"'<#]))/y;\n\nconst R_DOUBLE_CARET = /\\^\\^/y;\nconst R_WS = /\\s*/y;\nconst R_LANGTAG = /@([A-Za-z]+(?:-[A-Za-z0-9-]+)*)(?:\\s+|(?=[.},;\\])#]))/y;\n\nconst R_PREFIX_KEYWORD = /(?:(@prefix)|[pP][rR][eE][fF][iI][xX])\\s*/y;\nconst R_PREFIX_ID = /([^#:]*):\\s*/iy;\nconst R_BASE_KEYWORD = /(?:(@base)|[bB][aA][sS][eE])\\s*/y;\n\nconst R_GRAPH_IRI_ESCAPELESS = /(?:graph)?\\s*<([^\\\\>]*)>\\s*\\{\\s*/iy;\nconst R_GRAPH_PREFIXED_NAME = /(?:graph)?\\s*([^\\s#@<[(\"':_{}][^\\s#@<[(\"':{}]*)?:((?:(?:[^\\s#@<[(\"'.;,{})\\]\\\\]|\\\\(?:%[0-9A-Fa-f][0-9A-Fa-f]|[^\\s\"]))(?:(?:[^\\s#@<[(\"';,{})\\]\\\\]|\\\\(?:%[0-9A-Fa-f][0-9A-Fa-f]|[^\\s\"]))*(?:[^\\s#@<[(\"'.;,{})\\]\\\\]|\\\\(?:%[0-9A-Fa-f][0-9A-Fa-f]|[^\\s\"])))?)?)\\s*\\{\\s*/iy;\nconst R_GRAPH_LABELED_BLANK_NODE = /(?:graph)?\\s*_:(.(?:[^\\s:<;,)\\]#}]*[^\\s:<.;,)\\]#}])?)\\s*\\{\\s*/iy;\nconst R_GRAPH_ANONYMOUS_BLANK_NODE = /(?:graph)?\\s*\\[\\s*\\]\\s*\\{\\s*/iy;\nconst R_GRAPH_IRI = /(?:graph)?\\s*<([^>]*)>\\s*\\{\\s*/iy;\nconst R_GRAPH = /graph(?:\\s+|(?=[#<[{]))/iy;\n\nconst R_COMMENT = /(#[^\\n]*\\n\\s*)+/y;\n\nconst RT_IRI_ABSOLUTE = /^[A-Za-z][A-Za-z0-9.\\-+]*:/;\nconst R_RELATIVE_URI = /^(\\/[^?#]+)([?#].*)?$/;\nconst R_BASE_IRI = /^((([A-Za-z0-9.\\-+]*:\\/)?\\/[^/>]*)?(\\/(?:[^/>]*\\/)*)?[^>]*)$/;\n\nconst R_ANONYMOUS_BLANK_NODE = /\\[\\s*\\]\\s*/y;\nconst R_CHAR_BLANK_NODE = /\\[(?:\\s+|(?=[^\\]]))/y;\nconst R_CHAR_COLLECTION = /\\(\\s*/y;\n\nconst R_CHAR_KET = /\\]\\s*/y;\n\nconst R_CHAR_OPEN = /\\{\\s*/y;\nconst R_CHAR_CLOSE = /\\}\\s*/y;\n\nconst R_CHAR_STOP = /\\.\\s*/y;\n\n\n\nconst R_STRLIT_SHORT_DOUBLE_BREAK = /[\\\\\"\\r\\n]/g;\nconst R_STRLIT_SHORT_SINGLE_BREAK = /[\\\\'\\r\\n]/g;\n\nconst R_STRLIT_LONG_DOUBLE_UNFINISHED_TERM = /\"{1,2}$/g;\nconst R_STRLIT_LONG_SINGLE_UNFINISHED_TERM = /'{1,2}$/g;\n\nconst R_STRLIT_LONG_DOUBLE_BREAK = /(\\\\|\"\"\")/g;\nconst R_STRLIT_LONG_SINGLE_BREAK = /(\\\\|''')/g;\n\n\nconst F_REPLACE_STRLIT_CONTENTS = (s_, s_whitespace, s_auto, s_4, s_8, s_invalid) => {\n\tif(s_whitespace) {\n\t\tswitch(s_whitespace) {\n\t\t\tcase 't': return '\\t';\n\t\t\tcase 'n': return '\\n';\n\t\t\tcase 'r': return '\\r';\n\t\t\tcase 'f': return '\\f';\n\t\t\tcase 'b': return '\\b';\n\t\t\tdefault: {\n\t\t\t\tconsole.assert(`bad regex escape char mapping: '${s_whitespace}'`);\n\t\t\t}\n\t\t}\n\t}\n\telse if(s_auto) {\n\t\treturn s_auto;\n\t}\n\telse if(s_4) {\n\t\treturn String.fromCodePoint(parseInt(s_4, 16));\n\t}\n\telse if(s_8) {\n\t\treturn String.fromCodePoint(parseInt(s_8, 16));\n\t}\n\telse if(s_invalid) {\n\t\t// pointless escape\n\t\tif('\\\\' === s_invalid[0]) {\n\t\t\t\t// // relaxed\n\t\t\t\t// return s_invalid[1];\n\t\t\t// if relaxed then return s_invalid, otherwise throw:\n\t\t\tthrow new Error(`expected string_literal but invalid escape sequence within contents: '${s_invalid}'. failed to parse a valid token`);\n\t\t}\n\t\t// bad character\n\t\telse {\n\t\t\tthrow new Error(`expected string_literal but invalid whitespace character within contents: ${JSON.stringify(s_invalid)}. failed to parse a valid token`);\n\t\t}\n\t}\n\telse {\n\t\tconsole.assert(`unexpected no match branch in escape sequence replace callback`);\n\t}\n};\n\n\nconst R_STRLIT_SHORT_CONTENTS_ESCAPES_HARD = /(?:\\\\(?:([tnrfb])|([\\\\\"'])|u([0-9A-Fa-f]{4})|U([0-9A-Fa-f]{8}))|([\\r\\n]|\\\\.))/g;\nconst R_STRLIT_SHORT_CONTENTS_ESCAPES_SOFT = /(?:\\\\(?:([tnrfb])|([\\\\\"'])|u([0-9A-Fa-f]{4})|U([0-9A-Fa-f]{8}))|([\\r\\n]|\\\\[^uU]|\\\\u[^]{4}|\\\\U[^]{8}))/g;\n\nconst unescape_literal_short_hard = s_literal => s_literal\n\t.replace(R_STRLIT_SHORT_CONTENTS_ESCAPES_HARD, F_REPLACE_STRLIT_CONTENTS);\n\nconst unescape_literal_short_soft = (s_literal) => {\n\tlet m_incomplete = R_STRLIT_ESCAPE_INCOMPLETE.exec(s_literal);\n\n\t// incomplete escape\n\tif(m_incomplete) {\n\t\tlet i_safe = m_incomplete.index;\n\n\t\t// rewind\n\t\treturn [\n\t\t\ts_literal.slice(0, i_safe)\n\t\t\t\t.replace(R_STRLIT_SHORT_CONTENTS_ESCAPES_SOFT, F_REPLACE_STRLIT_CONTENTS),\n\t\t\ts_literal.slice(i_safe),\n\t\t];\n\t}\n\t// done\n\telse {\n\t\treturn [\n\t\t\ts_literal\n\t\t\t\t.replace(R_STRLIT_SHORT_CONTENTS_ESCAPES_SOFT, F_REPLACE_STRLIT_CONTENTS),\n\t\t\t'',\n\t\t];\n\t}\n};\n\n\nconst R_STRLIT_LONG_CONTENTS_ESCAPES_HARD = /(?:\\\\(?:([tnrfb])|([\\\\\"'])|u([0-9A-Fa-f]{4})|U([0-9A-Fa-f]{8}))|(\\\\.))/g;\nconst R_STRLIT_LONG_CONTENTS_ESCAPES_SOFT = /(?:\\\\(?:([tnrfb])|([\\\\\"'])|u([0-9A-Fa-f]{4})|U([0-9A-Fa-f]{8}))|(\\\\[^uU]|\\\\u[^]{4}|\\\\U[^]{8}))/g;\n\nconst unescape_literal_long_hard = s_literal => s_literal\n\t.replace(R_STRLIT_LONG_CONTENTS_ESCAPES_HARD, F_REPLACE_STRLIT_CONTENTS);\n\nconst unescape_literal_long_soft = (s_literal) => {\n\tlet m_incomplete = R_STRLIT_ESCAPE_INCOMPLETE.exec(s_literal);\n\n\t// incomplete escape\n\tif(m_incomplete) {\n\t\tlet i_safe = m_incomplete.index;\n\n\t\t// rewind\n\t\treturn [\n\t\t\ts_literal.slice(0, i_safe)\n\t\t\t\t.replace(R_STRLIT_LONG_CONTENTS_ESCAPES_SOFT, F_REPLACE_STRLIT_CONTENTS),\n\t\t\ts_literal.slice(i_safe),\n\t\t];\n\t}\n\t// done\n\telse {\n\t\treturn [\n\t\t\ts_literal\n\t\t\t\t.replace(R_STRLIT_LONG_CONTENTS_ESCAPES_SOFT, F_REPLACE_STRLIT_CONTENTS),\n\t\t\t'',\n\t\t];\n\t}\n};\n\n// lookbehind regexes\nconst [\n\tR_STRLIT_ESCAPE_INCOMPLETE,\n\tR_STRLIT_SHORT_DOUBLE_TERM,\n\tR_STRLIT_SHORT_SINGLE_TERM,\n\tR_STRLIT_LONG_DOUBLE_TERM,\n\tR_STRLIT_LONG_SINGLE_TERM,\n] = (() => {\n\tfunction RegExp_$lookbehind_polyfill(s_input) {\n\t\tlet m_match = RegExp.prototype.exec.call(this, s_input);\n\n\t\tif(m_match) {\n\t\t\tlet i_start = m_match[0].length - m_match[1].length;\n\t\t\tm_match.index += i_start;\n\t\t\tm_match[0] = m_match[0].slice(i_start);\n\t\t}\n\n\t\treturn m_match;\n\t}\n\tlet mk_lookbehind_regex = (() => {\n\t\ttry {\n\t\t\tnew RegExp('(?<!h)i');  // eslint-disable-line no-new\n\t\t}\n\t\tcatch(e_compile) {\n\t\t\treturn (f_lookbehind, r_polyfill, f_polyfill) => {\n\t\t\t\tr_polyfill.exec = f_polyfill;\n\t\t\t\treturn r_polyfill;\n\t\t\t};\n\t\t}\n\t\treturn f_lookbehind => f_lookbehind();\n\t})();\n\treturn [\n\t\t// R_STRLIT_ESCAPE_INCOMPLETE\n\t\tmk_lookbehind_regex(\n\t\t\t() => new RegExp('(?<!(?:[^\\\\\\\\]|^)(?:\\\\\\\\\\\\\\\\)*\\\\\\\\)\\\\\\\\(|u[0-9A-Fa-f]{0,3}|U[0-9A-Fa-f]{0,7})$'),\n\t\t\t/^(?:(?:[^\\\\]|\\\\.)*)(\\\\(?:|u[0-9A-Fa-f]{0,3}|U[0-9A-Fa-f]{0,7}))$/,\n\t\t\tfunction RegExp_$lookbehind_polyfill_n(s_input) {\n\t\t\t\tlet m_match = RegExp.prototype.exec.call(this, s_input);\n\t\t\t\tif(m_match) {\n\t\t\t\t\tm_match.index += m_match[0].length - m_match[1].length;\n\t\t\t\t}\n\n\t\t\t\treturn m_match;\n\t\t\t},\n\t\t),\n\t\t// R_STRLIT_SHORT_DOUBLE_TERM\n\t\tmk_lookbehind_regex(\n\t\t\t() => new RegExp('(?<!(?:[^\\\\\\\\]|^)(?:\\\\\\\\\\\\\\\\)*\\\\\\\\)\"\\\\s*', 'g'),\n\t\t\t/(?:[^\\\\\"]|\\\\.)*(\"\\s*)/y,\n\t\t\tRegExp_$lookbehind_polyfill,\n\t\t),\n\t\t// R_STRLIT_SHORT_SINGLE_TERM\n\t\tmk_lookbehind_regex(\n\t\t\t() => new RegExp('(?<!(?:[^\\\\\\\\]|^)(?:\\\\\\\\\\\\\\\\)*\\\\\\\\)\\'\\\\s*', 'g'),\n\t\t\t/(?:[^\\\\']|\\\\.)*('\\s*)/y,\n\t\t\tRegExp_$lookbehind_polyfill,\n\t\t),\n\n\t\t// R_STRLIT_LONG_DOUBLE_TERM\n\t\tmk_lookbehind_regex(\n\t\t\t() => new RegExp('(?<!(?:[^\\\\\\\\]|^)(?:\\\\\\\\\\\\\\\\)*\\\\\\\\)\"\"\"\\\\s*', 'g'),\n\t\t\t/(?:[^\\\\\"]|\\\\.|\"\"?(?!\"))*(\"\"\"\\s*)/y,\n\t\t\tRegExp_$lookbehind_polyfill,\n\t\t),\n\n\t\t// R_STRLIT_LONG_SINGLE_TERM\n\t\tmk_lookbehind_regex(\n\t\t\t() => new RegExp('(?<!(?:[^\\\\\\\\]|^)(?:\\\\\\\\\\\\\\\\)*\\\\\\\\)\\'\\'\\'\\\\s*', 'g'),\n\t\t\t/(?:[^\\\\']|\\\\.|''?(?!'))*('''\\s*)/y,\n\t\t\tRegExp_$lookbehind_polyfill,\n\t\t),\n\n\t];\n})();\n\nconst match_prefixed_name_quick = (s, i) => {\n\tR_PREFIXED_NAME_QUICK.lastIndex = i;\n\treturn [R_PREFIXED_NAME_QUICK.exec(s), R_PREFIXED_NAME_QUICK.lastIndex];\n};\n\nconst match_prefixed_name_escapeless = (s, i) => {\n\tR_PREFIXED_NAME_ESCAPELESS.lastIndex = i;\n\treturn [R_PREFIXED_NAME_ESCAPELESS.exec(s), R_PREFIXED_NAME_ESCAPELESS.lastIndex];\n};\n\nconst match_prefixed_name = (s, i) => {\n\tR_PREFIXED_NAME.lastIndex = i;\n\treturn [R_PREFIXED_NAME.exec(s), R_PREFIXED_NAME.lastIndex];\n};\n\n\n\nfunction Reader$syntax_error(k_self, i, si_state, s_info) {\n\tlet i_off = Math.min(i, Math.abs(i-15));\n\n\tlet s = k_self.s;\n\n\treturn k_self.error(`\\n\\`${s.substr(i_off, i_off+90).replace(/[\\n\\t]/g, ' ')}\\`\\n`\n\t\t+` ${' '.repeat(i-i_off)}^\\n`\n\t\t+`expected ${si_state} ${s_info || ''}.  failed to parse a valid token starting at ${s[i]? '\"'+s[i]+'\"': '<<EOF>>'}`);\n}\n\n\n\nclass TriG_Reader extends stream.Transform {\n\tconstructor(g_impls) {\n\t\tsuper({\n\t\t\t// do not decode strings into buffers\n\t\t\tdecodeStrings: false,\n\n\t\t\t// accept strings as input on writable side\n\t\t\twritableObjectMode: false,\n\n\t\t\t// output quad objects on readable side\n\t\t\treadableObjectMode: true,\n\n\t\t\t// implementations\n\t\t\tflush: g_impls.flush,\n\t\t\ttransform: g_impls.transform,\n\t\t});\n\t}\n\n\t// intercept pipe\n\tpipe(ds_out) {\n\t\tlet ds_dst = ds_out;\n\n\t\t// non-object mode\n\t\tif(!ds_dst._writableState.objectMode) {\n\t\t\t// transform to JSON\n\t\t\tds_out = stream.quads_to_json();\n\t\t}\n\t\t// yet object mode and graphy writable\n\t\telse if(ds_out.isGraphyWritable) {\n\t\t\t// transform to writable data events\n\t\t\tds_out = stream.quads_to_writable();\n\t\t}\n\n\t\t// interim stream created\n\t\tif(ds_out !== ds_dst) {\n\t\t\t// forward output to super\n\t\t\tsuper.pipe(ds_out);\n\n\t\t\t// pipe outpu to destination\n\t\t\treturn ds_out.pipe(ds_dst);\n\t\t}\n\t\t// forward as-is to super\n\t\telse {\n\t\t\treturn super.pipe(ds_dst);\n\t\t}\n\t}\n}\n\n\nclass Reader {\n\tconstructor(g_config={}) {\n\t\t// impl-specific configs\n\t\tlet {\n\t\t\t// input medium\n\t\t\tinput: g_input=null,\n\n\t\t\t// a state to inherit\n\t\t\tstate: g_state={},\n\t\t} = g_config;\n\n\t\t// inherit state from creator\n\t\tlet {\n\t\t\t// index for anonymous blank node labels\n\t\t\tblank_node_index: i_anon=0,\n\n\t\t\t// prefix map\n\t\t\tprefixes: h_prefixes={},\n\n\t\t\t// blank node label map\n\t\t\tlabels: h_labels={},\n\t\t} = g_state;\n\n\n\t\tlet dc_factory = factory.adopt(g_config.dataFactory || g_config.data_factory || factory.unfiltered);\n\n\t\tlet kt_default_graph = dc_factory.defaultGraph();\n\n\t\t// if data factory is not graphy, it might be returning the same object on each call to .defaultGraph()\n\t\tif(dc_factory !== factory.unfiltered) {\n\t\t\t// do not trust it, create a new object\n\t\t\tkt_default_graph = Object.create(kt_default_graph);\n\t\t}\n\n\t\tlet kt_rdf_first = dc_factory.namedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#first');\n\n\t\tlet blankNode = dc_factory.blankNode;\n\t\tlet namedNode = dc_factory.namedNode;\n\n\t\tthis.emit_data = factory.unfiltered === dc_factory\n\t\t\t? function() {\n\t\t\t\tds_transform.push(quad(this));\n\t\t\t}\n\t\t\t: function() {\n\t\t\t\tlet g_quad = dc_factory.quad(this._kt_subject, this._kt_predicate, this._kt_object, this._kt_graph);\n\t\t\t\tds_transform.push(g_quad);\n\t\t\t};\n\n\t\t// fields\n\t\tObject.assign(this, {\n\t\t\t// read index\n\t\t\ti: 0,\n\n\t\t\t// string buffer\n\t\t\ts: '',\n\n\t\t\t// string buffer length\n\t\t\tn: 0,\n\n\t\t\t// left-over string from previous data chunk\n\t\t\tpre: g_config.prepend || '',\n\n\t\t\t// debug state\n\t\t\t_b_debug: g_config.debug || false,\n\n\t\t\t// relax\n\t\t\t_b_relax: g_config.relax || false,\n\n\t\t\t// factory\n\t\t\t_dc_factory: dc_factory,\n\n\t\t\t// current reader state\n\t\t\t_f_state: this.block,\n\n\t\t\t// map of current prefix ids => iris\n\t\t\t_h_prefixes: h_prefixes,\n\n\n\t\t\t// reader was destroyed by an error\n\t\t\t_b_destroyed: false,\n\n\t\t\t// current @base url\n\t\t\t_s_base_url: '',\n\t\t\t_s_base_url_scheme: '',\n\t\t\t_s_base_url_root: '',\n\t\t\t_s_base_url_path: '',\n\n\t\t\t// current data\n\t\t\t_kt_subject: null,\n\t\t\t_kt_predicate: kt_rdf_first,\n\t\t\t_kt_object: null,\n\t\t\t_kt_graph: kt_default_graph,\n\t\t\t_s_literal: '',\n\n\t\t\t// static terms\n\t\t\t_kt_rdf_type: dc_factory.namedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#type'),\n\t\t\t_kt_rdf_first: kt_rdf_first,\n\t\t\t_kt_rdf_rest: dc_factory.namedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#rest'),\n\t\t\t_kt_rdf_nil: dc_factory.namedNode('http://www.w3.org/1999/02/22-rdf-syntax-ns#nil'),\n\t\t\t_kt_default_graph: kt_default_graph,\n\n\t\t\t// queue of nested subject, predicate, state for blanknodes and collections\n\t\t\t_a_nested: [],\n\n\t\t\t// hash to keep track of all blank node labels in use\n\t\t\t_h_labels: h_labels,\n\n\t\t\t// event routing\n\t\t\tevent: this.emit,\n\t\t\tdata: this.emit_data,\n\n\t\t\t// for restoring the original event callback when resuming paused stream\n\t\t\trestore_data: this.emit_data,\n\n\t\t\t// keep a queue of data events to hold onto until stream resumes (only happens in rare conditions)\n\t\t\t_a_queue_event: [],\n\n\t\t\t// helper states\n\t\t\t_b_expecting_full_stop: false,\n\t\t\t_s_temp_prefix_id: null,\n\t\t\t_b_trim_start: true,\n\n\t\t\tanonymous_blank_node: s_label => blankNode(s_label, true),\n\n\t\t\t// finds the next non-conflicting blank node label\n\t\t\tnext_label() {\n\t\t\t\tlet s_label = '';\n\t\t\t\tdo {\n\t\t\t\t\ts_label = 'g'+(i_anon++);\n\t\t\t\t} while(this._h_labels[s_label]);\n\n\t\t\t\t// claim this label, and remember that we invented it\n\t\t\t\tthis._h_labels[s_label] = 2;\n\n\t\t\t\t// return the label\n\t\t\t\treturn s_label;\n\t\t\t},\n\n\t\t\t// what to do when reach eos\n\t\t\teos: null,\n\n\t\t\t// which state to go to after end of statement\n\t\t\tafter_end_of_statement: this.post_object,\n\n\t\t\t// maximum length of a token: defaults to 2048 => http://stackoverflow.com/a/417184/1641160\n\t\t\t_n_max_token_length: g_config.max_token_length || g_config.maxTokenLength || 2048,\n\n\t\t\t// maximum length of a string (overrides max_token_length): defaults to Infinity\n\t\t\t_n_max_string_length: g_config.max_string_length || g_config.maxStringLength || Infinity,\n\n\t\t\t// byte tracking\n\t\t\t_b_byte_tracking: g_config.byte_tracking || g_config.byteTracking || false,\n\t\t\t_nb_seen: 0,\n\t\t\t_nb_last: 0,\n\t\t\t_nb_curr: 0,\n\t\t});\n\n\t\tif(g_config.relaxed) {\n\t\t\tconsole.warn((new Error(`no such option 'relaxed'; did you mean 'relax' ?`)).stack.replace(/^Error:/, 'Warning:'));\n\t\t}\n\t\tif('validate' in g_config) {\n\t\t\tconsole.warn((new Error(`option 'validate' has been deprecated. Validation is now enabled by default. Use the 'relax' option if you wish to disable validation.`)).stack.replace(/^Error:/, 'Warning:'));\n\t\t}\n\n\n\n\t\t// term constructors\n\t\tObject.assign(this, !g_config.relax\n\t\t\t? {\n\t\t\t\tblank_node(s_label) {\n\t\t\t\t\t// test valid blank node label\n\t\t\t\t\tif(!RT_BLANK_NODE_VALID.test(s_label)) return this.error(`invalid blank node label: \"${s_label}\"`);\n\n\t\t\t\t\t// not first time use of label\n\t\t\t\t\tlet z_label_state = this._h_labels[s_label];\n\t\t\t\t\tif(z_label_state) {\n\t\t\t\t\t\t// label was used previously by document and has no conflict\n\t\t\t\t\t\tif(1 === z_label_state) {}  // eslint-disable-line no-empty\n\t\t\t\t\t\t// label is in use by invention, this would cause a conflict\n\t\t\t\t\t\telse if(2 === z_label_state) {\n\t\t\t\t\t\t\t// so create a redirect mapping for this actual label & use it instead\n\t\t\t\t\t\t\ts_label = this._h_labels[s_label] = this.next_label();\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// label already has a redirect mapping\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t// use redirected label\n\t\t\t\t\t\t\ts_label = this._h_labels[s_label];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// first time use of label\n\t\t\t\t\telse {\n\t\t\t\t\t\t// store label in hash so we avoid future collisions\n\t\t\t\t\t\tthis._h_labels[s_label] = 1;\n\t\t\t\t\t}\n\n\t\t\t\t\t// make term\n\t\t\t\t\treturn blankNode(s_label);\n\t\t\t\t},\n\n\t\t\t\tcheck_named_node(p_iri) {\n\t\t\t\t\tif(!RT_NAMED_NODE_VALID.test(p_iri)) return this.error(`invalid IRI: \"${p_iri}\"`);\n\t\t\t\t\treturn namedNode(p_iri);\n\t\t\t\t},\n\n\t\t\t\tcheck_named_node_escapeless(p_iri) {\n\t\t\t\t\tif(!RT_NAMED_NODE_ESCAPELESS_VALID.test(p_iri)) return this.error(`invalid IRI: \"${p_iri}\"`);\n\t\t\t\t\treturn namedNode(p_iri);\n\t\t\t\t},\n\n\t\t\t\tmatch_prefixed_name_quick(s, i) {\n\t\t\t\t\tR_PREFIXED_NAME_QUICK.lastIndex = i;\n\t\t\t\t\treturn [R_PREFIXED_NAME_QUICK.exec(s), R_PREFIXED_NAME_QUICK.lastIndex];\n\t\t\t\t},\n\n\t\t\t\tmatch_prefixed_name_escapeless(s, i) {\n\t\t\t\t\tlet [m_prefixed_name_e, im_prefixed_name_e] = match_prefixed_name_escapeless(s, i);\n\t\t\t\t\tif(m_prefixed_name_e) {\n\t\t\t\t\t\t// invalid local name\n\t\t\t\t\t\tif(!RT_PREFIXED_NAME_LOCAL_NAME_VALID.test(m_prefixed_name_e[2]) && m_prefixed_name_e[2]) {\n\t\t\t\t\t\t\tthis.error(`invalid prefixed name local name: \"${m_prefixed_name_e[2]}:\"`);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn [m_prefixed_name_e, im_prefixed_name_e];\n\t\t\t\t},\n\n\t\t\t\tmatch_prefixed_name(s, i) {\n\t\t\t\t\tlet [m_prefixed_name, im_prefixed_name] = match_prefixed_name(s, i);\n\t\t\t\t\tif(m_prefixed_name) {\n\t\t\t\t\t\t// invalid local name\n\t\t\t\t\t\tif(!RT_PREFIXED_NAME_LOCAL_NAME_VALID.test(m_prefixed_name[2])) {\n\t\t\t\t\t\t\tthis.error(`invalid prefixed name local name: \"${m_prefixed_name[2]}:\"`);\n\t\t\t\t\t\t\treturn;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\treturn [m_prefixed_name, im_prefixed_name];\n\t\t\t\t},\n\t\t\t}\n\t\t\t: {\n\t\t\t\t// term constructors\n\t\t\t\tblank_node(s_label) {\n\t\t\t\t\t// not first time use of label\n\t\t\t\t\tlet z_label_state = this._h_labels[s_label];\n\t\t\t\t\tif(z_label_state) {\n\t\t\t\t\t\t// label was used previously by document and has no conflict\n\t\t\t\t\t\tif(1 === z_label_state) {}  // eslint-disable-line no-empty\n\t\t\t\t\t\t// label is in use by invention, this would cause a conflict\n\t\t\t\t\t\telse if(2 === z_label_state) {\n\t\t\t\t\t\t\t// so create a redirect mapping for this actual label & use it instead\n\t\t\t\t\t\t\ts_label = this._h_labels[s_label] = this.next_label();\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// label already has a redirect mapping\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t// use redirected label\n\t\t\t\t\t\t\ts_label = this._h_labels[s_label];\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// first time use of label\n\t\t\t\t\telse {\n\t\t\t\t\t\t// store label in hash so we avoid future collisions\n\t\t\t\t\t\tthis._h_labels[s_label] = 1;\n\t\t\t\t\t}\n\n\t\t\t\t\t// make term\n\t\t\t\t\treturn blankNode(s_label);\n\t\t\t\t},\n\n\t\t\t\tcheck_named_node: namedNode,\n\n\t\t\t\tcheck_named_node_escapeless: namedNode,\n\n\t\t\t\tmatch_prefixed_name_escapeless,\n\n\t\t\t\tmatch_prefixed_name,\n\t\t\t});\n\n\n\t\tthis.named_node = namedNode;\n\n\t\tthis.prefixed_name = function(si_prefix, s_suffix) {\n\t\t\treturn namedNode(h_prefixes[si_prefix] + s_suffix);\n\t\t};\n\n\n\t\t// oops -- user passed string into `base`\n\t\tif('string' === typeof g_config.base) {\n\t\t\tthrow new TypeError(`invalid type 'string' was given for 'base' event listener: '${g_config.base}'\\n`\n\t\t\t\t+`did you mean to use the 'base_uri' key instead?`);\n\t\t}\n\n\t\t// base uri\n\t\tlet p_set_base_uri = g_config.base_uri || g_config.baseUri || g_config.baseURI || g_config.base_iri || g_config.baseIri || g_config.baseIRI;\n\t\tif(p_set_base_uri) {\n\t\t\tlet m_base_iri = R_BASE_IRI.exec(p_set_base_uri);\n\t\t\tthis._s_base_url = m_base_iri[1];\n\t\t\tthis._s_base_url_root = m_base_iri[2] || '';\n\t\t\tthis._s_base_url_scheme = m_base_iri[3] || '';\n\t\t\tthis._s_base_url_path = m_base_iri[4] || '';\n\t\t}\n\t\t// not set; 'url' variant is\n\t\telse if(g_config.base_url || g_config.baseUrl || g_config.baseURL) {\n\t\t\tthrow new Error(`invalid option: .base${g_config.base_url? '_url': g_config.baseUrl? 'Url': g_config.baseURL? 'URL': ''}; use the '.base_uri' key instead`);\n\t\t}\n\n\t\t// transform stream\n\t\tlet ds_transform = this.transform = new TriG_Reader({\n\t\t\t// on data event\n\t\t\ttransform: (s_chunk, s_encoding, fke_chunk) => {\n\t\t\t\t// concatenate current chunk to previous chunk\n\t\t\t\tlet s = this.s = this.pre + s_chunk;\n\n\t\t\t\t// cache chunk length\n\t\t\t\tthis.n = s.length;\n\n\t\t\t\t// eat whitespace before token and reset index\n\t\t\t\tif(this._b_trim_start) {\n\t\t\t\t\t// consume whitespace (and incidentally reset index)\n\t\t\t\t\tR_WS.lastIndex = 0;\n\t\t\t\t\tR_WS.exec(s);\n\t\t\t\t\tthis.i = R_WS.lastIndex;\n\t\t\t\t}\n\t\t\t\t// do not eat whitespace; start at beginning\n\t\t\t\telse {\n\t\t\t\t\tthis.i = 0;\n\t\t\t\t}\n\n\t\t\t\t// resume parsing; no errors\n\t\t\t\tif(this.safe_parse(true)) {\n\t\t\t\t\t// emit progress event updates\n\t\t\t\t\tds_transform.emit('progress', s_chunk.length);\n\n\t\t\t\t\t// done transforming this chunk\n\t\t\t\t\tfke_chunk();\n\t\t\t\t}\n\t\t\t},\n\n\t\t\t// once there's no more data to consume, invoke eof\n\t\t\tflush: (fke_flush) => {\n\t\t\t\t// now that input stream has ended, clean up remainder\n\t\t\t\ttry {\n\t\t\t\t\tthis.eof(1);\n\t\t\t\t}\n\t\t\t\t// read error occurred\n\t\t\t\tcatch(e_eof) {\n\t\t\t\t\t// destroy self and stream\n\t\t\t\t\tthis.destroy(e_eof);\n\n\t\t\t\t\t// exit gracefully\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// no errors. done flushing, close read stream\n\t\t\t\tfke_flush();\n\t\t\t},\n\t\t});\n\n\t\t// when the writable side is piped into\n\t\tds_transform.on('pipe', (ds_input) => {\n\t\t\tthis._ds_input = ds_input;\n\n\t\t\tlet b_byte_tracking = this._b_byte_tracking;\n\n\t\t\t// byte-tracking is disable & input stream has encoding option; ensure stream encoding is utf8\n\t\t\tif(!b_byte_tracking && 'function' === typeof ds_input.setEncoding) {\n\t\t\t\tds_input.setEncoding('utf8');\n\t\t\t}\n\t\t\t// set decoding on write\n\t\t\telse {\n\t\t\t\tlet f_write = ds_transform.write;\n\t\t\t\tlet d_decoder = new string_decoder.StringDecoder('utf8');\n\n\t\t\t\tlet f_write_track = (s_chunk, s_encoding, fk_write) => {\n\t\t\t\t\t// TODO: optimize by testing for multibyte chars and using string length instead?\n\t\t\t\t\tlet nb_chunk = Buffer.from(s_chunk, 'utf8').length;\n\t\t\t\t\tthis._nb_seen += nb_chunk;\n\t\t\t\t\tthis._nb_last = nb_chunk;\n\t\t\t\t\treturn f_write.call(ds_transform, s_chunk, s_encoding, fk_write);\n\t\t\t\t};\n\n\t\t\t\tlet f_decode_write_track = (ab_chunk, s_encoding, fk_write) => {\n\t\t\t\t\tlet nb_chunk = this._nb_last = ab_chunk.length;\n\t\t\t\t\tthis._nb_seen += nb_chunk;\n\t\t\t\t\treturn f_write.call(ds_transform, d_decoder.write(ab_chunk), s_encoding, fk_write);\n\t\t\t\t};\n\n\t\t\t\tlet f_decode_write = (ab_chunk, s_encoding, fk_write) => f_write.call(ds_transform, d_decoder.write(ab_chunk), s_encoding, fk_write);\n\n\t\t\t\tds_transform.write = function(z_chunk, s_encoding, fk_write) {\n\t\t\t\t\t// not null\n\t\t\t\t\tif(null !== z_chunk) {\n\t\t\t\t\t\t// chunk is string; adapt by resetting method to original\n\t\t\t\t\t\tif('string' === typeof z_chunk) {\n\t\t\t\t\t\t\tds_transform.write = b_byte_tracking? f_write_track: f_write;\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// chunk is buffer; adapt by setting decoder write method\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tds_transform.write = b_byte_tracking? f_decode_write_track: f_decode_write;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// use set method\n\t\t\t\t\t\treturn ds_transform.write(z_chunk, s_encoding, fk_write);\n\t\t\t\t\t}\n\n\t\t\t\t\t// null, use parent\n\t\t\t\t\treturn f_write.call(ds_transform, z_chunk, s_encoding, fk_write);\n\t\t\t\t};\n\n\t\t\t\t// byte tracking is enabled\n\t\t\t\tif(b_byte_tracking) {\n\t\t\t\t\t// overwrite emit_data method\n\t\t\t\t\tthis.emit_data = this.data = this.restore_data = function() {\n\t\t\t\t\t\tlet g_quad = this._dc_factory.quad(this._kt_subject, this._kt_predicate, this._kt_object, this._kt_graph);\n\t\t\t\t\t\tlet nb_post = Buffer.from(this.s.slice(this.i)).length;\n\t\t\t\t\t\tlet ib_post = this._nb_seen - nb_post;\n\t\t\t\t\t\tg_quad.byteRange = [this._nb_curr, ib_post];\n\t\t\t\t\t\tthis._nb_curr = ib_post;\n\t\t\t\t\t\tthis.transform.push(g_quad);\n\t\t\t\t\t};\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\n\t\t// new listener added\n\t\tds_transform.on('newListener', (s_event) => {\n\t\t\t// comment\n\t\t\tif('comment' === s_event) {\n\t\t\t\tthis.emit_comments = (s_captured) => {\n\t\t\t\t\tlet a_comments = s_captured.slice(1).replace(/\\n\\s+$/, '').split(/\\n+\\s*#/g);\n\n\t\t\t\t\tfor(let s_comment of a_comments) {\n\t\t\t\t\t\tds_transform.emit('comment', s_comment);\n\t\t\t\t\t}\n\t\t\t\t};\n\t\t\t}\n\t\t});\n\n\t\t// destroy\n\t\tds_transform._destroy = (...a_args) => {\n\t\t\tthis.destroy(...a_args);\n\t\t};\n\n\t\t// bind events to transform stream\n\t\tthis.bind(g_config);\n\n\t\t// input given\n\t\tif(g_input) {\n\t\t\t// input is stream\n\t\t\tif(g_input.stream) {\n\t\t\t\tlet ds_input = g_input.stream;\n\n\t\t\t\t// go async so caller has chance to bind event listeners\n\t\t\t\tqueueMicrotask(() => {\n\t\t\t\t\tds_input.pipe(ds_transform);\n\t\t\t\t});\n\t\t\t}\n\t\t\t// string\n\t\t\telse if('string' === typeof g_input.string) {\n\t\t\t\tlet s_input = g_input.string;\n\n\t\t\t\t// go async so caller has chance to bind event listeners\n\t\t\t\tqueueMicrotask(() => {\n\t\t\t\t\tds_transform.end(s_input, 'utf8');\n\t\t\t\t});\n\t\t\t}\n\t\t\t// invalid arg\n\t\t\telse {\n\t\t\t\tthrow new TypeError(`Invalid argument for input parameter: ${'object' === typeof g_input? JSON.stringify(g_input): g_input}`);\n\t\t\t}\n\t\t}\n\t}\n\n\t// begin parsing, keep applying until no more stack bail-outs\n\tsafe_parse() {\n\t\ttry {\n\t\t\tlet f_sync = this._f_state();\n\t\t\twhile('function' === typeof f_sync) {\n\t\t\t\tf_sync = f_sync.apply(this);\n\t\t\t}\n\t\t}\n\t\t// read error occurred\n\t\tcatch(e_read) {\n\t\t\t// destroy self and stream\n\t\t\tthis.destroy(e_read);\n\n\t\t\t// failure\n\t\t\treturn false;\n\t\t}\n\n\t\t// okay\n\t\treturn true;\n\t}\n\n\n\temit(s_event, ...a_args) {\n\t\tthis.transform.emit(s_event, ...a_args);\n\t}\n\n\tqueue(s_event, ...a_args) {\n\t\tthis._a_queue_event.push({\n\t\t\tevent: s_event,\n\t\t\targs: a_args,\n\t\t});\n\t}\n\n\terror(s_message) {\n\t\t// bail out\n\t\tthrow new Error(s_message);\n\t}\n\n\t// parse_error (not meant to be an event callback)\n\tparse_error(s_expected, b_eof=false) {\n\t\tlet i = this.i;\n\n\t\tlet i_off = Math.min(i, Math.abs(i-15));\n\n\t\tlet s = this.s;\n\n\t\treturn this.error(`\\n\\`${s.substr(i_off, i_off+90).replace(/[\\n\\t]/g, ' ')}\\`\\n`\n\t\t\t+` ${' '.repeat(i-i_off)}^\\n`\n\t\t\t+`expected ${s_expected} ${b_eof? 'but encountered <<EOF>>': ''}.  failed to parse a valid token starting at ${s[i]? '\"'+s[i]+'\"': '<<EOF>>'}`);\n\t}\n\n\tinfo_error(s_message) {\n\t\tlet i = this.i;\n\n\t\tlet i_off = Math.min(i, Math.abs(i-15));\n\n\t\tlet s = this.s;\n\n\t\tthis.error(`\\n\\`${s.substr(i_off, i_off+90).replace(/[\\n\\t]/g, ' ')}\\`\\n`\n\t\t\t+` ${' '.repeat(i-i_off)}^\\n`\n\t\t\t+s_message);\n\t}\n\n\t// end of file\n\teof() {\n\t\t// there are events queued\n\t\tif(this._a_queue_event.length) {\n\t\t\tlet a_queue = this._a_queue_event;\n\n\t\t\t// drain event queue\n\t\t\twhile(a_queue.length) {\n\t\t\t\t// remove event from front of queue\n\t\t\t\tlet h_event = a_queue.shift();\n\n\t\t\t\t// make event callback\n\t\t\t\tthis[h_event.event](h_event.data);\n\t\t\t}\n\t\t}\n\n\t\t// invalid parsing state\n\t\tif(this.block !== this._f_state) {\n\t\t\t// append EOF char\n\t\t\tthis.s += '\\0';\n\n\t\t\t// exit \"flowing\" mode\n\t\t\tthis.n = this.s.length;\n\n\t\t\t// resume parsing; no errors\n\t\t\tif(this.safe_parse()) {\n\t\t\t\t// eof has occurred under safe parse\n\t\t\t\tif(null === this.s) return;\n\n\t\t\t\t// still invalid parsing state\n\t\t\t\tif(this.block !== this._f_state) {\n\t\t\t\t\treturn this.parse_error(this._f_state.name, true);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// there are still unparsed characters\n\t\tif(this.i < this.n) {\n\t\t\t// consume whitespace and comments\n\t\t\tlet s = this.s;\n\t\t\tlet i = this.i;\n\t\t\t// consume whitespace (and incidentally reset index)\n\t\t\tR_WS.lastIndex = i;\n\t\t\tR_WS.exec(s);\n\t\t\ti = R_WS.lastIndex;\n\t\t\tR_COMMENT.lastIndex = i;\n\t\t\tlet m_comment = R_COMMENT.exec(s);\n\n\t\t\t// advance beyond comment\n\t\t\tif(R_COMMENT.lastIndex > i) {\n\t\t\t\tthis.i = i = R_COMMENT.lastIndex;\n\t\t\t\tif(this.emit_comments) this.emit_comments(m_comment[0]);\n\t\t\t}\n\n\t\t\t// still unparsed characters\n\t\t\tif(i < this.n) {\n\t\t\t\t// not EOF\n\t\t\t\tif(!(i === this.n - 1 && '\\0' === s[i])) {\n\t\t\t\t\t// bad input; parse error\n\t\t\t\t\treturn this.parse_error(this._f_state.name);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// make buffer's alloc eligible for gc\n\t\tthis.s = null;\n\n\t\t// transform stream\n\t\tlet ds_transform = this.transform;\n\n\t\t// final progress update: no additional bytes were read\n\t\tds_transform.emit('progress', 0);\n\n\t\t// call end event listener\n\t\tds_transform.emit('eof', this._h_prefixes);\n\n\t\t// close write stream (EOF-signaling)\n\t\tds_transform.push(null);\n\t}\n\n\n\n\t// bind event listeners to transform stream\n\tbind(g_config) {\n\t\tlet ds_transform = this.transform;\n\t\tif(g_config.base) ds_transform.on('base', g_config.base);\n\t\tif(g_config.prefix) ds_transform.on('prefix', g_config.prefix);\n\t\tif(g_config.enter) ds_transform.on('enter', g_config.enter);\n\t\tif(g_config.exit) ds_transform.on('exit', g_config.exit);\n\t\tif(g_config.comment) ds_transform.on('comment', g_config.comment);\n\t\tif(g_config.error) ds_transform.on('error', g_config.error);\n\t\tif(g_config.read) ds_transform.once('read', g_config.read);\n\t\tif(g_config.progress) ds_transform.on('progress', g_config.progress);\n\t\tif(g_config.eof) ds_transform.once('eof', g_config.eof);\n\t\tif(g_config.end) ds_transform.once('end', g_config.end);\n\t\tif(g_config.finish) ds_transform.once('finish', g_config.finish);\n\t\tif(g_config.data) ds_transform.on('data', g_config.data);\n\t}\n\n\t// after a blank node subject (either property-list or colleciton)\n\tpost_blank_subject() {\n\t\tlet {s, i} = this;\n\t\tif('.' === s[i]) {\n\t\t\t// consume whitespace (and incidentally reset index)\n\t\t\tR_WS.lastIndex = i+1;\n\t\t\tR_WS.exec(s);\n\t\t\tthis.i = R_WS.lastIndex;\n\n\t\t\t// not inside block\n\t\t\tif(this._kt_default_graph === this._kt_graph) {\n\t\t\t\treturn this.block();\n\t\t\t}\n\t\t\t// inside block\n\t\t\telse {\n\t\t\t\treturn this.statement();\n\t\t\t}\n\t\t}\n\t\telse {\n\t\t\t// prepare sticky regex index\n\t\t\tR_CHAR_CLOSE.lastIndex = i;\n\n\t\t\tif(R_CHAR_CLOSE.exec(s)) {\n\t\t\t\t// advance index\n\t\t\t\tthis.i = R_CHAR_CLOSE.lastIndex;\n\t\t\t\t// empty collection\n\t\t\t\tif(this._kt_rdf_nil.equals(this._kt_subject)) {\n\t\t\t\t\treturn this.error('empty collection');\n\t\t\t\t}\n\n\t\t\t\t// emit graph_close event\n\t\t\t\tthis.emit('exit', this._kt_graph);\n\n\t\t\t\t// reset graph\n\t\t\t\tthis._kt_graph = this._kt_default_graph;\n\n\t\t\t\t// goto block state\n\t\t\t\treturn this.block();\n\t\t\t}\n\t\t} // brace #1\n\n\t\treturn this.pairs();\n\t}\n\n\n\n\t// parse state for statement\n\tstatement() {\n\t\t// destruct chunk, length, and index\n\t\tlet {s, n, i} = this;\n\n\t\t// start labeled loop, run while there are characters\n\t\twhile(i < n) {  // eslint-disable-line no-unmodified-loop-condition\n// prefixed name quick\n\n\t\t\t// prepare sticky regex index\n\t\t\tR_PREFIXED_NAME_QUICK.lastIndex = i;\n\t\t\t// execute regex\n\t\t\tlet m_pnq_subject = R_PREFIXED_NAME_QUICK.exec(s);\n\n\t\t\t// regex was a match\n\t\t\tif(m_pnq_subject) {\n\t\t\t\t// advance index\n\t\t\t\tthis.i = R_PREFIXED_NAME_QUICK.lastIndex;\n\t\t\t\t// check valid prefix\n\t\t\t\tlet s_prefix_id = m_pnq_subject[1] || '';\n\t\t\t\t// invalid prefix\n\t\t\t\tif(!OPHOP.call(this._h_prefixes, s_prefix_id)) return this.error(`no such prefix \"${s_prefix_id}\"`);\n\n\n\t\t\t\t// commit subject iri from resolve prefixed name\n\t\t\t\tthis._kt_subject = this.prefixed_name(s_prefix_id, m_pnq_subject[2]);\n\n\t\t\t\t// predicate-object pairs state\n\t\t\t\treturn this.pairs();\n\n\t\t\t// iriref\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// prepare sticky regex index\n\t\t\t\tR_IRIREF_ESCAPELESS.lastIndex = i;\n\t\t\t\t// execute regex\n\t\t\t\tlet m_iriref_e_subject = R_IRIREF_ESCAPELESS.exec(s);\n\n\t\t\t\t// regex was a match\n\t\t\t\tif(m_iriref_e_subject) {\n\t\t\t\t\t// advance index\n\t\t\t\t\tthis.i = R_IRIREF_ESCAPELESS.lastIndex;\n\n\t\t\t\t\t// ref iri\n\t\t\t\t\tlet s_iri = m_iriref_e_subject[1];\n\t\t\t\t\t// absolute iri\n\t\t\t\t\tif(!this._s_base_url || RT_IRI_ABSOLUTE.test(s_iri)) {\n\t\t\t\t\t\t// set subject\n\t\t\t\t\t\tthis._kt_subject = this.check_named_node_escapeless(s_iri);\n\t\t\t\t\t}\n\t\t\t\t\t// relative iri\n\t\t\t\t\telse {\n\t\t\t\t\t\tthis._kt_subject = this.check_named_node_escapeless(uri.resolve(this._s_base_url, s_iri));\n\t\t\t\t\t}\n\n\t\t\t\t\t// predicate-object pairs state\n\t\t\t\t\treturn this.pairs();\n\n\n\n\t\t\t\t// prefixed name\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// try match\n\t\t\t\t\tlet aw_valid_this_match_prefixed_name_escapeless = this.match_prefixed_name_escapeless(s, i);\n\t\t\t\t\t// stack bail out\n\t\t\t\t\tif(!aw_valid_this_match_prefixed_name_escapeless) return true;\n\t\t\t\t\tlet [m_prefixed_named_e_subject, im_prefixed_named_e_subject] = aw_valid_this_match_prefixed_name_escapeless;\n\t\t\t\t\tif(m_prefixed_named_e_subject) {\n\t\t\t\t\t\t// advance index\n\t\t\t\t\t\tthis.i = im_prefixed_named_e_subject;\n\n\t\t\t\t\t\t// check valid prefix\n\t\t\t\t\t\tlet s_prefix_id = m_prefixed_named_e_subject[1] || '';\n\t\t\t\t\t\t// invalid prefix\n\t\t\t\t\t\tif(!OPHOP.call(this._h_prefixes, s_prefix_id)) return this.error(`no such prefix \"${s_prefix_id}\"`);\n\n\n\t\t\t\t\t\t// make subject key\n\t\t\t\t\t\tthis._kt_subject = this.prefixed_name(s_prefix_id, m_prefixed_named_e_subject[2]);\n\n\t\t\t\t\t\t// predicate-object pairs state\n\t\t\t\t\t\treturn this.pairs();\n\n\t\t\t\t\t// blank node label\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\t\tR_BLANK_NODE_LABEL.lastIndex = i;\n\t\t\t\t\t\t// execute regex\n\t\t\t\t\t\tlet m_blank_node_label_subject = R_BLANK_NODE_LABEL.exec(s);\n\n\t\t\t\t\t\t// regex was a match\n\t\t\t\t\t\tif(m_blank_node_label_subject) {\n\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\tthis.i = R_BLANK_NODE_LABEL.lastIndex;\n\t\t\t\t\t\t\t// extract label\n\t\t\t\t\t\t\tlet s_label = m_blank_node_label_subject[1];\n\n\t\t\t\t\t\t\t// make subject key\n\t\t\t\t\t\t\tthis._kt_subject = this.blank_node(s_label);\n\n\t\t\t\t\t\t\t// predicate-object pairs state\n\t\t\t\t\t\t\treturn this.pairs();\n\n\t\t\t\t\t\t// anonymous blank node subject\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\t\t\tR_ANONYMOUS_BLANK_NODE.lastIndex = i;\n\n\t\t\t\t\t\t\tif(R_ANONYMOUS_BLANK_NODE.exec(s)) {\n\t\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\t\tthis.i = R_ANONYMOUS_BLANK_NODE.lastIndex;\n\t\t\t\t\t\t\t\t// set new blank node as subject\n\t\t\t\t\t\t\t\tthis._kt_subject = this.anonymous_blank_node(this.next_label());\n\n\t\t\t\t\t\t\t\t// goto pairs state for inside property list\n\t\t\t\t\t\t\t\treturn this.pairs();\n\n\t\t\t\t\t\t\t// anonymous blank node property list subject\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\t\t\t\tR_CHAR_BLANK_NODE.lastIndex = i;\n\n\t\t\t\t\t\t\t\tif(R_CHAR_BLANK_NODE.exec(s)) {\n\t\t\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\t\t\tthis.i = R_CHAR_BLANK_NODE.lastIndex;\n\t\t\t\t\t\t\t\t\t// enter blank node\n\t\t\t\t\t\t\t\t\tthis._kt_subject = this.anonymous_blank_node(this.next_label());\n\n\t\t\t\t\t\t\t\t\t// how to resume when we pop state\n\t\t\t\t\t\t\t\t\tthis._a_nested.push([this._kt_subject, this._kt_predicate, 'post_blank_subject']);\n\n\t\t\t\t\t\t\t\t\t// goto pairs state for inside property list\n\t\t\t\t\t\t\t\t\treturn this.pairs();\n\n\t\t\t\t\t\t\t\t// rdf collection\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\t\t\t\t\tR_CHAR_COLLECTION.lastIndex = i;\n\n\t\t\t\t\t\t\t\t\tif(R_CHAR_COLLECTION.exec(s)) {\n\t\t\t\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\t\t\t\tthis.i = R_CHAR_COLLECTION.lastIndex;\n\t\t\t\t\t\t\t\t\t\t// indicate that collection subject should emit an initial statement\n\t\t\t\t\t\t\t\t\t\tthis._kt_subject = null;\n\n// (don't push state, we don't have a subject yet)\n\n\t\t\t\t\t\t\t\t\t\t// goto collection-subject state\n\t\t\t\t\t\t\t\t\t\treturn this.collection_subject();\n\n\n\t\t\t\t\t\t\t\t\t// closing graph '}'\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\t\t\t\t\t\tR_CHAR_CLOSE.lastIndex = i;\n\n\t\t\t\t\t\t\t\t\t\tif(R_CHAR_CLOSE.exec(s)) {\n\t\t\t\t\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\t\t\t\t\tthis.i = R_CHAR_CLOSE.lastIndex;\n\t\t\t\t\t\t\t\t\t\t\t// emit graph_close event\n\t\t\t\t\t\t\t\t\t\t\tthis.emit('exit', this._kt_graph);\n\n\t\t\t\t\t\t\t\t\t\t\t// reset graph\n\t\t\t\t\t\t\t\t\t\t\tthis._kt_graph = this._kt_default_graph;\n\n\t\t\t\t\t\t\t\t\t\t\t// goto block state\n\t\t\t\t\t\t\t\t\t\t\treturn this.block();\n\n\t\t\t\t\t\t\t\t\t\t// iriref\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\t\t\t\t\t\t\tR_IRIREF.lastIndex = i;\n\t\t\t\t\t\t\t\t\t\t\t// execute regex\n\t\t\t\t\t\t\t\t\t\t\tlet m_iriref_subject = R_IRIREF.exec(s);\n\n\t\t\t\t\t\t\t\t\t\t\t// regex was a match\n\t\t\t\t\t\t\t\t\t\t\tif(m_iriref_subject) {\n\t\t\t\t\t\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\t\t\t\t\t\tthis.i = R_IRIREF.lastIndex;\n\n\t\t\t\t\t\t\t\t\t\t\t\t// ref iri\n\t\t\t\t\t\t\t\t\t\t\t\tlet s_iri = m_iriref_subject[1].replace(R_UNICODE_ANY, F_REPLACE_UNICODE_ANY);\n\t\t\t\t\t\t\t\t\t\t\t\t// absolute iri\n\t\t\t\t\t\t\t\t\t\t\t\tif(!this._s_base_url || RT_IRI_ABSOLUTE.test(s_iri)) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t// set subject\n\t\t\t\t\t\t\t\t\t\t\t\t\tthis._kt_subject = this.check_named_node(s_iri);\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t// relative iri\n\t\t\t\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t\t\t\tthis._kt_subject = this.check_named_node(uri.resolve(this._s_base_url, s_iri));\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\t// predicate-object pairs state\n\t\t\t\t\t\t\t\t\t\t\t\treturn this.pairs();\n\n\t\t\t\t\t\t\t\t\t\t\t// prefixed name\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t\t\t// try match\n\t\t\t\t\t\t\t\t\t\t\t\tlet aw_valid_this_match_prefixed_name = this.match_prefixed_name(s, i);\n\t\t\t\t\t\t\t\t\t\t\t\t// stack bail out\n\t\t\t\t\t\t\t\t\t\t\t\tif(!aw_valid_this_match_prefixed_name) return true;\n\t\t\t\t\t\t\t\t\t\t\t\tlet [m_prefixed_named_subject, im_prefixed_named_subject] = aw_valid_this_match_prefixed_name;\n\t\t\t\t\t\t\t\t\t\t\t\tif(m_prefixed_named_subject) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\t\t\t\t\t\t\tthis.i = im_prefixed_named_subject;\n\t\t\t\t\t\t\t\t\t\t\t\t\t// check valid prefix\n\t\t\t\t\t\t\t\t\t\t\t\t\tlet s_prefix_id = m_prefixed_named_subject[1] || '';\n\t\t\t\t\t\t\t\t\t\t\t\t\t// invalid prefix\n\t\t\t\t\t\t\t\t\t\t\t\t\tif(!OPHOP.call(this._h_prefixes, s_prefix_id)) return this.error(`no such prefix \"${s_prefix_id}\"`);\n\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t// escape local escapes\n\t\t\t\t\t\t\t\t\t\t\t\t\tlet s_suffix = m_prefixed_named_subject[2]\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.replace(R_UNICODE_ANY, F_REPLACE_UNICODE_ANY)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t.replace(R_PN_LOCAL_ESCAPES, '$1');\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t// make subject key\n\t\t\t\t\t\t\t\t\t\t\t\t\tthis._kt_subject = this.prefixed_name(s_prefix_id, s_suffix);\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t// predicate-object pairs state\n\t\t\t\t\t\t\t\t\t\t\t\t\treturn this.pairs();\n\n\n\t\t\t\t\t\t\t\t\t\t\t\t// comment\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\t\t\t\t\t\t\t\t\tR_COMMENT.lastIndex = i;\n\t\t\t\t\t\t\t\t\t\t\t\t\t// execute regex\n\t\t\t\t\t\t\t\t\t\t\t\t\tlet m_comment = R_COMMENT.exec(s);\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t// regex was a match\n\t\t\t\t\t\t\t\t\t\t\t\t\tif(m_comment) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\t\t\t\t\t\t\t\ti = R_COMMENT.lastIndex;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(this.emit_comments) this.emit_comments(m_comment[0]);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tcontinue;\n\n\t\t\t// not iriref, not prefixed name, not blank node label, not prefix id, not base\n\t\t\t// match counter: 10\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t// break loop to retry on next chunk if eos\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t} // brace #10\n\t\t\t\t\t\t\t\t\t\t\t} // brace #9\n\t\t\t\t\t\t\t\t\t\t} // brace #8\n\t\t\t\t\t\t\t\t\t} // brace #7\n\t\t\t\t\t\t\t\t} // brace #6\n\t\t\t\t\t\t\t} // brace #5\n\t\t\t\t\t\t} // brace #4\n\t\t\t\t\t} // brace #3\n\t\t\t\t} // brace #2\n\t\t\t} // brace #1\n\t\t}\n\n\t\t\t\t// ran out of characters\n\t\t\t\t// update index value\n\t\tthis.i = i;\n\n\t\t// not yet eos\n\t\tif(i < this.n) {\n\t\t\t// expected token was not found\n\t\t\tif(0 === i) {\n\t\t\t\t// we've exceeded the maximum token length\n\t\t\t\tif(this.n > this.max_token_length) {\n\t\t\t\t\treturn this.parse_error('statement');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// save state before pausing\n\t\tthis._f_state = this.statement;\n\n\t\t// store what is unparsed\n\t\tthis.pre = s.slice(i);\n\n\t\t// if we're not parsing a stream, then this is an error\n\t\tif(this.eos) this.eos();\n\t\treturn;\n\t}\n\n\n\n\t// parse state for block\n\tblock() {\n\t\t// destruct chunk, length, and index\n\t\tlet {s, n, i} = this;\n\n\t\t// start labeled loop, run while there are characters\n\t\twhile(i < n) {  // eslint-disable-line no-unmodified-loop-condition\n\t\t\t// prepare sticky regex index\n\t\t\tR_GRAPH_IRI_ESCAPELESS.lastIndex = i;\n\t\t\t// execute regex\n\t\t\tlet m_graph_iriref_e_graph = R_GRAPH_IRI_ESCAPELESS.exec(s);\n\n\t\t\t// regex was a match\n\t\t\tif(m_graph_iriref_e_graph) {\n\t\t\t\t// advance index\n\t\t\t\tthis.i = R_GRAPH_IRI_ESCAPELESS.lastIndex;\n\n\t\t\t\t// ref iri\n\t\t\t\tlet s_iri = m_graph_iriref_e_graph[1];\n\t\t\t\t// absolute iri\n\t\t\t\tif(!this._s_base_url || RT_IRI_ABSOLUTE.test(s_iri)) {\n\t\t\t\t\t// set graph\n\t\t\t\t\tthis._kt_graph = this.check_named_node_escapeless(s_iri);\n\t\t\t\t}\n\t\t\t\t// relative iri\n\t\t\t\telse {\n\t\t\t\t\tthis._kt_graph = this.check_named_node_escapeless(uri.resolve(this._s_base_url, s_iri));\n\t\t\t\t}\n\n\t\t\t\tthis.emit('enter', this._kt_graph);\n\n\t\t\t\t// statement state\n\t\t\t\treturn this.statement();\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// prepare sticky regex index\n\t\t\t\tR_GRAPH_PREFIXED_NAME.lastIndex = i;\n\t\t\t\t// execute regex\n\t\t\t\tlet m_graph_prefixed_name = R_GRAPH_PREFIXED_NAME.exec(s);\n\n\t\t\t\t// regex was a match\n\t\t\t\tif(m_graph_prefixed_name) {\n\t\t\t\t\t// advance index\n\t\t\t\t\tthis.i = R_GRAPH_PREFIXED_NAME.lastIndex;\n\t\t\t\t\t// check valid prefix\n\t\t\t\t\tlet s_prefix_id = m_graph_prefixed_name[1] || '';\n\t\t\t\t\t// invalid prefix\n\t\t\t\t\tif(!OPHOP.call(this._h_prefixes, s_prefix_id)) return this.error(`no such prefix \"${s_prefix_id}\"`);\n\n\n\t\t\t\t\t// make subject key\n\t\t\t\t\tthis._kt_graph = this.prefixed_name(s_prefix_id, m_graph_prefixed_name[2]);\n\n\t\t\t\t\tthis.emit('enter', this._kt_graph);\n\n\t\t\t\t\t// statement state\n\t\t\t\t\treturn this.statement();\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\tR_CHAR_OPEN.lastIndex = i;\n\n\t\t\t\t\tif(R_CHAR_OPEN.exec(s)) {\n\t\t\t\t\t\t// advance index\n\t\t\t\t\t\tthis.i = R_CHAR_OPEN.lastIndex;\n\t\t\t\t\t\t// make new default graph\n\t\t\t\t\t\tthis._kt_graph = this._dc_factory.defaultGraph();\n\n\t\t\t\t\t\tthis.emit('enter', this._kt_graph);\n\n\t\t\t\t\t\t// goto statement state\n\t\t\t\t\t\treturn this.statement();\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\t\tR_GRAPH_ANONYMOUS_BLANK_NODE.lastIndex = i;\n\t\t\t\t\t\t// execute regex\n\t\t\t\t\t\tlet m_graph_anonymous_blank_node = R_GRAPH_ANONYMOUS_BLANK_NODE.exec(s);\n\n\t\t\t\t\t\t// regex was a match\n\t\t\t\t\t\tif(m_graph_anonymous_blank_node) {\n\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\tthis.i = R_GRAPH_ANONYMOUS_BLANK_NODE.lastIndex;\n\t\t\t\t\t\t\t// make new label & set graph to blank node\n\t\t\t\t\t\t\tthis._kt_graph = this.anonymous_blank_node(this.next_label());\n\n\t\t\t\t\t\t\tthis.emit('enter', this._kt_graph);\n\n\t\t\t\t\t\t\t// statement state\n\t\t\t\t\t\t\treturn this.statement();\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\t\t\tR_GRAPH_LABELED_BLANK_NODE.lastIndex = i;\n\t\t\t\t\t\t\t// execute regex\n\t\t\t\t\t\t\tlet m_graph_labeled_blank_node = R_GRAPH_LABELED_BLANK_NODE.exec(s);\n\n\t\t\t\t\t\t\t// regex was a match\n\t\t\t\t\t\t\tif(m_graph_labeled_blank_node) {\n\t\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\t\tthis.i = R_GRAPH_LABELED_BLANK_NODE.lastIndex;\n\t\t\t\t\t\t\t\tlet s_label = m_graph_labeled_blank_node[1];\n\n\t\t\t\t\t\t\t\tthis._kt_graph = this.blank_node(s_label);\n\n\t\t\t\t\t\t\t\tthis.emit('enter', this._kt_graph);\n\n\t\t\t\t\t\t\t\t// statement state\n\t\t\t\t\t\t\t\treturn this.statement();\n\n\t\t\t\t\t\t\t// iriref\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\t\t\t\tR_IRIREF_ESCAPELESS.lastIndex = i;\n\t\t\t\t\t\t\t\t// execute regex\n\t\t\t\t\t\t\t\tlet m_iriref_e_graph_subject = R_IRIREF_ESCAPELESS.exec(s);\n\n\t\t\t\t\t\t\t\t// regex was a match\n\t\t\t\t\t\t\t\tif(m_iriref_e_graph_subject) {\n\t\t\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\t\t\tthis.i = R_IRIREF_ESCAPELESS.lastIndex;\n\n\t\t\t\t\t\t\t\t\t// ref iri\n\t\t\t\t\t\t\t\t\tlet s_iri = m_iriref_e_graph_subject[1];\n\t\t\t\t\t\t\t\t\t// absolute iri\n\t\t\t\t\t\t\t\t\tif(!this._s_base_url || RT_IRI_ABSOLUTE.test(s_iri)) {\n\t\t\t\t\t\t\t\t\t\t// set subject\n\t\t\t\t\t\t\t\t\t\tthis._kt_subject = this.check_named_node_escapeless(s_iri);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t// relative iri\n\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\tthis._kt_subject = this.check_named_node_escapeless(uri.resolve(this._s_base_url, s_iri));\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t// graph or subject\n\t\t\t\t\t\t\t\t\treturn this.graph_or_subject();\n\n\n\n\t\t\t\t\t\t\t\t// prefixed name\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t// try match\n\t\t\t\t\t\t\t\t\tlet aw_valid_this_match_prefixed_name_escapeless = this.match_prefixed_name_escapeless(s, i);\n\t\t\t\t\t\t\t\t\t// stack bail out\n\t\t\t\t\t\t\t\t\tif(!aw_valid_this_match_prefixed_name_escapeless) return true;\n\t\t\t\t\t\t\t\t\tlet [m_prefixed_named_e_subject, im_prefixed_named_e_subject] = aw_valid_this_match_prefixed_name_escapeless;\n\t\t\t\t\t\t\t\t\tif(m_prefixed_named_e_subject) {\n\t\t\t\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\t\t\t\tthis.i = im_prefixed_named_e_subject;\n\n\t\t\t\t\t\t\t\t\t\t// check valid prefix\n\t\t\t\t\t\t\t\t\t\tlet s_prefix_id = m_prefixed_named_e_subject[1] || '';\n\t\t\t\t\t\t\t\t\t\t// invalid prefix\n\t\t\t\t\t\t\t\t\t\tif(!OPHOP.call(this._h_prefixes, s_prefix_id)) return this.error(`no such prefix \"${s_prefix_id}\"`);\n\n\n\t\t\t\t\t\t\t\t\t\t// make subject key\n\t\t\t\t\t\t\t\t\t\tthis._kt_subject = this.prefixed_name(s_prefix_id, m_prefixed_named_e_subject[2]);\n\n\t\t\t\t\t\t\t\t\t\t// predicate-object pairs state\n\t\t\t\t\t\t\t\t\t\treturn this.graph_or_subject();\n\n\t\t\t\t\t\t\t\t\t// blank node label\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\t\t\t\t\t\tR_BLANK_NODE_LABEL.lastIndex = i;\n\t\t\t\t\t\t\t\t\t\t// execute regex\n\t\t\t\t\t\t\t\t\t\tlet m_blank_node_label_subject = R_BLANK_NODE_LABEL.exec(s);\n\n\t\t\t\t\t\t\t\t\t\t// regex was a match\n\t\t\t\t\t\t\t\t\t\tif(m_blank_node_label_subject) {\n\t\t\t\t\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\t\t\t\t\tthis.i = R_BLANK_NODE_LABEL.lastIndex;\n\t\t\t\t\t\t\t\t\t\t\t// extract label\n\t\t\t\t\t\t\t\t\t\t\tlet s_label = m_blank_node_label_subject[1];\n\n\t\t\t\t\t\t\t\t\t\t\t// make subject key\n\t\t\t\t\t\t\t\t\t\t\tthis._kt_subject = this.blank_node(s_label);\n\n\t\t\t\t\t\t\t\t\t\t\t// predicate-object pairs state\n\t\t\t\t\t\t\t\t\t\t\treturn this.graph_or_subject();\n\n\t\t\t\t\t\t\t\t\t\t// anonymous blank node subject\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\t\t\t\t\t\t\tR_ANONYMOUS_BLANK_NODE.lastIndex = i;\n\n\t\t\t\t\t\t\t\t\t\t\tif(R_ANONYMOUS_BLANK_NODE.exec(s)) {\n\t\t\t\t\t\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\t\t\t\t\t\tthis.i = R_ANONYMOUS_BLANK_NODE.lastIndex;\n\t\t\t\t\t\t\t\t\t\t\t\t// set new blank node as subject\n\t\t\t\t\t\t\t\t\t\t\t\tthis._kt_subject = this.anonymous_blank_node(this.next_label());\n\n\t\t\t\t\t\t\t\t\t\t\t\t// goto pairs state for inside property list\n\t\t\t\t\t\t\t\t\t\t\t\treturn this.graph_or_subject();\n\n\t\t\t\t\t\t\t\t\t\t\t// anonymous blank node property list subject\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\t\t\t\t\t\t\t\tR_CHAR_BLANK_NODE.lastIndex = i;\n\n\t\t\t\t\t\t\t\t\t\t\t\tif(R_CHAR_BLANK_NODE.exec(s)) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\t\t\t\t\t\t\tthis.i = R_CHAR_BLANK_NODE.lastIndex;\n\t\t\t\t\t\t\t\t\t\t\t\t\t// enter blank node\n\t\t\t\t\t\t\t\t\t\t\t\t\tthis._kt_subject = this.anonymous_blank_node(this.next_label());\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t// how to resume when we pop state\n\t\t\t\t\t\t\t\t\t\t\t\t\tthis._a_nested.push([this._kt_subject, this._kt_predicate, 'post_blank_subject']);\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t// goto pairs state for inside property list\n\t\t\t\t\t\t\t\t\t\t\t\t\treturn this.graph_or_subject_property_list();\n\n\t\t\t\t\t\t\t\t\t\t\t\t// rdf collection\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\t\t\t\t\t\t\t\t\tR_CHAR_COLLECTION.lastIndex = i;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\tif(R_CHAR_COLLECTION.exec(s)) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.i = R_CHAR_COLLECTION.lastIndex;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t// indicate that collection subject should emit an initial statement\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis._kt_subject = null;\n\n// (don't push state, we don't have a subject yet)\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t// goto collection-subject state\n\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn this.collection_subject();\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t// prefix with interupt (e.g., a comment)\n\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tR_PREFIX_KEYWORD.lastIndex = i;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t// execute regex\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tlet m_prefix_keyword = R_PREFIX_KEYWORD.exec(s);\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t// regex was a match\n\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(m_prefix_keyword) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.i = R_PREFIX_KEYWORD.lastIndex;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// save whether or not to expect a full stop\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis._b_expecting_full_stop = !!m_prefix_keyword[1];\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// goto prefix state\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn this.prefix_id();\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t// base with interupt (e.g., a comment)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tR_BASE_KEYWORD.lastIndex = i;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// execute regex\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tlet m_base_keyword = R_BASE_KEYWORD.exec(s);\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// regex was a match\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(m_base_keyword) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.i = R_BASE_KEYWORD.lastIndex;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// save whether or not to expect a full stop\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis._b_expecting_full_stop = !!m_base_keyword[1];\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// goto base state\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn this.base_iri();\n\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// iriref\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tR_IRIREF.lastIndex = i;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// execute regex\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tlet m_iriref_subject = R_IRIREF.exec(s);\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// regex was a match\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(m_iriref_subject) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.i = R_IRIREF.lastIndex;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// ref iri\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tlet s_iri = m_iriref_subject[1].replace(R_UNICODE_ANY, F_REPLACE_UNICODE_ANY);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// absolute iri\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(!this._s_base_url || RT_IRI_ABSOLUTE.test(s_iri)) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// set subject\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis._kt_subject = this.check_named_node(s_iri);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// relative iri\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis._kt_subject = this.check_named_node(uri.resolve(this._s_base_url, s_iri));\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// predicate-object pairs state\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn this.graph_or_subject();\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// prefixed name\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// try match\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tlet aw_valid_this_match_prefixed_name = this.match_prefixed_name(s, i);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// stack bail out\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(!aw_valid_this_match_prefixed_name) return true;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tlet [m_prefixed_named_subject, im_prefixed_named_subject] = aw_valid_this_match_prefixed_name;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(m_prefixed_named_subject) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.i = im_prefixed_named_subject;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// check valid prefix\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tlet s_prefix_id = m_prefixed_named_subject[1] || '';\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// invalid prefix\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(!OPHOP.call(this._h_prefixes, s_prefix_id)) return this.error(`no such prefix \"${s_prefix_id}\"`);\n\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// escape local escapes\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tlet s_suffix = m_prefixed_named_subject[2]\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t.replace(R_UNICODE_ANY, F_REPLACE_UNICODE_ANY)\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t.replace(R_PN_LOCAL_ESCAPES, '$1');\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// make subject key\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis._kt_subject = this.prefixed_name(s_prefix_id, s_suffix);\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// predicate-object pairs state\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn this.graph_or_subject();\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tR_GRAPH_IRI.lastIndex = i;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// execute regex\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tlet m_graph_iriref_graph = R_GRAPH_IRI.exec(s);\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// regex was a match\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(m_graph_iriref_graph) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.i = R_GRAPH_IRI.lastIndex;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// ref iri\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tlet s_iri = m_graph_iriref_graph[1].replace(R_UNICODE_ANY, F_REPLACE_UNICODE_ANY);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// absolute iri\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(!this._s_base_url || RT_IRI_ABSOLUTE.test(s_iri)) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// set graph\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis._kt_graph = this.check_named_node(s_iri);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// relative iri\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis._kt_graph = this.check_named_node(uri.resolve(this._s_base_url, s_iri));\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.emit('enter', this._kt_graph);\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// statement state\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn this.statement();\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// comment\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tR_COMMENT.lastIndex = i;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// execute regex\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tlet m_comment = R_COMMENT.exec(s);\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// regex was a match\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(m_comment) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\ti = R_COMMENT.lastIndex;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(this.emit_comments) this.emit_comments(m_comment[0]);\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tR_GRAPH.lastIndex = i;\n\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tif(R_GRAPH.exec(s)) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tthis.i = R_GRAPH.lastIndex;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\treturn this.graph_keyword();\n\n\t\t\t\t// not iriref, not prefixed name, not blank node label, not prefix id, not base\n\t\t\t\t// match counter: 17\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t// break loop to retry on next chunk if eos\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t} // brace #17\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t} // brace #16\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t} // brace #15\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t} // brace #14\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t\t} // brace #13\n\t\t\t\t\t\t\t\t\t\t\t\t\t\t} // brace #12\n\t\t\t\t\t\t\t\t\t\t\t\t\t} // brace #11\n\t\t\t\t\t\t\t\t\t\t\t\t} // brace #10\n\t\t\t\t\t\t\t\t\t\t\t} // brace #9\n\t\t\t\t\t\t\t\t\t\t} // brace #8\n\t\t\t\t\t\t\t\t\t} // brace #7\n\t\t\t\t\t\t\t\t} // brace #6\n\t\t\t\t\t\t\t} // brace #5\n\t\t\t\t\t\t} // brace #4\n\t\t\t\t\t} // brace #3\n\t\t\t\t} // brace #2\n\t\t\t} // brace #1\n\t\t}\n\n\t\t\t\t// ran out of characters\n\t\t\t\t// update index value\n\t\tthis.i = i;\n\n\t\t// not yet eos\n\t\tif(i < this.n) {\n\t\t\t// expected token was not found\n\t\t\tif(0 === i) {\n\t\t\t\t// we've exceeded the maximum token length\n\t\t\t\tif(this.n > this.max_token_length) {\n\t\t\t\t\treturn this.parse_error('block');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// save state before pausing\n\t\tthis._f_state = this.block;\n\n\t\t// store what is unparsed\n\t\tthis.pre = s.slice(i);\n\n\t\t// if we're not parsing a stream, then this is an error\n\t\tif(this.eos) this.eos();\n\t\treturn;\n\t}\n\n\n\n\t// parse state for graph_or_subject\n\tgraph_or_subject() {\n\t\t// destruct chunk, length, and index\n\t\tlet {s, n, i} = this;\n\n\t\t// start labeled loop, run while there are characters\n\t\twhile(i < n) {  // eslint-disable-line no-unmodified-loop-condition\n\t\t\tlet x = s[i];\n\n\t\t\tif('{' === x) {\n\t\t\t\t// consume whitespace (and incidentally reset index)\n\t\t\t\tR_WS.lastIndex = i+1;\n\t\t\t\tR_WS.exec(s);\n\t\t\t\tthis.i = R_WS.lastIndex;\n\n\t\t\t\t// shift placeholder subject\n\t\t\t\tthis._kt_graph = this._kt_subject;\n\n\t\t\t\tthis.emit('enter', this._kt_graph);\n\n\t\t\t\t// reset subject in case of collections\n\t\t\t\tthis._kt_subject = null;\n\n\t\t\t\t// statement state\n\t\t\t\treturn this.statement();\n\n\t\t\t// non-comment\n\t\t\t}\n\t\t\telse if('#' !== x) {\n\t\t\t\treturn this.pairs();\n\n\t\t\t// comment\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// prepare sticky regex index\n\t\t\t\tR_COMMENT.lastIndex = i;\n\t\t\t\t// execute regex\n\t\t\t\tlet m_comment = R_COMMENT.exec(s);\n\n\t\t\t\t// regex was a match\n\t\t\t\tif(m_comment) {\n\t\t\t\t\t// advance index\n\t\t\t\t\ti = R_COMMENT.lastIndex;\n\t\t\t\t\tif(this.emit_comments) this.emit_comments(m_comment[0]);\n\t\t\t\t\tcontinue;\n\n\t\t\t\t// match counter: 1\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// break loop to retry on next chunk if eos\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} // brace #1\n\t\t}\n\n\t\t\t\t// ran out of characters\n\t\t\t\t// update index value\n\t\tthis.i = i;\n\n\t\t// not yet eos\n\t\tif(i < this.n) {\n\t\t\t// expected token was not found\n\t\t\tif(0 === i) {\n\t\t\t\t// we've exceeded the maximum token length\n\t\t\t\tif(this.n > this.max_token_length) {\n\t\t\t\t\treturn this.parse_error('graph_or_subject');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// save state before pausing\n\t\tthis._f_state = this.graph_or_subject;\n\n\t\t// store what is unparsed\n\t\tthis.pre = s.slice(i);\n\n\t\t// if we're not parsing a stream, then this is an error\n\t\tif(this.eos) this.eos();\n\t\treturn;\n\t}\n\n\n\n\t// parse state for graph_or_subject_property_list\n\tgraph_or_subject_property_list() {\n\t\t// destruct chunk, length, and index\n\t\tlet {s, n, i} = this;\n\n\t\t// start labeled loop, run while there are characters\n\t\twhile(i < n) {  // eslint-disable-line no-unmodified-loop-condition\n\t\t\tlet x = s[i];\n\n\t\t\tif(']' === x) {\n\t\t\t\t// consume whitespace (and incidentally reset index)\n\t\t\t\tR_WS.lastIndex = i+1;\n\t\t\t\tR_WS.exec(s);\n\t\t\t\tthis.i = R_WS.lastIndex;\n\n\t\t\t\t// next state\n\t\t\t\treturn this.graph_or_subject_anon();\n\n\t\t\t// non-comment\n\t\t\t}\n\t\t\telse if('#' !== x) {\n\t\t\t\treturn this.pairs();\n\n\t\t\t// comment\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// prepare sticky regex index\n\t\t\t\tR_COMMENT.lastIndex = i;\n\t\t\t\t// execute regex\n\t\t\t\tlet m_comment = R_COMMENT.exec(s);\n\n\t\t\t\t// regex was a match\n\t\t\t\tif(m_comment) {\n\t\t\t\t\t// advance index\n\t\t\t\t\ti = R_COMMENT.lastIndex;\n\t\t\t\t\tif(this.emit_comments) this.emit_comments(m_comment[0]);\n\t\t\t\t\tcontinue;\n\n\t\t\t\t// match counter: 1\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// break loop to retry on next chunk if eos\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} // brace #1\n\t\t}\n\n\t\t\t\t// ran out of characters\n\t\t\t\t// update index value\n\t\tthis.i = i;\n\n\t\t// not yet eos\n\t\tif(i < this.n) {\n\t\t\t// expected token was not found\n\t\t\tif(0 === i) {\n\t\t\t\t// we've exceeded the maximum token length\n\t\t\t\tif(this.n > this.max_token_length) {\n\t\t\t\t\treturn this.parse_error('graph_or_subject_property_list');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// save state before pausing\n\t\tthis._f_state = this.graph_or_subject_property_list;\n\n\t\t// store what is unparsed\n\t\tthis.pre = s.slice(i);\n\n\t\t// if we're not parsing a stream, then this is an error\n\t\tif(this.eos) this.eos();\n\t\treturn;\n\t}\n\n\n\n\t// parse state for graph_or_subject_anon\n\tgraph_or_subject_anon() {\n\t\t// destruct chunk, length, and index\n\t\tlet {s, n, i} = this;\n\n\t\t// start labeled loop, run while there are characters\n\t\twhile(i < n) {  // eslint-disable-line no-unmodified-loop-condition\n\t\t\tlet x = s[i];\n\n\t\t\tif('{' === x) {\n\t\t\t\t// consume whitespace (and incidentally reset index)\n\t\t\t\tR_WS.lastIndex = i+1;\n\t\t\t\tR_WS.exec(s);\n\t\t\t\tthis.i = R_WS.lastIndex;\n\n\t\t\t\t// shift placeholder subject\n\t\t\t\tthis._kt_graph = this._kt_subject;\n\n\t\t\t\tthis.emit('enter', this._kt_graph);\n\n\t\t\t\t// reset subject in case of collections\n\t\t\t\tthis._kt_subject = null;\n\n\t\t\t\t// pop dummy state\n\t\t\t\tthis._a_nested.pop();\n\n\t\t\t\t// statement state\n\t\t\t\treturn this.statement();\n\n\t\t\t// non-comment\n\t\t\t}\n\t\t\telse if('#' !== x) {\n\t\t\t\treturn this.pairs();\n\n\t\t\t// comment\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// prepare sticky regex index\n\t\t\t\tR_COMMENT.lastIndex = i;\n\t\t\t\t// execute regex\n\t\t\t\tlet m_comment = R_COMMENT.exec(s);\n\n\t\t\t\t// regex was a match\n\t\t\t\tif(m_comment) {\n\t\t\t\t\t// advance index\n\t\t\t\t\ti = R_COMMENT.lastIndex;\n\t\t\t\t\tif(this.emit_comments) this.emit_comments(m_comment[0]);\n\t\t\t\t\tcontinue;\n\n\t\t\t\t// match counter: 1\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// break loop to retry on next chunk if eos\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} // brace #1\n\t\t}\n\n\t\t\t\t// ran out of characters\n\t\t\t\t// update index value\n\t\tthis.i = i;\n\n\t\t// not yet eos\n\t\tif(i < this.n) {\n\t\t\t// expected token was not found\n\t\t\tif(0 === i) {\n\t\t\t\t// we've exceeded the maximum token length\n\t\t\t\tif(this.n > this.max_token_length) {\n\t\t\t\t\treturn this.parse_error('graph_or_subject_anon');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// save state before pausing\n\t\tthis._f_state = this.graph_or_subject_anon;\n\n\t\t// store what is unparsed\n\t\tthis.pre = s.slice(i);\n\n\t\t// if we're not parsing a stream, then this is an error\n\t\tif(this.eos) this.eos();\n\t\treturn;\n\t}\n\n\n\n\t// parse state for graph_keyword\n\tgraph_keyword() {\n\t\t// destruct chunk, length, and index\n\t\tlet {s, n, i} = this;\n\n\t\t// start labeled loop, run while there are characters\n\t\twhile(i < n) {  // eslint-disable-line no-unmodified-loop-condition\n\t\t\t// prefixed name\n\t\t\t// try match\n\t\t\tlet aw_valid_this_match_prefixed_name_escapeless = this.match_prefixed_name_escapeless(s, i);\n\t\t\t// stack bail out\n\t\t\tif(!aw_valid_this_match_prefixed_name_escapeless) return true;\n\t\t\tlet [m_prefixed_named_e_graph, im_prefixed_named_e_graph] = aw_valid_this_match_prefixed_name_escapeless;\n\t\t\tif(m_prefixed_named_e_graph) {\n\t\t\t\t// advance index\n\t\t\t\tthis.i = im_prefixed_named_e_graph;\n\n\t\t\t\t// check valid prefix\n\t\t\t\tlet s_prefix_id = m_prefixed_named_e_graph[1] || '';\n\t\t\t\t// invalid prefix\n\t\t\t\tif(!OPHOP.call(this._h_prefixes, s_prefix_id)) return this.error(`no such prefix \"${s_prefix_id}\"`);\n\n\n\t\t\t\t// make subject key\n\t\t\t\tthis._kt_graph = this.prefixed_name(s_prefix_id, m_prefixed_named_e_graph[2]);\n\n\t\t\t\t// predicate-object pairs state\n\t\t\t\treturn this.graph_post_name();\n\n\t\t\t// iriref\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// prepare sticky regex index\n\t\t\t\tR_IRIREF_ESCAPELESS.lastIndex = i;\n\t\t\t\t// execute regex\n\t\t\t\tlet m_iriref_e_graph = R_IRIREF_ESCAPELESS.exec(s);\n\n\t\t\t\t// regex was a match\n\t\t\t\tif(m_iriref_e_graph) {\n\t\t\t\t\t// advance index\n\t\t\t\t\tthis.i = R_IRIREF_ESCAPELESS.lastIndex;\n\n\t\t\t\t\t// ref iri\n\t\t\t\t\tlet s_iri = m_iriref_e_graph[1];\n\t\t\t\t\t// absolute iri\n\t\t\t\t\tif(!this._s_base_url || RT_IRI_ABSOLUTE.test(s_iri)) {\n\t\t\t\t\t\t// set graph\n\t\t\t\t\t\tthis._kt_graph = this.check_named_node_escapeless(s_iri);\n\t\t\t\t\t}\n\t\t\t\t\t// relative iri\n\t\t\t\t\telse {\n\t\t\t\t\t\tthis._kt_graph = this.check_named_node_escapeless(uri.resolve(this._s_base_url, s_iri));\n\t\t\t\t\t}\n\n\t\t\t\t\t// graph\n\t\t\t\t\treturn this.graph_post_name();\n\n\t\t\t\t// blank node label\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\tR_BLANK_NODE_LABEL.lastIndex = i;\n\t\t\t\t\t// execute regex\n\t\t\t\t\tlet m_blank_node_label_graph = R_BLANK_NODE_LABEL.exec(s);\n\n\t\t\t\t\t// regex was a match\n\t\t\t\t\tif(m_blank_node_label_graph) {\n\t\t\t\t\t\t// advance index\n\t\t\t\t\t\tthis.i = R_BLANK_NODE_LABEL.lastIndex;\n\t\t\t\t\t\t// extract label\n\t\t\t\t\t\tlet s_label = m_blank_node_label_graph[1];\n\n\t\t\t\t\t\t// make graph key\n\t\t\t\t\t\tthis._kt_graph = this.blank_node(s_label);\n\n\t\t\t\t\t\t// predicate-object pairs state\n\t\t\t\t\t\treturn this.graph_post_name();\n\n\t\t\t\t\t// anonymous blank node graph\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\t\tR_ANONYMOUS_BLANK_NODE.lastIndex = i;\n\n\t\t\t\t\t\tif(R_ANONYMOUS_BLANK_NODE.exec(s)) {\n\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\tthis.i = R_ANONYMOUS_BLANK_NODE.lastIndex;\n\t\t\t\t\t\t\t// set new blank node as graph\n\t\t\t\t\t\t\tthis._kt_graph = this.anonymous_blank_node(this.next_label());\n\n\t\t\t\t\t\t\t// goto pairs state for inside property list\n\t\t\t\t\t\t\treturn this.graph_post_name();\n\n\t\t\t\t\t\t// iriref\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\t\t\tR_IRIREF.lastIndex = i;\n\t\t\t\t\t\t\t// execute regex\n\t\t\t\t\t\t\tlet m_iriref_graph = R_IRIREF.exec(s);\n\n\t\t\t\t\t\t\t// regex was a match\n\t\t\t\t\t\t\tif(m_iriref_graph) {\n\t\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\t\tthis.i = R_IRIREF.lastIndex;\n\n\t\t\t\t\t\t\t\t// ref iri\n\t\t\t\t\t\t\t\tlet s_iri = m_iriref_graph[1].replace(R_UNICODE_ANY, F_REPLACE_UNICODE_ANY);\n\t\t\t\t\t\t\t\t// absolute iri\n\t\t\t\t\t\t\t\tif(!this._s_base_url || RT_IRI_ABSOLUTE.test(s_iri)) {\n\t\t\t\t\t\t\t\t\t// set graph\n\t\t\t\t\t\t\t\t\tthis._kt_graph = this.check_named_node(s_iri);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// relative iri\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tthis._kt_graph = this.check_named_node(uri.resolve(this._s_base_url, s_iri));\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// predicate-object pairs state\n\t\t\t\t\t\t\t\treturn this.graph_post_name();\n\n\t\t\t\t\t\t\t// prefixed name\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t// try match\n\t\t\t\t\t\t\t\tlet aw_valid_this_match_prefixed_name = this.match_prefixed_name(s, i);\n\t\t\t\t\t\t\t\t// stack bail out\n\t\t\t\t\t\t\t\tif(!aw_valid_this_match_prefixed_name) return true;\n\t\t\t\t\t\t\t\tlet [m_prefixed_named_graph, im_prefixed_named_graph] = aw_valid_this_match_prefixed_name;\n\t\t\t\t\t\t\t\tif(m_prefixed_named_graph) {\n\t\t\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\t\t\tthis.i = im_prefixed_named_graph;\n\t\t\t\t\t\t\t\t\t// check valid prefix\n\t\t\t\t\t\t\t\t\tlet s_prefix_id = m_prefixed_named_graph[1] || '';\n\t\t\t\t\t\t\t\t\t// invalid prefix\n\t\t\t\t\t\t\t\t\tif(!OPHOP.call(this._h_prefixes, s_prefix_id)) return this.error(`no such prefix \"${s_prefix_id}\"`);\n\n\n\t\t\t\t\t\t\t\t\t// escape local escapes\n\t\t\t\t\t\t\t\t\tlet s_suffix = m_prefixed_named_graph[2]\n\t\t\t\t\t\t\t\t\t\t.replace(R_UNICODE_ANY, F_REPLACE_UNICODE_ANY)\n\t\t\t\t\t\t\t\t\t\t.replace(R_PN_LOCAL_ESCAPES, '$1');\n\n\t\t\t\t\t\t\t\t\t// make subject key\n\t\t\t\t\t\t\t\t\tthis._kt_graph = this.prefixed_name(s_prefix_id, s_suffix);\n\n\t\t\t\t\t\t\t\t\t// predicate-object pairs state\n\t\t\t\t\t\t\t\t\treturn this.graph_post_name();\n\n\t\t\t\t\t\t\t\t// comment\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\t\t\t\t\tR_COMMENT.lastIndex = i;\n\t\t\t\t\t\t\t\t\t// execute regex\n\t\t\t\t\t\t\t\t\tlet m_comment = R_COMMENT.exec(s);\n\n\t\t\t\t\t\t\t\t\t// regex was a match\n\t\t\t\t\t\t\t\t\tif(m_comment) {\n\t\t\t\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\t\t\t\ti = R_COMMENT.lastIndex;\n\t\t\t\t\t\t\t\t\t\tif(this.emit_comments) this.emit_comments(m_comment[0]);\n\t\t\t\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t// not iriref, not prefixed name, not blank node label, not prefix id, not base\n\t\t\t\t// match counter: 6\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t// break loop to retry on next chunk if eos\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} // brace #6\n\t\t\t\t\t\t\t} // brace #5\n\t\t\t\t\t\t} // brace #4\n\t\t\t\t\t} // brace #3\n\t\t\t\t} // brace #2\n\t\t\t} // brace #1\n\t\t}\n\n\t\t\t\t// ran out of characters\n\t\t\t\t// update index value\n\t\tthis.i = i;\n\n\t\t// not yet eos\n\t\tif(i < this.n) {\n\t\t\t// expected token was not found\n\t\t\tif(0 === i) {\n\t\t\t\t// we've exceeded the maximum token length\n\t\t\t\tif(this.n > this.max_token_length) {\n\t\t\t\t\treturn this.parse_error('graph_keyword');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// save state before pausing\n\t\tthis._f_state = this.graph_keyword;\n\n\t\t// store what is unparsed\n\t\tthis.pre = s.slice(i);\n\n\t\t// if we're not parsing a stream, then this is an error\n\t\tif(this.eos) this.eos();\n\t\treturn;\n\t}\n\n\n\n\t// parse state for graph_post_name\n\tgraph_post_name() {\n\t\t// destruct chunk, length, and index\n\t\tlet {s, n, i} = this;\n\n\t\t// start labeled loop, run while there are characters\n\t\twhile(i < n) {  // eslint-disable-line no-unmodified-loop-condition\n\t\t\tlet x = s[i];\n\n\t\t\tif('{' === x) {\n\t\t\t\t// consume whitespace (and incidentally reset index)\n\t\t\t\tR_WS.lastIndex = i+1;\n\t\t\t\tR_WS.exec(s);\n\t\t\t\tthis.i = R_WS.lastIndex;\n\n\t\t\t\tthis.emit('enter', this._kt_graph);\n\n\t\t\t\t// statement state\n\t\t\t\treturn this.statement();\n\n\t\t\t// comment\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// prepare sticky regex index\n\t\t\t\tR_COMMENT.lastIndex = i;\n\t\t\t\t// execute regex\n\t\t\t\tlet m_comment = R_COMMENT.exec(s);\n\n\t\t\t\t// regex was a match\n\t\t\t\tif(m_comment) {\n\t\t\t\t\t// advance index\n\t\t\t\t\ti = R_COMMENT.lastIndex;\n\t\t\t\t\tif(this.emit_comments) this.emit_comments(m_comment[0]);\n\t\t\t\t\tcontinue;\n\n\t\t\t\t// match counter: 1\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// break loop to retry on next chunk if eos\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} // brace #1\n\t\t}\n\n\t\t\t\t// ran out of characters\n\t\t\t\t// update index value\n\t\tthis.i = i;\n\n\t\t// not yet eos\n\t\tif(i < this.n) {\n\t\t\t// expected token was not found\n\t\t\tif(0 === i) {\n\t\t\t\t// we've exceeded the maximum token length\n\t\t\t\tif(this.n > this.max_token_length) {\n\t\t\t\t\treturn this.parse_error('graph_post_name');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// save state before pausing\n\t\tthis._f_state = this.graph_post_name;\n\n\t\t// store what is unparsed\n\t\tthis.pre = s.slice(i);\n\n\t\t// if we're not parsing a stream, then this is an error\n\t\tif(this.eos) this.eos();\n\t\treturn;\n\t}\n\n\n\n\t// parse state for pairs\n\tpairs() {\n\t\t// destruct chunk, length, and index\n\t\tlet {s, n, i} = this;\n\n\t\t// start labeled loop, run while there are characters\n\t\twhile(i < n) {  // eslint-disable-line no-unmodified-loop-condition\n// benchmarks indicate: regex for end of blank node property list faster than ch\n\n\n// iriref\n\n\t\t\t// prepare sticky regex index\n\t\t\tR_IRIREF_ESCAPELESS.lastIndex = i;\n\t\t\t// execute regex\n\t\t\tlet m_iriref_e_predicate = R_IRIREF_ESCAPELESS.exec(s);\n\n\t\t\t// regex was a match\n\t\t\tif(m_iriref_e_predicate) {\n\t\t\t\t// advance index\n\t\t\t\tthis.i = R_IRIREF_ESCAPELESS.lastIndex;\n\n\t\t\t\t// ref iri\n\t\t\t\tlet s_iri = m_iriref_e_predicate[1];\n\t\t\t\t// absolute iri\n\t\t\t\tif(!this._s_base_url || RT_IRI_ABSOLUTE.test(s_iri)) {\n\t\t\t\t\t// set predicate\n\t\t\t\t\tthis._kt_predicate = this.check_named_node_escapeless(s_iri);\n\t\t\t\t}\n\t\t\t\t// relative iri\n\t\t\t\telse {\n\t\t\t\t\tthis._kt_predicate = this.check_named_node_escapeless(uri.resolve(this._s_base_url, s_iri));\n\t\t\t\t}\n\n\t\t\t\t// object-list state\n\t\t\t\treturn this.object_list();\n\n\t\t\t// prefixed name\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// try match\n\t\t\t\tlet aw_valid_this_match_prefixed_name_escapeless = this.match_prefixed_name_escapeless(s, i);\n\t\t\t\t// stack bail out\n\t\t\t\tif(!aw_valid_this_match_prefixed_name_escapeless) return true;\n\t\t\t\tlet [m_prefixed_named_e_predicate, im_prefixed_named_e_predicate] = aw_valid_this_match_prefixed_name_escapeless;\n\t\t\t\tif(m_prefixed_named_e_predicate) {\n\t\t\t\t\t// advance index\n\t\t\t\t\tthis.i = im_prefixed_named_e_predicate;\n\t\t\t\t\t// check valid prefix\n\t\t\t\t\tlet s_prefix_id = m_prefixed_named_e_predicate[1] || '';\n\t\t\t\t\t// invalid prefix\n\t\t\t\t\tif(!OPHOP.call(this._h_prefixes, s_prefix_id)) return this.error(`no such prefix \"${s_prefix_id}\"`);\n\n\n\t\t\t\t\t// make predicate key\n\t\t\t\t\tthis._kt_predicate = this.prefixed_name(s_prefix_id, m_prefixed_named_e_predicate[2]);\n\n\t\t\t\t\t// object-list state\n\t\t\t\t\treturn this.object_list();\n\n\t\t\t\t// 'a'\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\tR_A.lastIndex = i;\n\n\t\t\t\t\tif(R_A.exec(s)) {\n\t\t\t\t\t\t// advance index\n\t\t\t\t\t\tthis.i = R_A.lastIndex;\n\t\t\t\t\t\t// make predicate key\n\t\t\t\t\t\tthis._kt_predicate = this._kt_rdf_type;\n\n\t\t\t\t\t\t// object-list state\n\t\t\t\t\t\treturn this.object_list();\n\n\t\t\t\t\t// ']' end of blank node property list\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\t\tR_CHAR_KET.lastIndex = i;\n\n\t\t\t\t\t\tif(R_CHAR_KET.exec(s)) {\n\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\tthis.i = R_CHAR_KET.lastIndex;\n\t\t\t\t\t\t\tlet s_resume_state;\n\t\t\t\t\t\t\t[this._kt_subject, this._kt_predicate, s_resume_state] = this._a_nested.pop();\n\t\t\t\t\t\t\treturn this[s_resume_state]();\n\n\t\t\t\t\t\t// iriref\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\t\t\tR_IRIREF.lastIndex = i;\n\t\t\t\t\t\t\t// execute regex\n\t\t\t\t\t\t\tlet m_iriref_predicate = R_IRIREF.exec(s);\n\n\t\t\t\t\t\t\t// regex was a match\n\t\t\t\t\t\t\tif(m_iriref_predicate) {\n\t\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\t\tthis.i = R_IRIREF.lastIndex;\n\n\t\t\t\t\t\t\t\t// ref iri\n\t\t\t\t\t\t\t\tlet s_iri = m_iriref_predicate[1].replace(R_UNICODE_ANY, F_REPLACE_UNICODE_ANY);\n\t\t\t\t\t\t\t\t// absolute iri\n\t\t\t\t\t\t\t\tif(!this._s_base_url || RT_IRI_ABSOLUTE.test(s_iri)) {\n\t\t\t\t\t\t\t\t\t// set predicate\n\t\t\t\t\t\t\t\t\tthis._kt_predicate = this.check_named_node(s_iri);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// relative iri\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tthis._kt_predicate = this.check_named_node(uri.resolve(this._s_base_url, s_iri));\n\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// object-list state\n\t\t\t\t\t\t\t\treturn this.object_list();\n\n\t\t\t\t\t\t\t// prefixed name\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t// try match\n\t\t\t\t\t\t\t\tlet aw_valid_this_match_prefixed_name = this.match_prefixed_name(s, i);\n\t\t\t\t\t\t\t\t// stack bail out\n\t\t\t\t\t\t\t\tif(!aw_valid_this_match_prefixed_name) return true;\n\t\t\t\t\t\t\t\tlet [m_prefixed_named_predicate, im_prefixed_named_predicate] = aw_valid_this_match_prefixed_name;\n\t\t\t\t\t\t\t\tif(m_prefixed_named_predicate) {\n\t\t\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\t\t\tthis.i = im_prefixed_named_predicate;\n\t\t\t\t\t\t\t\t\t// check valid prefix\n\t\t\t\t\t\t\t\t\tlet s_prefix_id = m_prefixed_named_predicate[1] || '';\n\t\t\t\t\t\t\t\t\t// invalid prefix\n\t\t\t\t\t\t\t\t\tif(!OPHOP.call(this._h_prefixes, s_prefix_id)) return this.error(`no such prefix \"${s_prefix_id}\"`);\n\n\n\t\t\t\t\t\t\t\t\t// escape local escapes\n\t\t\t\t\t\t\t\t\tlet s_suffix = m_prefixed_named_predicate[2]\n\t\t\t\t\t\t\t\t\t\t.replace(R_UNICODE_ANY, F_REPLACE_UNICODE_ANY)\n\t\t\t\t\t\t\t\t\t\t.replace(R_PN_LOCAL_ESCAPES, '$1');\n\n\t\t\t\t\t\t\t\t\t// make predicate key\n\t\t\t\t\t\t\t\t\tthis._kt_predicate = this.prefixed_name(s_prefix_id, s_suffix);\n\n\t\t\t\t\t\t\t\t\t// object-list state\n\t\t\t\t\t\t\t\t\treturn this.object_list();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\t\t\t\t\tR_COMMENT.lastIndex = i;\n\t\t\t\t\t\t\t\t\t// execute regex\n\t\t\t\t\t\t\t\t\tlet m_comment = R_COMMENT.exec(s);\n\n\t\t\t\t\t\t\t\t\t// regex was a match\n\t\t\t\t\t\t\t\t\tif(m_comment) {\n\t\t\t\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\t\t\t\ti = R_COMMENT.lastIndex;\n\t\t\t\t\t\t\t\t\t\tif(this.emit_comments) this.emit_comments(m_comment[0]);\n\t\t\t\t\t\t\t\t\t\tcontinue;\n\n\t\t\t// not iriref, not prefixed name, not 'a'\n\t\t\t// match counter: 6\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t// break loop to retry on next chunk if eos\n\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t} // brace #6\n\t\t\t\t\t\t\t} // brace #5\n\t\t\t\t\t\t} // brace #4\n\t\t\t\t\t} // brace #3\n\t\t\t\t} // brace #2\n\t\t\t} // brace #1\n\t\t}\n\n\t\t\t\t// ran out of characters\n\t\t\t\t// update index value\n\t\tthis.i = i;\n\n\t\t// not yet eos\n\t\tif(i < this.n) {\n\t\t\t// expected token was not found\n\t\t\tif(0 === i) {\n\t\t\t\t// we've exceeded the maximum token length\n\t\t\t\tif(this.n > this.max_token_length) {\n\t\t\t\t\treturn this.parse_error('pairs');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// save state before pausing\n\t\tthis._f_state = this.pairs;\n\n\t\t// store what is unparsed\n\t\tthis.pre = s.slice(i);\n\n\t\t// if we're not parsing a stream, then this is an error\n\t\tif(this.eos) this.eos();\n\t\treturn;\n\t}\n\n\n\n\t// parse state for object_list\n\tobject_list() {\n\t\t// destruct chunk, length, and index\n\t\tlet {s, n, i} = this;\n\n\t\t// start labeled loop, run while there are characters\n\t\twhile(i < n) {  // eslint-disable-line no-unmodified-loop-condition\n\t\t\t// ref char\n\t\t\tlet x = s[i];\n\n\t\t\t// string literal * double\n\t\t\tif('\"' === x) {\n\t\t\t\t// enough chars to deduce type\n\t\t\t\tif((i+2) < n) {\n\t\t\t\t\t// long type\n\t\t\t\t\tif('\"' === s[i+1] && '\"' === s[i+2]) {\n\t\t\t\t\t\t// advance index beyond token\n\t\t\t\t\t\tthis.i = i + 3;\n\n\t\t\t\t\t\t// read contents\n\t\t\t\t\t\treturn this.string_literal_long_double();\n\t\t\t\t\t}\n\t\t\t\t\t// not long type\n\t\t\t\t\telse {\n\t\t\t\t\t\t// advance index beyond token\n\t\t\t\t\t\tthis.i = i + 1;\n\n\t\t\t\t\t\t// read contents\n\t\t\t\t\t\treturn this.string_literal_short_double();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// enough chars to eliminate long type\n\t\t\t\telse if((i+1) < n && '\"' !== s[i+1]) {\n\t\t\t\t\t// advance index beyond token\n\t\t\t\t\tthis.i = i + 1;\n\n\t\t\t\t\t// read contents\n\t\t\t\t\treturn this.string_literal_short_double();\n\t\t\t\t}\n\t\t\t\t// not enough chars to deduce type; retry next chunk\n\t\t\t\telse {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t// prefixed name quick\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// prepare sticky regex index\n\t\t\t\tR_PREFIXED_NAME_QUICK.lastIndex = i;\n\t\t\t\t// execute regex\n\t\t\t\tlet m_pnq_object = R_PREFIXED_NAME_QUICK.exec(s);\n\n\t\t\t\t// regex was a match\n\t\t\t\tif(m_pnq_object) {\n\t\t\t\t\t// advance index\n\t\t\t\t\tthis.i = R_PREFIXED_NAME_QUICK.lastIndex;\n\t\t\t\t\t// check valid prefix\n\t\t\t\t\tlet s_prefix_id = m_pnq_object[1] || '';\n\t\t\t\t\t// invalid prefix\n\t\t\t\t\tif(!OPHOP.call(this._h_prefixes, s_prefix_id)) return this.error(`no such prefix \"${s_prefix_id}\"`);\n\n\n\t\t\t\t\t// commit object iri from resolve prefixed name\n\t\t\t\t\tthis._kt_object = this.prefixed_name(s_prefix_id, m_pnq_object[2]);\n\n\t\t\t\t// iriref\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\tR_IRIREF_ESCAPELESS.lastIndex = i;\n\t\t\t\t\t// execute regex\n\t\t\t\t\tlet m_iriref_e_object = R_IRIREF_ESCAPELESS.exec(s);\n\n\t\t\t\t\t// regex was a match\n\t\t\t\t\tif(m_iriref_e_object) {\n\t\t\t\t\t\t// advance index\n\t\t\t\t\t\tthis.i = R_IRIREF_ESCAPELESS.lastIndex;\n\n\t\t\t\t\t\t// ref iri\n\t\t\t\t\t\tlet s_iri = m_iriref_e_object[1];\n\t\t\t\t\t\t// absolute iri\n\t\t\t\t\t\tif(!this._s_base_url || RT_IRI_ABSOLUTE.test(s_iri)) {\n\t\t\t\t\t\t\t// set object\n\t\t\t\t\t\t\tthis._kt_object = this.check_named_node_escapeless(s_iri);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// relative iri\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tthis._kt_object = this.check_named_node_escapeless(uri.resolve(this._s_base_url, s_iri));\n\t\t\t\t\t\t}\n\n\t\t\t\t\t// prefixed name\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// try match\n\t\t\t\t\t\tlet aw_valid_this_match_prefixed_name_escapeless = this.match_prefixed_name_escapeless(s, i);\n\t\t\t\t\t\t// stack bail out\n\t\t\t\t\t\tif(!aw_valid_this_match_prefixed_name_escapeless) return true;\n\t\t\t\t\t\tlet [m_prefixed_named_e_object, im_prefixed_named_e_object] = aw_valid_this_match_prefixed_name_escapeless;\n\t\t\t\t\t\tif(m_prefixed_named_e_object) {\n\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\tthis.i = im_prefixed_named_e_object;\n\t\t\t\t\t\t\t// check valid prefix\n\t\t\t\t\t\t\tlet s_prefix_id = m_prefixed_named_e_object[1] || '';\n\t\t\t\t\t\t\t// invalid prefix\n\t\t\t\t\t\t\tif(!OPHOP.call(this._h_prefixes, s_prefix_id)) return this.error(`no such prefix \"${s_prefix_id}\"`);\n\n\n\t\t\t\t\t\t\t// commit object iri from resolve prefixed name\n\t\t\t\t\t\t\tthis._kt_object = this.prefixed_name(s_prefix_id, m_prefixed_named_e_object[2]);\n\n\t\t\t\t\t\t// string literal * single\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse \tif('\\'' === x) {\n\t\t\t\t\t\t\t// enough chars to deduce type\n\t\t\t\t\t\t\tif((i+2) < n) {\n\t\t\t\t\t\t\t\t// long type\n\t\t\t\t\t\t\t\tif(\"'\" === s[i+1] && \"'\" === s[i+2]) {\n\t\t\t\t\t\t\t\t\t// advance index beyond token\n\t\t\t\t\t\t\t\t\tthis.i = i + 3;\n\n\t\t\t\t\t\t\t\t\t// read contents\n\t\t\t\t\t\t\t\t\treturn this.string_literal_long_single();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// not long type\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t// advance index beyond token\n\t\t\t\t\t\t\t\t\tthis.i = i + 1;\n\n\t\t\t\t\t\t\t\t\t// read contents\n\t\t\t\t\t\t\t\t\treturn this.string_literal_short_single();\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// enough chars to eliminate long type\n\t\t\t\t\t\t\telse if((i+1) < n && \"'\" !== s[i+1]) {\n\t\t\t\t\t\t\t\t// advance index beyond token\n\t\t\t\t\t\t\t\tthis.i = i + 1;\n\n\t\t\t\t\t\t\t\t// read contents\n\t\t\t\t\t\t\t\treturn this.string_literal_short_single();\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// not enough chars to deduce type; retry next chunk\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// numeric literal\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\t\t\tR_NUMERIC_LITERAL.lastIndex = i;\n\t\t\t\t\t\t\t// execute regex\n\t\t\t\t\t\t\tlet m_numeric_literal = R_NUMERIC_LITERAL.exec(s);\n\n\t\t\t\t\t\t\t// regex was a match\n\t\t\t\t\t\t\tif(m_numeric_literal) {\n\t\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\t\tthis.i = R_NUMERIC_LITERAL.lastIndex;\n\t\t\t\t\t\t\t\t// it has exponent term, xsd:double\n\t\t\t\t\t\t\t\tif(m_numeric_literal[4]) {\n\t\t\t\t\t\t\t\t\tthis._kt_object = this._dc_factory.double(m_numeric_literal[1]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// contains decimal point, xsd:decimal\n\t\t\t\t\t\t\t\telse if(m_numeric_literal[2] || m_numeric_literal[3]) {\n\t\t\t\t\t\t\t\t\tthis._kt_object = this._dc_factory.decimal(m_numeric_literal[1]);\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t// otherwise, it is an integer\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\tthis._kt_object = this._dc_factory.integer(m_numeric_literal[1]);\n\t\t\t\t\t\t\t\t}\n\n\n\t\t\t\t\t\t\t// boolean literal\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\t\t\t\tR_BOOLEAN_LITERAL.lastIndex = i;\n\t\t\t\t\t\t\t\t// execute regex\n\t\t\t\t\t\t\t\tlet m_boolean_literal = R_BOOLEAN_LITERAL.exec(s);\n\n\t\t\t\t\t\t\t\t// regex was a match\n\t\t\t\t\t\t\t\tif(m_boolean_literal) {\n\t\t\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\t\t\tthis.i = R_BOOLEAN_LITERAL.lastIndex;\n\t\t\t\t\t\t\t\t\t// make literal\n\t\t\t\t\t\t\t\t\tthis._kt_object = this._dc_factory.boolean(!!m_boolean_literal[1]);\n\n\n\t\t\t\t\t\t\t\t// blank node property list\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse \tif('[' === x) {\n\t\t\t\t// advance index to next token\n\t\t\t\t// consume whitespace (and incidentally reset index)\n\t\t\t\t\t\t\t\t\tR_WS.lastIndex = i+1;\n\t\t\t\t\t\t\t\t\tR_WS.exec(s);\n\t\t\t\t\t\t\t\t\tthis.i = R_WS.lastIndex;\n\n\t\t\t\t\t\t\t\t\t// make object\n\t\t\t\t\t\t\t\t\tlet kt_blank_node = this._kt_object = this.anonymous_blank_node(this.next_label());\n\n\t\t\t\t\t\t\t\t\t// emit statement event\n\t\t\t\t\t\t\t\t\tthis.data();\n\n\n\t\t\t\t\t\t\t\t\t// push state to stack\n\t\t\t\t\t\t\t\t\tthis._a_nested.push([this._kt_subject, this._kt_predicate, 'post_object']);\n\n\t\t\t\t\t\t\t\t\t// set new subject\n\t\t\t\t\t\t\t\t\tthis._kt_subject = kt_blank_node;\n\n\t\t\t\t\t\t\t\t\t// goto parsing pairs state\n\t\t\t\t\t\t\t\t\treturn this.pairs();\n\n\t\t\t\t\t\t\t\t// labeled blank node\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\t\t\t\t\tR_BLANK_NODE_LABEL_TERMINAL.lastIndex = i;\n\t\t\t\t\t\t\t\t\t// execute regex\n\t\t\t\t\t\t\t\t\tlet m_blank_node_label_object = R_BLANK_NODE_LABEL_TERMINAL.exec(s);\n\n\t\t\t\t\t\t\t\t\t// regex was a match\n\t\t\t\t\t\t\t\t\tif(m_blank_node_label_object) {\n\t\t\t\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\t\t\t\tthis.i = R_BLANK_NODE_LABEL_TERMINAL.lastIndex;\n\t\t\t\t\t\t\t\t\t\t// ref blank node label\n\t\t\t\t\t\t\t\t\t\tlet s_label = m_blank_node_label_object[1];\n\n\t\t\t\t\t\t\t\t\t\t// make object\n\t\t\t\t\t\t\t\t\t\tthis._kt_object = this.blank_node(s_label);\n\n\t\t\t\t\t\t\t\t\t// collection\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse \tif('(' === x) {\n\t\t\t\t// advance index to next token\n\t\t\t\t// consume whitespace (and incidentally reset index)\n\t\t\t\t\t\t\t\t\t\tR_WS.lastIndex = i+1;\n\t\t\t\t\t\t\t\t\t\tR_WS.exec(s);\n\t\t\t\t\t\t\t\t\t\tthis.i = R_WS.lastIndex;\n\n\t\t\t\t\t\t\t\t\t\t// state to resume after collection ends\n\t\t\t\t\t\t\t\t\t\tthis._a_nested.push([this._kt_subject, this._kt_predicate, 'post_object']);\n\n\t\t\t\t\t\t\t\t\t\t// goto collection-object state\n\t\t\t\t\t\t\t\t\t\treturn this.collection_object();\n\n\t\t\t\t\t\t\t\t\t// iriref\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\t\t\t\t\t\tR_IRIREF.lastIndex = i;\n\t\t\t\t\t\t\t\t\t\t// execute regex\n\t\t\t\t\t\t\t\t\t\tlet m_iriref_object = R_IRIREF.exec(s);\n\n\t\t\t\t\t\t\t\t\t\t// regex was a match\n\t\t\t\t\t\t\t\t\t\tif(m_iriref_object) {\n\t\t\t\t\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\t\t\t\t\tthis.i = R_IRIREF.lastIndex;\n\n\t\t\t\t\t\t\t\t\t\t\t// ref iri\n\t\t\t\t\t\t\t\t\t\t\tlet s_iri = m_iriref_object[1].replace(R_UNICODE_ANY, F_REPLACE_UNICODE_ANY);\n\t\t\t\t\t\t\t\t\t\t\t// absolute iri\n\t\t\t\t\t\t\t\t\t\t\tif(!this._s_base_url || RT_IRI_ABSOLUTE.test(s_iri)) {\n\t\t\t\t\t\t\t\t\t\t\t\t// set object\n\t\t\t\t\t\t\t\t\t\t\t\tthis._kt_object = this.check_named_node(s_iri);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t// relative iri\n\t\t\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t\t\tthis._kt_object = this.check_named_node(uri.resolve(this._s_base_url, s_iri));\n\t\t\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t\t\t// prefixed name\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t\t// try match\n\t\t\t\t\t\t\t\t\t\t\tlet aw_valid_this_match_prefixed_name = this.match_prefixed_name(s, i);\n\t\t\t\t\t\t\t\t\t\t\t// stack bail out\n\t\t\t\t\t\t\t\t\t\t\tif(!aw_valid_this_match_prefixed_name) return true;\n\t\t\t\t\t\t\t\t\t\t\tlet [m_prefixed_named_object, im_prefixed_named_object] = aw_valid_this_match_prefixed_name;\n\t\t\t\t\t\t\t\t\t\t\tif(m_prefixed_named_object) {\n\t\t\t\t\t\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\t\t\t\t\t\tthis.i = im_prefixed_named_object;\n\t\t\t\t\t\t\t\t\t\t\t\t// check valid prefix\n\t\t\t\t\t\t\t\t\t\t\t\tlet s_prefix_id = m_prefixed_named_object[1] || '';\n\t\t\t\t\t\t\t\t\t\t\t\t// invalid prefix\n\t\t\t\t\t\t\t\t\t\t\t\tif(!OPHOP.call(this._h_prefixes, s_prefix_id)) return this.error(`no such prefix \"${s_prefix_id}\"`);\n\n\n\t\t\t\t\t\t\t\t\t\t\t\t// escape local escapes\n\t\t\t\t\t\t\t\t\t\t\t\tlet s_suffix = m_prefixed_named_object[2]\n\t\t\t\t\t\t\t\t\t\t\t\t\t.replace(R_UNICODE_ANY, F_REPLACE_UNICODE_ANY)\n\t\t\t\t\t\t\t\t\t\t\t\t\t.replace(R_PN_LOCAL_ESCAPES, '$1');\n\n\t\t\t\t\t\t\t\t\t\t\t\t// commit object iri from resolve prefixed name\n\t\t\t\t\t\t\t\t\t\t\t\tthis._kt_object = this.prefixed_name(s_prefix_id, s_suffix);\n\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\t\t\t\t\t\t\t\tR_COMMENT.lastIndex = i;\n\t\t\t\t\t\t\t\t\t\t\t\t// execute regex\n\t\t\t\t\t\t\t\t\t\t\t\tlet m_comment = R_COMMENT.exec(s);\n\n\t\t\t\t\t\t\t\t\t\t\t\t// regex was a match\n\t\t\t\t\t\t\t\t\t\t\t\tif(m_comment) {\n\t\t\t\t\t\t\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\t\t\t\t\t\t\ti = R_COMMENT.lastIndex;\n\t\t\t\t\t\t\t\t\t\t\t\t\tif(this.emit_comments) this.emit_comments(m_comment[0]);\n\t\t\t\t\t\t\t\t\t\t\t\t\tcontinue;\n\n\t\t\t// not iriref, not prefixed name, not string literal, not numeric literal, not boolean literal, not blank node property list, not collection\n\t\t\t// match counter: 9\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t\t\t\t// break loop to retry on next chunk if eos\n\t\t\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\t\t} // brace #9\n\t\t\t\t\t\t\t\t\t\t} // brace #8\n\t\t\t\t\t\t\t\t\t} // brace #7\n\t\t\t\t\t\t\t\t} // brace #6\n\t\t\t\t\t\t\t} // brace #5\n\t\t\t\t\t\t} // brace #4\n\t\t\t\t\t} // brace #3\n\t\t\t\t} // brace #2\n\t\t\t} // brace #1\n\n\n\t\t\t// fall through for cases that did not change state on their own\n\t\t\t// at this point, a new statement has been parsed\n\t\t\tthis.data();\n\n\n\t\t\t// goto next parsing state; bail out of stack\n\t\t\treturn this.after_end_of_statement;\n\t\t}\n\n\t\t\t\t// ran out of characters\n\t\t\t\t// update index value\n\t\tthis.i = i;\n\n\t\t// not yet eos\n\t\tif(i < this.n) {\n\t\t\t// expected token was not found\n\t\t\tif(0 === i) {\n\t\t\t\t// we've exceeded the maximum token length\n\t\t\t\tif(this.n > this.max_token_length) {\n\t\t\t\t\treturn this.parse_error('object_list');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// save state before pausing\n\t\tthis._f_state = this.object_list;\n\n\t\t// store what is unparsed\n\t\tthis.pre = s.slice(i);\n\n\t\t// if we're not parsing a stream, then this is an error\n\t\tif(this.eos) this.eos();\n\t\treturn;\n\t}\n\n\n\n\t// parse state for string_literal_short_double\n\tstring_literal_short_double() {\n\t\t// destruct chunk, length, and index\n\t\tlet {s, n, i} = this;\n\n\t\t// start labeled loop, run while there are characters\n\t\tstring_literal_short_double: while(i < n) {  // eslint-disable-line no-unmodified-loop-condition\n// something breaks string in this chunk\n\n\t\t\t// prepare sticky regex index\n\t\t\tR_STRLIT_SHORT_DOUBLE_BREAK.lastIndex = i;\n\t\t\t// execute regex\n\t\t\tlet m_break = R_STRLIT_SHORT_DOUBLE_BREAK.exec(s);\n\n\t\t\t// regex was a match\n\t\t\tif(m_break) {\n\t\t\t\t// advance index\n\t\t\t\tthis.i = R_STRLIT_SHORT_DOUBLE_BREAK.lastIndex;\n\t\t\t\t// index of break\n\t\t\t\tlet i_break = m_break.index;\n\n\t\t\t\t// add to contents\n\t\t\t\tthis._s_literal += s.slice(i, i_break);\n\n\t\t\t\t// depending on char\n\t\t\t\tswitch(s[i_break]) {\n\t\t\t\t\t// terminator\n\t\t\t\t\tcase '\"': {\n\t\t\t\t\t// advance index to next token beyond delimiter\n\t\t\t\t\t// consume whitespace (and incidentally reset index)\n\t\t\t\t\t\tR_WS.lastIndex = i_break + 1;\n\t\t\t\t\t\tR_WS.exec(s);\n\t\t\t\t\t\tthis.i = R_WS.lastIndex;\n\n\t\t\t\t\t\t// resume eating whitespace at start of next chunk\n\t\t\t\t\t\tthis._b_trim_start = true;\n\n\t\t\t\t\t\t// consume rest\n\t\t\t\t\t\treturn this.datatype_or_langtag();\n\t\t\t\t\t}\n\n\t\t\t\t\t// escape\n\t\t\t\t\tcase '\\\\': {\n\t\t\t\t\t\t// try to find end\n\t\t\t\t\t\tR_STRLIT_SHORT_DOUBLE_TERM.lastIndex = i_break;\n\t\t\t\t\t\tlet m_term = R_STRLIT_SHORT_DOUBLE_TERM.exec(s);\n\n\t\t\t\t\t\t// end is in this chunk\n\t\t\t\t\t\tif(m_term) {\n\t\t\t\t\t\t\t// index of terminator\n\t\t\t\t\t\t\tlet i_term = m_term.index;\n\n\t\t\t\t\t\t\t// extract dirty potion\n\t\t\t\t\t\t\tlet s_dirty = s.slice(i_break, i_term);\n\n\t\t\t\t\t\t\t// clean and save\n\t\t\t\t\t\t\tthis._s_literal += unescape_literal_short_hard(s_dirty);\n\n\t\t\t\t\t\t\t// advance index beyond terminator\n\t\t\t\t\t\t\tthis.i = i_term + m_term[0].length;\n\n\t\t\t\t\t\t\t// resume eating whitespace at start of next chunk\n\t\t\t\t\t\t\tthis._b_trim_start = true;\n\n\t\t\t\t\t\t\t// consume rest\n\t\t\t\t\t\t\treturn this.datatype_or_langtag();\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// end is not in this chunk\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t// extract whole portion\n\t\t\t\t\t\t\tlet s_dirty = s.slice(i_break);\n\n\t\t\t\t\t\t\t// unescape to clean part\n\t\t\t\t\t\t\tlet [s_clean, s_incomplete] = unescape_literal_short_soft(s_dirty);\n\n\t\t\t\t\t\t\t// save\n\t\t\t\t\t\t\tthis._s_literal += s_clean;\n\n\t\t\t\t\t\t\t// set unparsed index\n\t\t\t\t\t\t\ti = n - s_incomplete.length;\n\n\t\t\t\t\t\t\t// reached eos; pause normally\n\t\t\t\t\t\t\tbreak string_literal_short_double;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// invalid '\\n'\n\t\t\t\t\tcase '\\n': {\n\t\t\t\t\t\treturn this.info_error(`expected string_literal_short_double but invalid line feed character '\\\\n' (newline) within contents. failed to parse a valid token`);\n\t\t\t\t\t}\n\n\t\t\t\t\t// invalid '\\r'\n\t\t\t\t\tcase '\\r': {\n\t\t\t\t\t\treturn this.info_error(`expected string_literal_short_double but invalid form feed character '\\\\r' (carriage return) within contents. failed to parse a valid token`);\n\t\t\t\t\t}\n\n\t\t\t\t\t// invalid\n\t\t\t\t\tdefault: {\n\t\t\t\t\t\tconsole.assert(`Unhandle invalid character ${JSON.stringify(s[i_break])} case for string_literal_short_double`);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t// no terminator and nothing to escape\n\t\t// match counter: 0\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// save\n\t\t\t\tthis._s_literal += i? s.slice(i): s;\n\n\t\t\t\t// set unparsed index\n\t\t\t\ti = n;\n\n\t\t\t\t// reached eos; pause normally\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// do not eat whitespace at start of next chunk\n\t\tthis._b_trim_start = false;\n\n\t// ran out of characters\n\t// update index value\n\t\tthis.i = i;\n\n\t\t// not yet eos\n\t\tif(i < this.n) {\n\t\t\t// expected token was not found\n\t\t\tif(0 === i) {\n\t\t\t\t// we've exceeded the maximum token length\n\t\t\t\tif(this.n > this.max_token_length) {\n\t\t\t\t\treturn this.parse_error('string_literal_short_double');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// save state before pausing\n\t\tthis._f_state = this.string_literal_short_double;\n\n\t\t// store what is unparsed\n\t\tthis.pre = s.slice(i);\n\n\t\t// if we're not parsing a stream, then this is an error\n\t\tif(this.eos) this.eos();\n\t\treturn;\n\t}\n\n\n\n\t// parse state for string_literal_short_single\n\tstring_literal_short_single() {\n\t\t// destruct chunk, length, and index\n\t\tlet {s, n, i} = this;\n\n\t\t// start labeled loop, run while there are characters\n\t\tstring_literal_short_single: while(i < n) {  // eslint-disable-line no-unmodified-loop-condition\n// something breaks string in this chunk\n\n\t\t\t// prepare sticky regex index\n\t\t\tR_STRLIT_SHORT_SINGLE_BREAK.lastIndex = i;\n\t\t\t// execute regex\n\t\t\tlet m_break = R_STRLIT_SHORT_SINGLE_BREAK.exec(s);\n\n\t\t\t// regex was a match\n\t\t\tif(m_break) {\n\t\t\t\t// advance index\n\t\t\t\tthis.i = R_STRLIT_SHORT_SINGLE_BREAK.lastIndex;\n\t\t\t\t// index of break\n\t\t\t\tlet i_break = m_break.index;\n\n\t\t\t\t// add to contents\n\t\t\t\tthis._s_literal += s.slice(i, i_break);\n\n\t\t\t\t// depending on char\n\t\t\t\tswitch(s[i_break]) {\n\t\t\t\t\t// terminator\n\t\t\t\t\tcase \"'\": {\n\t\t\t\t\t// advance index to next token beyond delimiter\n\t\t\t\t\t// consume whitespace (and incidentally reset index)\n\t\t\t\t\t\tR_WS.lastIndex = i_break + 1;\n\t\t\t\t\t\tR_WS.exec(s);\n\t\t\t\t\t\tthis.i = R_WS.lastIndex;\n\n\t\t\t\t\t\t// resume eating whitespace at start of next chunk\n\t\t\t\t\t\tthis._b_trim_start = true;\n\n\t\t\t\t\t\t// consume rest\n\t\t\t\t\t\treturn this.datatype_or_langtag();\n\t\t\t\t\t}\n\n\t\t\t\t\t// escape\n\t\t\t\t\tcase '\\\\': {\n\t\t\t\t\t\t// try to find end\n\t\t\t\t\t\tR_STRLIT_SHORT_SINGLE_TERM.lastIndex = i_break;\n\t\t\t\t\t\tlet m_term = R_STRLIT_SHORT_SINGLE_TERM.exec(s);\n\n\t\t\t\t\t\t// end is in this chunk\n\t\t\t\t\t\tif(m_term) {\n\t\t\t\t\t\t\t// index of terminator\n\t\t\t\t\t\t\tlet i_term = m_term.index;\n\n\t\t\t\t\t\t\t// extract dirty potion\n\t\t\t\t\t\t\tlet s_dirty = s.slice(i_break, i_term);\n\n\t\t\t\t\t\t\t// clean and save\n\t\t\t\t\t\t\tthis._s_literal += unescape_literal_short_hard(s_dirty);\n\n\t\t\t\t\t\t\t// advance index beyond terminator\n\t\t\t\t\t\t\tthis.i = i_term + m_term[0].length;\n\n\t\t\t\t\t\t\t// resume eating whitespace at start of next chunk\n\t\t\t\t\t\t\tthis._b_trim_start = true;\n\n\t\t\t\t\t\t\t// consume rest\n\t\t\t\t\t\t\treturn this.datatype_or_langtag();\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// end is not in this chunk\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t// extract whole portion\n\t\t\t\t\t\t\tlet s_dirty = s.slice(i_break);\n\n\t\t\t\t\t\t\t// unescape to clean part\n\t\t\t\t\t\t\tlet [s_clean, s_incomplete] = unescape_literal_short_soft(s_dirty);\n\n\t\t\t\t\t\t\t// save\n\t\t\t\t\t\t\tthis._s_literal += s_clean;\n\n\t\t\t\t\t\t\t// set unparsed index\n\t\t\t\t\t\t\ti = n - s_incomplete.length;\n\n\t\t\t\t\t\t\t// reached eos; pause normally\n\t\t\t\t\t\t\tbreak string_literal_short_single;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// invalid '\\n'\n\t\t\t\t\tcase '\\n': {\n\t\t\t\t\t\treturn this.info_error(`expected string_literal_short_single but invalid line feed character '\\\\n' (newline) within contents. failed to parse a valid token`);\n\t\t\t\t\t}\n\n\t\t\t\t\t// invalid '\\r'\n\t\t\t\t\tcase '\\r': {\n\t\t\t\t\t\treturn this.info_error(`expected string_literal_short_single but invalid form feed character '\\\\r' (carriage return) within contents. failed to parse a valid token`);\n\t\t\t\t\t}\n\n\t\t\t\t\t// invalid\n\t\t\t\t\tdefault: {\n\t\t\t\t\t\tconsole.assert(`Unhandle invalid character ${JSON.stringify(s[i_break])} case for string_literal_short_single`);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t// no terminator and nothing to escape\n\t\t// match counter: 0\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// save\n\t\t\t\tthis._s_literal += i? s.slice(i): s;\n\n\t\t\t\t// set unparsed index\n\t\t\t\ti = n;\n\n\t\t\t\t// reached eos; pause normally\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// do not eat whitespace at start of next chunk\n\t\tthis._b_trim_start = false;\n\n\t// ran out of characters\n\t// update index value\n\t\tthis.i = i;\n\n\t\t// not yet eos\n\t\tif(i < this.n) {\n\t\t\t// expected token was not found\n\t\t\tif(0 === i) {\n\t\t\t\t// we've exceeded the maximum token length\n\t\t\t\tif(this.n > this.max_token_length) {\n\t\t\t\t\treturn this.parse_error('string_literal_short_single');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// save state before pausing\n\t\tthis._f_state = this.string_literal_short_single;\n\n\t\t// store what is unparsed\n\t\tthis.pre = s.slice(i);\n\n\t\t// if we're not parsing a stream, then this is an error\n\t\tif(this.eos) this.eos();\n\t\treturn;\n\t}\n\n\n\n\t// parse state for string_literal_long_double\n\tstring_literal_long_double() {\n\t\t// destruct chunk, length, and index\n\t\tlet {s, n, i} = this;\n\n\t\t// start labeled loop, run while there are characters\n\t\tstring_literal_long_double: while(i < n) {  // eslint-disable-line no-unmodified-loop-condition\n// something breaks string in this chunk\n\n\t\t\t// prepare sticky regex index\n\t\t\tR_STRLIT_LONG_DOUBLE_BREAK.lastIndex = i;\n\t\t\t// execute regex\n\t\t\tlet m_break = R_STRLIT_LONG_DOUBLE_BREAK.exec(s);\n\n\t\t\t// regex was a match\n\t\t\tif(m_break) {\n\t\t\t\t// advance index\n\t\t\t\tthis.i = R_STRLIT_LONG_DOUBLE_BREAK.lastIndex;\n\t\t\t\t// index of break\n\t\t\t\tlet i_break = m_break.index;\n\n\t\t\t\t// add to contents\n\t\t\t\tthis._s_literal += s.slice(i, i_break);\n\n\t\t\t\t// depending on char\n\t\t\t\tswitch(s[i_break]) {\n\t\t\t\t\t// terminator\n\t\t\t\t\tcase '\"': {\n\t\t\t\t\t// advance index to next token beyond delimiter\n\t\t\t\t\t// consume whitespace (and incidentally reset index)\n\t\t\t\t\t\tR_WS.lastIndex = i_break + 3;\n\t\t\t\t\t\tR_WS.exec(s);\n\t\t\t\t\t\tthis.i = R_WS.lastIndex;\n\n\t\t\t\t\t\t// resume eating whitespace at start of next chunk\n\t\t\t\t\t\tthis._b_trim_start = true;\n\n\t\t\t\t\t\t// consume rest\n\t\t\t\t\t\treturn this.datatype_or_langtag();\n\t\t\t\t\t}\n\n\t\t\t\t\t// escape\n\t\t\t\t\tcase '\\\\': {\n\t\t\t\t\t\t// try to find end\n\t\t\t\t\t\tR_STRLIT_LONG_DOUBLE_TERM.lastIndex = i_break;\n\t\t\t\t\t\tlet m_term = R_STRLIT_LONG_DOUBLE_TERM.exec(s);\n\n\t\t\t\t\t\t// end is in this chunk\n\t\t\t\t\t\tif(m_term) {\n\t\t\t\t\t\t\t// index of terminator\n\t\t\t\t\t\t\tlet i_term = m_term.index;\n\n\t\t\t\t\t\t\t// extract dirty potion\n\t\t\t\t\t\t\tlet s_dirty = s.slice(i_break, i_term);\n\n\t\t\t\t\t\t\t// clean and save\n\t\t\t\t\t\t\tthis._s_literal += unescape_literal_long_hard(s_dirty);\n\n\t\t\t\t\t\t\t// advance index beyond terminator\n\t\t\t\t\t\t\tthis.i = i_term + m_term[0].length;\n\n\t\t\t\t\t\t\t// resume eating whitespace at start of next chunk\n\t\t\t\t\t\t\tthis._b_trim_start = true;\n\n\t\t\t\t\t\t\t// consume rest\n\t\t\t\t\t\t\treturn this.datatype_or_langtag();\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// end is not in this chunk\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t// extract whole portion\n\t\t\t\t\t\t\tlet s_dirty = s.slice(i_break);\n\n\t\t\t\t\t\t\t// unescape to clean part\n\t\t\t\t\t\t\tlet [s_clean, s_incomplete] = unescape_literal_long_soft(s_dirty);\n\n\t\t\t\t\t\t\t// save\n\t\t\t\t\t\t\tthis._s_literal += s_clean;\n\n\t\t\t\t\t\t\t// set unparsed index\n\t\t\t\t\t\t\ti = n - s_incomplete.length;\n\n\t\t\t\t\t\t\t// reached eos; pause normally\n\t\t\t\t\t\t\tbreak string_literal_long_double;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// invalid\n\t\t\t\t\tdefault: {\n\t\t\t\t\t\tconsole.assert(`Unhandle invalid character ${JSON.stringify(s[i_break])} case for string_literal_long_double`);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t// no terminator and nothing to escape\n\t\t// match counter: 0\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// could be unfinished terminator\n\t\t\t\tR_STRLIT_LONG_DOUBLE_UNFINISHED_TERM.lastIndex = i;\n\t\t\t\tlet m_unfinished = R_STRLIT_LONG_DOUBLE_UNFINISHED_TERM.exec(s);\n\n\t\t\t\t// unfinished terminator\n\t\t\t\tif(m_unfinished) {\n\t\t\t\t\t// save valid portion\n\t\t\t\t\tthis._s_literal += s.slice(i, m_unfinished.index);\n\n\t\t\t\t\t// set unparsed index\n\t\t\t\t\ti = m_unfinished.index;\n\t\t\t\t}\n\t\t\t\t// not unfinished\n\t\t\t\telse {\n\t\t\t\t\t// save\n\t\t\t\t\tthis._s_literal += i? s.slice(i): s;\n\n\t\t\t\t\t// set unparsed index\n\t\t\t\t\ti = n;\n\t\t\t\t}\n\n\t\t\t\t// reached eos; pause normally\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// do not eat whitespace at start of next chunk\n\t\tthis._b_trim_start = false;\n\n\t// ran out of characters\n\t// update index value\n\t\tthis.i = i;\n\n\t\t// not yet eos\n\t\tif(i < this.n) {\n\t\t\t// expected token was not found\n\t\t\tif(0 === i) {\n\t\t\t\t// we've exceeded the maximum token length\n\t\t\t\tif(this.n > this.max_token_length) {\n\t\t\t\t\treturn this.parse_error('string_literal_long_double');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// save state before pausing\n\t\tthis._f_state = this.string_literal_long_double;\n\n\t\t// store what is unparsed\n\t\tthis.pre = s.slice(i);\n\n\t\t// if we're not parsing a stream, then this is an error\n\t\tif(this.eos) this.eos();\n\t\treturn;\n\t}\n\n\n\n\t// parse state for string_literal_long_single\n\tstring_literal_long_single() {\n\t\t// destruct chunk, length, and index\n\t\tlet {s, n, i} = this;\n\n\t\t// start labeled loop, run while there are characters\n\t\tstring_literal_long_single: while(i < n) {  // eslint-disable-line no-unmodified-loop-condition\n// something breaks string in this chunk\n\n\t\t\t// prepare sticky regex index\n\t\t\tR_STRLIT_LONG_SINGLE_BREAK.lastIndex = i;\n\t\t\t// execute regex\n\t\t\tlet m_break = R_STRLIT_LONG_SINGLE_BREAK.exec(s);\n\n\t\t\t// regex was a match\n\t\t\tif(m_break) {\n\t\t\t\t// advance index\n\t\t\t\tthis.i = R_STRLIT_LONG_SINGLE_BREAK.lastIndex;\n\t\t\t\t// index of break\n\t\t\t\tlet i_break = m_break.index;\n\n\t\t\t\t// add to contents\n\t\t\t\tthis._s_literal += s.slice(i, i_break);\n\n\t\t\t\t// depending on char\n\t\t\t\tswitch(s[i_break]) {\n\t\t\t\t\t// terminator\n\t\t\t\t\tcase \"'\": {\n\t\t\t\t\t// advance index to next token beyond delimiter\n\t\t\t\t\t// consume whitespace (and incidentally reset index)\n\t\t\t\t\t\tR_WS.lastIndex = i_break + 3;\n\t\t\t\t\t\tR_WS.exec(s);\n\t\t\t\t\t\tthis.i = R_WS.lastIndex;\n\n\t\t\t\t\t\t// resume eating whitespace at start of next chunk\n\t\t\t\t\t\tthis._b_trim_start = true;\n\n\t\t\t\t\t\t// consume rest\n\t\t\t\t\t\treturn this.datatype_or_langtag();\n\t\t\t\t\t}\n\n\t\t\t\t\t// escape\n\t\t\t\t\tcase '\\\\': {\n\t\t\t\t\t\t// try to find end\n\t\t\t\t\t\tR_STRLIT_LONG_SINGLE_TERM.lastIndex = i_break;\n\t\t\t\t\t\tlet m_term = R_STRLIT_LONG_SINGLE_TERM.exec(s);\n\n\t\t\t\t\t\t// end is in this chunk\n\t\t\t\t\t\tif(m_term) {\n\t\t\t\t\t\t\t// index of terminator\n\t\t\t\t\t\t\tlet i_term = m_term.index;\n\n\t\t\t\t\t\t\t// extract dirty potion\n\t\t\t\t\t\t\tlet s_dirty = s.slice(i_break, i_term);\n\n\t\t\t\t\t\t\t// clean and save\n\t\t\t\t\t\t\tthis._s_literal += unescape_literal_long_hard(s_dirty);\n\n\t\t\t\t\t\t\t// advance index beyond terminator\n\t\t\t\t\t\t\tthis.i = i_term + m_term[0].length;\n\n\t\t\t\t\t\t\t// resume eating whitespace at start of next chunk\n\t\t\t\t\t\t\tthis._b_trim_start = true;\n\n\t\t\t\t\t\t\t// consume rest\n\t\t\t\t\t\t\treturn this.datatype_or_langtag();\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// end is not in this chunk\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t// extract whole portion\n\t\t\t\t\t\t\tlet s_dirty = s.slice(i_break);\n\n\t\t\t\t\t\t\t// unescape to clean part\n\t\t\t\t\t\t\tlet [s_clean, s_incomplete] = unescape_literal_long_soft(s_dirty);\n\n\t\t\t\t\t\t\t// save\n\t\t\t\t\t\t\tthis._s_literal += s_clean;\n\n\t\t\t\t\t\t\t// set unparsed index\n\t\t\t\t\t\t\ti = n - s_incomplete.length;\n\n\t\t\t\t\t\t\t// reached eos; pause normally\n\t\t\t\t\t\t\tbreak string_literal_long_single;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t\t\t\t// invalid\n\t\t\t\t\tdefault: {\n\t\t\t\t\t\tconsole.assert(`Unhandle invalid character ${JSON.stringify(s[i_break])} case for string_literal_long_single`);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t// no terminator and nothing to escape\n\t\t// match counter: 0\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// could be unfinished terminator\n\t\t\t\tR_STRLIT_LONG_SINGLE_UNFINISHED_TERM.lastIndex = i;\n\t\t\t\tlet m_unfinished = R_STRLIT_LONG_SINGLE_UNFINISHED_TERM.exec(s);\n\n\t\t\t\t// unfinished terminator\n\t\t\t\tif(m_unfinished) {\n\t\t\t\t\t// save valid portion\n\t\t\t\t\tthis._s_literal += s.slice(i, m_unfinished.index);\n\n\t\t\t\t\t// set unparsed index\n\t\t\t\t\ti = m_unfinished.index;\n\t\t\t\t}\n\t\t\t\t// not unfinished\n\t\t\t\telse {\n\t\t\t\t\t// save\n\t\t\t\t\tthis._s_literal += i? s.slice(i): s;\n\n\t\t\t\t\t// set unparsed index\n\t\t\t\t\ti = n;\n\t\t\t\t}\n\n\t\t\t\t// reached eos; pause normally\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t// do not eat whitespace at start of next chunk\n\t\tthis._b_trim_start = false;\n\n\t// ran out of characters\n\t// update index value\n\t\tthis.i = i;\n\n\t\t// not yet eos\n\t\tif(i < this.n) {\n\t\t\t// expected token was not found\n\t\t\tif(0 === i) {\n\t\t\t\t// we've exceeded the maximum token length\n\t\t\t\tif(this.n > this.max_token_length) {\n\t\t\t\t\treturn this.parse_error('string_literal_long_single');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// save state before pausing\n\t\tthis._f_state = this.string_literal_long_single;\n\n\t\t// store what is unparsed\n\t\tthis.pre = s.slice(i);\n\n\t\t// if we're not parsing a stream, then this is an error\n\t\tif(this.eos) this.eos();\n\t\treturn;\n\t}\n\n\n\n\t// parse state for string_literal\n\tstring_literal() {\n\t\t// destruct chunk, length, and index\n\t\tlet {s, n, i} = this;\n\n\t\t// start labeled loop, run while there are characters\n\t\twhile(i < n) {  // eslint-disable-line no-unmodified-loop-condition\n\t\t\t// ref character\n\t\t\tlet x = s[i];\n\n\t\t\t// string literal * double\n\t\t\tif('\"' === x) {\n\t\t\t\t// enough chars to deduce type\n\t\t\t\tif((i+2) < n) {\n\t\t\t\t\t// long type\n\t\t\t\t\tif('\"' === s[i+1] && '\"' === s[i+2]) {\n\t\t\t\t\t\t// advance index beyond token\n\t\t\t\t\t\tthis.i = i + 3;\n\n\t\t\t\t\t\t// read contents\n\t\t\t\t\t\treturn this.string_literal_long_double();\n\t\t\t\t\t}\n\t\t\t\t\t// not long type\n\t\t\t\t\telse {\n\t\t\t\t\t\t// advance index beyond token\n\t\t\t\t\t\tthis.i = i + 1;\n\n\t\t\t\t\t\t// read contents\n\t\t\t\t\t\treturn this.string_literal_short_double();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// enough chars to eliminate long type\n\t\t\t\telse if((i+1) < n && '\"' !== s[i+1]) {\n\t\t\t\t\t// advance index beyond token\n\t\t\t\t\tthis.i = i + 1;\n\n\t\t\t\t\t// read contents\n\t\t\t\t\treturn this.string_literal_short_double();\n\t\t\t\t}\n\t\t\t\t// not enough chars to deduce type; retry next chunk\n\t\t\t\telse {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t// string literal * single\n\t\t\t}\n\t\t\telse \tif('\\'' === x) {\n\t\t\t\t// enough chars to deduce type\n\t\t\t\tif((i+2) < n) {\n\t\t\t\t\t// long type\n\t\t\t\t\tif(\"'\" === s[i+1] && \"'\" === s[i+2]) {\n\t\t\t\t\t\t// advance index beyond token\n\t\t\t\t\t\tthis.i = i + 3;\n\n\t\t\t\t\t\t// read contents\n\t\t\t\t\t\treturn this.string_literal_long_single();\n\t\t\t\t\t}\n\t\t\t\t\t// not long type\n\t\t\t\t\telse {\n\t\t\t\t\t\t// advance index beyond token\n\t\t\t\t\t\tthis.i = i + 1;\n\n\t\t\t\t\t\t// read contents\n\t\t\t\t\t\treturn this.string_literal_short_single();\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// enough chars to eliminate long type\n\t\t\t\telse if((i+1) < n && \"'\" !== s[i+1]) {\n\t\t\t\t\t// advance index beyond token\n\t\t\t\t\tthis.i = i + 1;\n\n\t\t\t\t\t// read contents\n\t\t\t\t\treturn this.string_literal_short_single();\n\t\t\t\t}\n\t\t\t\t// not enough chars to deduce type; retry next chunk\n\t\t\t\telse {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t// not string literal long single quote, not string literal single quote\n\t\t\t// match counter: 0\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// break loop to retry on next chunk if eos\n\t\t\t\tbreak;\n\t\t\t}\n\t\t}\n\n\t\t\t\t// ran out of characters\n\t\t\t\t// update index value\n\t\tthis.i = i;\n\n\t\t// not yet eos\n\t\tif(i < this.n) {\n\t\t\t// expected token was not found\n\t\t\tif(0 === i) {\n\t\t\t\t// we've exceeded the maximum token length\n\t\t\t\tif(this.n > this.max_string_length) {\n\t\t\t\t\treturn this.parse_error('string_literal');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// save state before pausing\n\t\tthis._f_state = this.string_literal;\n\n\t\t// store what is unparsed\n\t\tthis.pre = s.slice(i);\n\n\t\t// if we're not parsing a stream, then this is an error\n\t\tif(this.eos) this.eos();\n\t\treturn;\n\t}\n\n\n\n\t// parse state for datatype_or_langtag\n\tdatatype_or_langtag() {\n\t\t// destruct chunk, length, and index\n\t\tlet {s, n, i} = this;\n\n\t\t// start labeled loop, run while there are characters\n\t\twhile(i < n) {  // eslint-disable-line no-unmodified-loop-condition\n\t\t\t// ref character\n\t\t\tlet x = s[i];\n\n\t\t\t// next token indicates datatype or langtag\n\t\t\tif('^' === x || '@' === x) {\n// '^^' datatype\n\n\t\t\t\t// prepare sticky regex index\n\t\t\t\tR_DOUBLE_CARET.lastIndex = i;\n\n\t\t\t\tif(R_DOUBLE_CARET.exec(s)) {\n\t\t\t\t\t// advance index\n\t\t\t\t\tthis.i = R_DOUBLE_CARET.lastIndex;\n\t\t\t\t\treturn this.datatype();\n\n\t\t\t\t// '@' language tag\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\tR_LANGTAG.lastIndex = i;\n\t\t\t\t\t// execute regex\n\t\t\t\t\tlet m_langtag = R_LANGTAG.exec(s);\n\n\t\t\t\t\t// regex was a match\n\t\t\t\t\tif(m_langtag) {\n\t\t\t\t\t\t// advance index\n\t\t\t\t\t\tthis.i = R_LANGTAG.lastIndex;\n\t\t\t\t\t\tthis._kt_object = this._dc_factory.languagedLiteral(this._s_literal, m_langtag[1]);\n\n\t\t\t\t\t\t// reset literal\n\t\t\t\t\t\tthis._s_literal = '';\n\n\t\t\t\t// next token definitely datatype or langtag, we are just being interrupted by eos\n\t\t\t\t// match counter: 1\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// break loop to retry on next chunk if eos\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} // brace #1\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// prepare sticky regex index\n\t\t\t\tR_COMMENT.lastIndex = i;\n\t\t\t\t// execute regex\n\t\t\t\tlet m_comment = R_COMMENT.exec(s);\n\n\t\t\t\t// regex was a match\n\t\t\t\tif(m_comment) {\n\t\t\t\t\t// advance index\n\t\t\t\t\ti = R_COMMENT.lastIndex;\n\t\t\t\t\tif(this.emit_comments) this.emit_comments(m_comment[0]);\n\t\t\t\t\tcontinue;\n\n\t\t\t\t// match counter: 1\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\tthis._kt_object = this._dc_factory.simpleLiteral(this._s_literal);\n\n\t\t\t\t\t// reset literal\n\t\t\t\t\tthis._s_literal = '';\n\n\t\t\t\t// not datatype, not language tag => that's okay! those are optional\n\t\t\t\t}\n\t\t\t} // brace #1\n\n\n\t\t\t// goto end of statement state\n\t\t\t// at this point, a new statement has been parsed\n\t\t\tthis.data();\n\n\n\t\t\t// goto next parsing state; bail out of stack\n\t\t\treturn this.after_end_of_statement;\n\t\t}\n\n\t\t\t\t// ran out of characters\n\t\t\t\t// update index value\n\t\tthis.i = i;\n\n\t\t// not yet eos\n\t\tif(i < this.n) {\n\t\t\t// expected token was not found\n\t\t\tif(0 === i) {\n\t\t\t\t// we've exceeded the maximum token length\n\t\t\t\tif(this.n > this.max_token_length) {\n\t\t\t\t\treturn this.parse_error('datatype_or_langtag');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// save state before pausing\n\t\tthis._f_state = this.datatype_or_langtag;\n\n\t\t// store what is unparsed\n\t\tthis.pre = s.slice(i);\n\n\t\t// if we're not parsing a stream, then this is an error\n\t\tif(this.eos) this.eos();\n\t\treturn;\n\t}\n\n\n\n\t// parse state for datatype\n\tdatatype() {\n\t\t// destruct chunk, length, and index\n\t\tlet {s, n, i} = this;\n\n\t\t// start labeled loop, run while there are characters\n\t\twhile(i < n) {  // eslint-disable-line no-unmodified-loop-condition\n\t\t\tlet kt_datatype = null;\n\n// prefixed name quick\n\n\t\t\t// prepare sticky regex index\n\t\t\tR_PREFIXED_NAME_QUICK.lastIndex = i;\n\t\t\t// execute regex\n\t\t\tlet m_pnq_datatype = R_PREFIXED_NAME_QUICK.exec(s);\n\n\t\t\t// regex was a match\n\t\t\tif(m_pnq_datatype) {\n\t\t\t\t// advance index\n\t\t\t\tthis.i = R_PREFIXED_NAME_QUICK.lastIndex;\n\t\t\t\t// check valid prefix\n\t\t\t\tlet s_prefix_id = m_pnq_datatype[1] || '';\n\t\t\t\t// invalid prefix\n\t\t\t\tif(!OPHOP.call(this._h_prefixes, s_prefix_id)) return this.error(`no such prefix \"${s_prefix_id}\"`);\n\n\n\t\t\t\t// commit object iri from resolve prefixed name\n\t\t\t\tkt_datatype = this.prefixed_name(s_prefix_id, m_pnq_datatype[2]);\n\n\t\t\t// iriref\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// prepare sticky regex index\n\t\t\t\tR_IRIREF_ESCAPELESS.lastIndex = i;\n\t\t\t\t// execute regex\n\t\t\t\tlet m_iriref_e_datatype = R_IRIREF_ESCAPELESS.exec(s);\n\n\t\t\t\t// regex was a match\n\t\t\t\tif(m_iriref_e_datatype) {\n\t\t\t\t\t// advance index\n\t\t\t\t\tthis.i = R_IRIREF_ESCAPELESS.lastIndex;\n\t\t\t\t\tlet p_datatype;\n\n\t\t\t\t\t// ref iri\n\t\t\t\t\tlet s_iri = m_iriref_e_datatype[1];\n\t\t\t\t\t// absolute iri\n\t\t\t\t\tif(!this._s_base_url || RT_IRI_ABSOLUTE.test(s_iri)) {\n\t\t\t\t\t\t// set p_datatype\n\t\t\t\t\t\tp_datatype = s_iri;\n\t\t\t\t\t}\n\t\t\t\t\t// relative iri\n\t\t\t\t\telse {\n\t\t\t\t\t\tp_datatype = uri.resolve(this._s_base_url, s_iri);\n\t\t\t\t\t}\n\n\t\t\t\t\tkt_datatype = this.check_named_node_escapeless(p_datatype);\n\n\t\t\t\t// prefixed name\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// try match\n\t\t\t\t\tlet aw_valid_this_match_prefixed_name_escapeless = this.match_prefixed_name_escapeless(s, i);\n\t\t\t\t\t// stack bail out\n\t\t\t\t\tif(!aw_valid_this_match_prefixed_name_escapeless) return true;\n\t\t\t\t\tlet [m_prefixed_named_e_datatype, im_prefixed_named_e_datatype] = aw_valid_this_match_prefixed_name_escapeless;\n\t\t\t\t\tif(m_prefixed_named_e_datatype) {\n\t\t\t\t\t\t// advance index\n\t\t\t\t\t\tthis.i = im_prefixed_named_e_datatype;\n\t\t\t\t\t\t// check valid prefix\n\t\t\t\t\t\tlet s_prefix_id = m_prefixed_named_e_datatype[1] || '';\n\t\t\t\t\t\t// invalid prefix\n\t\t\t\t\t\tif(!OPHOP.call(this._h_prefixes, s_prefix_id)) return this.error(`no such prefix \"${s_prefix_id}\"`);\n\n\n\t\t\t\t\t\tkt_datatype = this.prefixed_name(s_prefix_id, m_prefixed_named_e_datatype[2]);\n\n\t\t\t\t\t// iriref\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\t\tR_IRIREF.lastIndex = i;\n\t\t\t\t\t\t// execute regex\n\t\t\t\t\t\tlet m_iriref_datatype = R_IRIREF.exec(s);\n\n\t\t\t\t\t\t// regex was a match\n\t\t\t\t\t\tif(m_iriref_datatype) {\n\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\tthis.i = R_IRIREF.lastIndex;\n\t\t\t\t\t\t\tlet p_datatype;\n\n\t\t\t\t\t\t\t// ref iri\n\t\t\t\t\t\t\tlet s_iri = m_iriref_e_datatype[1].replace(R_UNICODE_ANY, F_REPLACE_UNICODE_ANY);\n\t\t\t\t\t\t\t// absolute iri\n\t\t\t\t\t\t\tif(!this._s_base_url || RT_IRI_ABSOLUTE.test(s_iri)) {\n\t\t\t\t\t\t\t\t// set p_datatype\n\t\t\t\t\t\t\t\tp_datatype = s_iri;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t// relative iri\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\tp_datatype = uri.resolve(this._s_base_url, s_iri);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\tkt_datatype = this.check_named_node(p_datatype);\n\n\t\t\t\t\t\t// prefixed name\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t// try match\n\t\t\t\t\t\t\tlet aw_valid_this_match_prefixed_name = this.match_prefixed_name(s, i);\n\t\t\t\t\t\t\t// stack bail out\n\t\t\t\t\t\t\tif(!aw_valid_this_match_prefixed_name) return true;\n\t\t\t\t\t\t\tlet [m_prefixed_named_datatype, im_prefixed_named_datatype] = aw_valid_this_match_prefixed_name;\n\t\t\t\t\t\t\tif(m_prefixed_named_datatype) {\n\t\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\t\tthis.i = im_prefixed_named_datatype;\n\t\t\t\t\t\t\t\t// check valid prefix\n\t\t\t\t\t\t\t\tlet s_prefix_id = m_prefixed_named_datatype[1] || '';\n\t\t\t\t\t\t\t\t// invalid prefix\n\t\t\t\t\t\t\t\tif(!OPHOP.call(this._h_prefixes, s_prefix_id)) return this.error(`no such prefix \"${s_prefix_id}\"`);\n\n\n\t\t\t\t\t\t\t\t// escape local escapes\n\t\t\t\t\t\t\t\tlet s_suffix = m_prefixed_named_datatype[2]\n\t\t\t\t\t\t\t\t\t.replace(R_UNICODE_ANY, F_REPLACE_UNICODE_ANY)\n\t\t\t\t\t\t\t\t\t.replace(R_PN_LOCAL_ESCAPES, '$1');\n\n\t\t\t\t\t\t\t\t// set literal datatype\n\t\t\t\t\t\t\t\tkt_datatype = this.prefixed_name(s_prefix_id, s_suffix);\n\n\t\t\t// not iriref, not prefixed name\n\t\t\t// match counter: 4\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t// break loop to retry on next chunk if eos\n\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t} // brace #4\n\t\t\t\t\t} // brace #3\n\t\t\t\t} // brace #2\n\t\t\t} // brace #1\n\n\n\t\t\tthis._kt_object = this._dc_factory.datatypedLiteral(this._s_literal, kt_datatype);\n\n\t\t\t// reset literal\n\t\t\tthis._s_literal = '';\n\n\t\t\t// goto end of statement state\n\t\t\t// at this point, a new statement has been parsed\n\t\t\tthis.data();\n\n\n\t\t\t// goto next parsing state; bail out of stack\n\t\t\treturn this.after_end_of_statement;\n\t\t}\n\n\t\t\t\t// ran out of characters\n\t\t\t\t// update index value\n\t\tthis.i = i;\n\n\t\t// not yet eos\n\t\tif(i < this.n) {\n\t\t\t// expected token was not found\n\t\t\tif(0 === i) {\n\t\t\t\t// we've exceeded the maximum token length\n\t\t\t\tif(this.n > this.max_token_length) {\n\t\t\t\t\treturn this.parse_error('datatype');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// save state before pausing\n\t\tthis._f_state = this.datatype;\n\n\t\t// store what is unparsed\n\t\tthis.pre = s.slice(i);\n\n\t\t// if we're not parsing a stream, then this is an error\n\t\tif(this.eos) this.eos();\n\t\treturn;\n\t}\n\n\n\n\t// parse state for post_object\n\tpost_object() {\n\t\t// destruct chunk, length, and index\n\t\tlet {s, n, i} = this;\n\n\t\t// start labeled loop, run while there are characters\n\t\twhile(i < n) {  // eslint-disable-line no-unmodified-loop-condition\n\t\t\tlet i_reset = i;\n\n\t\t\t// benchmarks confirm: character ref faster than regexes in this context\n\t\t\tlet x = s[i];\n\n\t\t\t// advance index to next token beyond delimiter\n\t\t\t// consume whitespace (and incidentally reset index)\n\t\t\tR_WS.lastIndex = i+1;\n\t\t\tR_WS.exec(s);\n\t\t\tthis.i = R_WS.lastIndex;\n\n\t\t\t// ',' more objects\n\t\t\tif(',' === x) {\n\t\t\t\treturn this.object_list();\n\n\t\t\t// ';' more predicate-object pairs\n\t\t\t}\n\t\t\telse \tif(';' === x) {\n\t\t\t\tfor(;;) {\n\t\t\t\t\t// next token is end of outer section\n\t\t\t\t\tlet s_peek = s[this.i];\n\t\t\t\t\tif('.' === s_peek || ']' === s_peek || ';' === s_peek || '}' === s_peek) {\n\t\t\t\t\t\t// goto post_object state\n\t\t\t\t\t\treturn this.post_object();\n\t\t\t\t\t}\n\t\t\t\t\t// comment\n\t\t\t\t\telse if('#' === s_peek) {\n\t\t\t\t\t\t// comment\n\t\t\t\t\t\ti = this.i;\n\n\t\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\t\tR_COMMENT.lastIndex = i;\n\t\t\t\t\t\t// execute regex\n\t\t\t\t\t\tlet m_comment = R_COMMENT.exec(s);\n\n\t\t\t\t\t\t// regex was a match\n\t\t\t\t\t\tif(m_comment) {\n\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\tthis.i = R_COMMENT.lastIndex;\n\t\t\t\t\t\t\tif(this.emit_comments) this.emit_comments(m_comment[0]);\n\t\t\t\t\t\t\t// retry\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\n\t\t\t\t\t\t// no eol to close comment (yet)\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t// already consumed\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// eos\n\t\t\t\t\telse if(this.i === n) {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t\t// something else\n\t\t\t\t\telse {\n\t\t\t\t\t\treturn this.pairs();\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\t// rather than pushing a dedicated state, just try again next chunk\n\t\t\t\ti = i_reset;\n\t\t\t\tbreak;\n\n\t\t\t// '.' end of statement\n\t\t\t}\n\t\t\telse \tif('.' === x) {\n\t\t\t\t// assert not nested\n\t\t\t\tif(this._a_nested.length) {\n\t\t\t\t\t// reset index to that character\n\t\t\t\t\tthis.i = i;\n\n\t\t\t\t\t// emit parse error\n\t\t\t\t\treturn this.parse_error('end_of_property_list');\n\t\t\t\t}\n\n\t\t\t\treturn (this._kt_default_graph === this._kt_graph)? this.block(): this.statement();\n\n\t\t\t// ']' end of property-object pairs\n\t\t\t}\n\t\t\telse \tif(']' === x) {\n\t\t\t\tlet s_resume_state;\n\t\t\t\t[this._kt_subject, this._kt_predicate, s_resume_state] = this._a_nested.pop();\n\t\t\t\treturn this[s_resume_state]();\n\n\t\t\t// ')' end of collection\n\t\t\t}\n\t\t\telse \tif(')' === x) {\n\t\t\t\t// should not be here\n\t\t\t\treturn Reader$syntax_error(this, i, 'post_object', 'but encountered end of collection');\n\n\t\t\t// closing graph '}'\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// prepare sticky regex index\n\t\t\t\tR_CHAR_CLOSE.lastIndex = i;\n\n\t\t\t\tif(R_CHAR_CLOSE.exec(s)) {\n\t\t\t\t\t// advance index\n\t\t\t\t\tthis.i = R_CHAR_CLOSE.lastIndex;\n\t\t\t\t\t// emit graph_close event\n\t\t\t\t\tthis.emit('exit', this._kt_graph);\n\n\t\t\t\t\t// reset graph\n\t\t\t\t\tthis._kt_graph = this._kt_default_graph;\n\n\t\t\t\t\treturn this.block();\n\n\t\t\t\t// comment\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\tR_COMMENT.lastIndex = i;\n\t\t\t\t\t// execute regex\n\t\t\t\t\tlet m_comment = R_COMMENT.exec(s);\n\n\t\t\t\t\t// regex was a match\n\t\t\t\t\tif(m_comment) {\n\t\t\t\t\t\t// advance index\n\t\t\t\t\t\ti = R_COMMENT.lastIndex;\n\t\t\t\t\t\tif(this.emit_comments) this.emit_comments(m_comment[0]);\n\t\t\t\t\t\t// do not change state\n\t\t\t\t\t\tcontinue;\n\n\t\t\t// comment interrupted by eos?\n\t\t\t// match counter: 2\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// break loop to retry on next chunk if eos\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} // brace #2\n\t\t\t} // brace #1\n\t\t}\n\n\t\t\t\t// ran out of characters\n\t\t\t\t// update index value\n\t\tthis.i = i;\n\n\t\t// not yet eos\n\t\tif(i < this.n) {\n\t\t\t// expected token was not found\n\t\t\tif(0 === i) {\n\t\t\t\t// we've exceeded the maximum token length\n\t\t\t\tif(this.n > this.max_token_length) {\n\t\t\t\t\treturn this.parse_error('post_object');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// save state before pausing\n\t\tthis._f_state = this.post_object;\n\n\t\t// store what is unparsed\n\t\tthis.pre = s.slice(i);\n\n\t\t// if we're not parsing a stream, then this is an error\n\t\tif(this.eos) this.eos();\n\t\treturn;\n\t}\n\n\n\n\t// parse state for base_iri\n\tbase_iri() {\n\t\t// destruct chunk, length, and index\n\t\tlet {s, n, i} = this;\n\n\t\t// start labeled loop, run while there are characters\n\t\twhile(i < n) {  // eslint-disable-line no-unmodified-loop-condition\n// prefix id\n\n\t\t\t// prepare sticky regex index\n\t\t\tR_IRIREF_ESCAPELESS.lastIndex = i;\n\t\t\t// execute regex\n\t\t\tlet m_iriref_e_base = R_IRIREF_ESCAPELESS.exec(s);\n\n\t\t\t// regex was a match\n\t\t\tif(m_iriref_e_base) {\n\t\t\t\t// advance index\n\t\t\t\tthis.i = R_IRIREF_ESCAPELESS.lastIndex;\n\n\t\t\t\t// ref iri\n\t\t\t\tlet s_iri = m_iriref_e_base[1];\n\t\t\t\t// absolute iri\n\t\t\t\tif(!this._s_base_url || RT_IRI_ABSOLUTE.test(s_iri)) {\n\t\t\t\t\t// set base_url\n\t\t\t\t\tthis._s_base_url = s_iri;\n\t\t\t\t}\n\t\t\t\t// relative iri\n\t\t\t\telse {\n\t\t\t\t\tthis._s_base_url = uri.resolve(this._s_base_url, s_iri);\n\t\t\t\t}\t\tlet m_base_iri = R_BASE_IRI.exec(this._s_base_url);\n\t\t\t\tthis._s_base_url = m_base_iri[1];\n\t\t\t\tthis._s_base_url_root = m_base_iri[2] || '';\n\t\t\t\tthis._s_base_url_scheme = m_base_iri[3] || '';\n\t\t\t\tthis._s_base_url_path = m_base_iri[4] || '';\n\n\n\t\t\t\t// emit base event\n\t\t\t\tthis.emit('base', this._s_base_url);\n\n\t\t\t\tif(this._b_expecting_full_stop) {\n\t\t\t\t\t// change state\n\t\t\t\t\treturn this.full_stop();\n\t\t\t\t}\n\n\t\t\t\t// goto prefix iri state\n\t\t\t\treturn this.block();\n\n\t\t\t// prefix id\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// prepare sticky regex index\n\t\t\t\tR_IRIREF.lastIndex = i;\n\t\t\t\t// execute regex\n\t\t\t\tlet m_iriref_base = R_IRIREF.exec(s);\n\n\t\t\t\t// regex was a match\n\t\t\t\tif(m_iriref_base) {\n\t\t\t\t\t// advance index\n\t\t\t\t\tthis.i = R_IRIREF.lastIndex;\n\n\t\t\t\t\t// ref iri\n\t\t\t\t\tlet s_iri = m_iriref_base[1].replace(R_UNICODE_ANY, F_REPLACE_UNICODE_ANY);\n\t\t\t\t\t// absolute iri\n\t\t\t\t\tif(!this._s_base_url || RT_IRI_ABSOLUTE.test(s_iri)) {\n\t\t\t\t\t\t// set base_url\n\t\t\t\t\t\tthis._s_base_url = s_iri;\n\t\t\t\t\t}\n\t\t\t\t\t// relative iri\n\t\t\t\t\telse {\n\t\t\t\t\t\tthis._s_base_url = uri.resolve(this._s_base_url, s_iri);\n\t\t\t\t\t}\t\tlet m_base_iri = R_BASE_IRI.exec(this._s_base_url);\n\t\t\t\t\tthis._s_base_url = m_base_iri[1];\n\t\t\t\t\tthis._s_base_url_root = m_base_iri[2] || '';\n\t\t\t\t\tthis._s_base_url_scheme = m_base_iri[3] || '';\n\t\t\t\t\tthis._s_base_url_path = m_base_iri[4] || '';\n\n\n\t\t\t\t\t// emit base event\n\t\t\t\t\tthis.emit('base', this._s_base_url);\n\n\t\t\t\t\tif(this._b_expecting_full_stop) {\n\t\t\t\t\t\t// change state\n\t\t\t\t\t\treturn this.full_stop();\n\t\t\t\t\t}\n\n\t\t\t\t\t// goto prefix iri state\n\t\t\t\t\treturn this.block();\n\n\t\t\t\t// for poorly-placed comments\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\tR_COMMENT.lastIndex = i;\n\t\t\t\t\t// execute regex\n\t\t\t\t\tlet m_comment = R_COMMENT.exec(s);\n\n\t\t\t\t\t// regex was a match\n\t\t\t\t\tif(m_comment) {\n\t\t\t\t\t\t// advance index\n\t\t\t\t\t\ti = R_COMMENT.lastIndex;\n\t\t\t\t\t\tif(this.emit_comments) this.emit_comments(m_comment[0]);\n\t\t\t\t\t\t// do not change state\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t// match counter: 2\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// break loop to retry on next chunk if eos\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} // brace #2\n\t\t\t} // brace #1\n\t\t}\n\n\t\t\t\t// ran out of characters\n\t\t\t\t// update index value\n\t\tthis.i = i;\n\n\t\t// not yet eos\n\t\tif(i < this.n) {\n\t\t\t// expected token was not found\n\t\t\tif(0 === i) {\n\t\t\t\t// we've exceeded the maximum token length\n\t\t\t\tif(this.n > this.max_token_length) {\n\t\t\t\t\treturn this.parse_error('base_iri');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// save state before pausing\n\t\tthis._f_state = this.base_iri;\n\n\t\t// store what is unparsed\n\t\tthis.pre = s.slice(i);\n\n\t\t// if we're not parsing a stream, then this is an error\n\t\tif(this.eos) this.eos();\n\t\treturn;\n\t}\n\n\n\n\t// parse state for prefix_id\n\tprefix_id() {\n\t\t// destruct chunk, length, and index\n\t\tlet {s, n, i} = this;\n\n\t\t// start labeled loop, run while there are characters\n\t\twhile(i < n) {  // eslint-disable-line no-unmodified-loop-condition\n// prefix id\n\n\t\t\t// prepare sticky regex index\n\t\t\tR_PREFIX_ID.lastIndex = i;\n\t\t\t// execute regex\n\t\t\tlet m_prefix_id = R_PREFIX_ID.exec(s);\n\n\t\t\t// regex was a match\n\t\t\tif(m_prefix_id) {\n\t\t\t\t// advance index\n\t\t\t\tthis.i = R_PREFIX_ID.lastIndex;\n\t\t\t\t// set temp prefix id\n\t\t\t\tthis._s_temp_prefix_id = m_prefix_id[1];\n\n\t\t\t\t// goto prefix iri state\n\t\t\t\treturn this.prefix_iri();\n\n\t\t\t// for poorly-placed comments\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// prepare sticky regex index\n\t\t\t\tR_COMMENT.lastIndex = i;\n\t\t\t\t// execute regex\n\t\t\t\tlet m_comment = R_COMMENT.exec(s);\n\n\t\t\t\t// regex was a match\n\t\t\t\tif(m_comment) {\n\t\t\t\t\t// advance index\n\t\t\t\t\ti = R_COMMENT.lastIndex;\n\t\t\t\t\tif(this.emit_comments) this.emit_comments(m_comment[0]);\n\t\t\t\t\t// do not change state\n\t\t\t\t\tcontinue;\n\n\t\t\t\t// match counter: 1\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// break loop to retry on next chunk if eos\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} // brace #1\n\t\t}\n\n\t\t\t\t// ran out of characters\n\t\t\t\t// update index value\n\t\tthis.i = i;\n\n\t\t// not yet eos\n\t\tif(i < this.n) {\n\t\t\t// expected token was not found\n\t\t\tif(0 === i) {\n\t\t\t\t// we've exceeded the maximum token length\n\t\t\t\tif(this.n > this.max_token_length) {\n\t\t\t\t\treturn this.parse_error('prefix_id');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// save state before pausing\n\t\tthis._f_state = this.prefix_id;\n\n\t\t// store what is unparsed\n\t\tthis.pre = s.slice(i);\n\n\t\t// if we're not parsing a stream, then this is an error\n\t\tif(this.eos) this.eos();\n\t\treturn;\n\t}\n\n\n\n\t// parse state for prefix_iri\n\tprefix_iri() {\n\t\t// destruct chunk, length, and index\n\t\tlet {s, n, i} = this;\n\n\t\t// start labeled loop, run while there are characters\n\t\twhile(i < n) {  // eslint-disable-line no-unmodified-loop-condition\n\t\t\tlet h_prefixes = this._h_prefixes;\n\t\t\tlet s_prefix_id = this._s_temp_prefix_id;\n\t\t\tlet p_prefix_iri;\n\n// prefix iri\n\n\t\t\t// prepare sticky regex index\n\t\t\tR_IRIREF_ESCAPELESS.lastIndex = i;\n\t\t\t// execute regex\n\t\t\tlet m_iriref_e_prefix = R_IRIREF_ESCAPELESS.exec(s);\n\n\t\t\t// regex was a match\n\t\t\tif(m_iriref_e_prefix) {\n\t\t\t\t// advance index\n\t\t\t\tthis.i = R_IRIREF_ESCAPELESS.lastIndex;\n\n\t\t\t\t// ref iri\n\t\t\t\tlet s_iri = m_iriref_e_prefix[1];\n\t\t\t\t// absolute iri\n\t\t\t\tif(!this._s_base_url || RT_IRI_ABSOLUTE.test(s_iri)) {\n\t\t\t\t\t// set p_prefix_iri\n\t\t\t\t\tp_prefix_iri = s_iri;\n\t\t\t\t}\n\t\t\t\t// relative iri\n\t\t\t\telse {\n\t\t\t\t\tp_prefix_iri = uri.resolve(this._s_base_url, s_iri);\n\t\t\t\t}\n\n\t\t\t\tlet b_relax = this._b_relax;\n\n// existing mapping\n\n\t\t\t\tif(s_prefix_id in h_prefixes) {\n\t\t\t\t\t// doesn't match existing\n\t\t\t\t\tif(p_prefix_iri !== h_prefixes[s_prefix_id]) {\n\t\t\t\t\t\t// emit change event\n\t\t\t\t\t\tif(this.prefix_change) {\n\t\t\t\t\t\t\tthis.prefix_change(s_prefix_id, h_prefixes[s_prefix_id], p_prefix_iri);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// update prefix\n\t\t\t\t\t\th_prefixes[s_prefix_id] = p_prefix_iri;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t// first mapping\n\t\t\t\telse {\n\t\t\t\t\t// check namespace, invalid\n\t\t\t\t\tif(!b_relax && !RT_PREFIXED_NAME_NAMESPACE_VALID.test(s_prefix_id)) {\n\t\t\t\t\t\treturn this.error(`Invalid namespace for prefixed name: \"${s_prefix_id}:\"`);\n\t\t\t\t\t}\n\n\t\t\t\t\t// set prefix\n\t\t\t\t\th_prefixes[s_prefix_id] = p_prefix_iri;\n\t\t\t\t}\n\n\t\t\t\t// check iri, invalid\n\t\t\t\tif(!b_relax && !RT_NAMED_NODE_VALID.test(p_prefix_iri)) {\n\t\t\t\t\treturn this.error(`Invalid IRI found in prefix delcaration: \"${s_iri}\"`);\n\t\t\t\t}\n\n\t\t\t\t// emit prefix event\n\t\t\t\tthis.event('prefix', s_prefix_id, p_prefix_iri);\n\n\t\t\t\tif(this._b_expecting_full_stop) {\n\t\t\t\t\t// change state\n\t\t\t\t\treturn this.full_stop();\n\t\t\t\t}\n\n\t\t\t\t// goto statement state\n\t\t\t\treturn this.block();\n\n\t\t\t// prefix iri\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// prepare sticky regex index\n\t\t\t\tR_IRIREF.lastIndex = i;\n\t\t\t\t// execute regex\n\t\t\t\tlet m_iriref_prefix = R_IRIREF.exec(s);\n\n\t\t\t\t// regex was a match\n\t\t\t\tif(m_iriref_prefix) {\n\t\t\t\t\t// advance index\n\t\t\t\t\tthis.i = R_IRIREF.lastIndex;\n\n\t\t\t\t\t// ref iri\n\t\t\t\t\tlet s_iri = m_iriref_prefix[1].replace(R_UNICODE_ANY, F_REPLACE_UNICODE_ANY);\n\t\t\t\t\t// absolute iri\n\t\t\t\t\tif(!this._s_base_url || RT_IRI_ABSOLUTE.test(s_iri)) {\n\t\t\t\t\t\t// set p_prefix_iri\n\t\t\t\t\t\tp_prefix_iri = s_iri;\n\t\t\t\t\t}\n\t\t\t\t\t// relative iri\n\t\t\t\t\telse {\n\t\t\t\t\t\tp_prefix_iri = uri.resolve(this._s_base_url, s_iri);\n\t\t\t\t\t}\n\n\t\t\t\t\tlet b_relax = this._b_relax;\n\n// existing mapping\n\n\t\t\t\t\tif(s_prefix_id in h_prefixes) {\n\t\t\t\t\t\t// doesn't match existing\n\t\t\t\t\t\tif(p_prefix_iri !== h_prefixes[s_prefix_id]) {\n\t\t\t\t\t\t\t// emit change event\n\t\t\t\t\t\t\tif(this.prefix_change) {\n\t\t\t\t\t\t\t\tthis.prefix_change(s_prefix_id, h_prefixes[s_prefix_id], p_prefix_iri);\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// update prefix\n\t\t\t\t\t\t\th_prefixes[s_prefix_id] = p_prefix_iri;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\t// first mapping\n\t\t\t\t\telse {\n\t\t\t\t\t\t// check namespace, invalid\n\t\t\t\t\t\tif(!b_relax && !RT_PREFIXED_NAME_NAMESPACE_VALID.test(s_prefix_id)) {\n\t\t\t\t\t\t\treturn this.error(`Invalid namespace for prefixed name: \"${s_prefix_id}:\"`);\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// set prefix\n\t\t\t\t\t\th_prefixes[s_prefix_id] = p_prefix_iri;\n\t\t\t\t\t}\n\n\t\t\t\t\t// check iri, invalid\n\t\t\t\t\tif(!b_relax && !RT_NAMED_NODE_VALID.test(p_prefix_iri)) {\n\t\t\t\t\t\treturn this.error(`Invalid IRI found in prefix delcaration: \"${s_iri}\"`);\n\t\t\t\t\t}\n\n\t\t\t\t\t// emit prefix event\n\t\t\t\t\tthis.event('prefix', s_prefix_id, p_prefix_iri);\n\n\t\t\t\t\tif(this._b_expecting_full_stop) {\n\t\t\t\t\t\t// change state\n\t\t\t\t\t\treturn this.full_stop();\n\t\t\t\t\t}\n\n\t\t\t\t\t// goto statement state\n\t\t\t\t\treturn this.block();\n\n\t\t\t\t// for poorly-placed comments\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\tR_COMMENT.lastIndex = i;\n\t\t\t\t\t// execute regex\n\t\t\t\t\tlet m_comment = R_COMMENT.exec(s);\n\n\t\t\t\t\t// regex was a match\n\t\t\t\t\tif(m_comment) {\n\t\t\t\t\t\t// advance index\n\t\t\t\t\t\ti = R_COMMENT.lastIndex;\n\t\t\t\t\t\tif(this.emit_comments) this.emit_comments(m_comment[0]);\n\t\t\t\t\t\t// do not change state\n\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t// match counter: 2\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// break loop to retry on next chunk if eos\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t} // brace #2\n\t\t\t} // brace #1\n\t\t}\n\n\t\t\t\t// ran out of characters\n\t\t\t\t// update index value\n\t\tthis.i = i;\n\n\t\t// not yet eos\n\t\tif(i < this.n) {\n\t\t\t// expected token was not found\n\t\t\tif(0 === i) {\n\t\t\t\t// we've exceeded the maximum token length\n\t\t\t\tif(this.n > this.max_token_length) {\n\t\t\t\t\treturn this.parse_error('prefix_iri');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// save state before pausing\n\t\tthis._f_state = this.prefix_iri;\n\n\t\t// store what is unparsed\n\t\tthis.pre = s.slice(i);\n\n\t\t// if we're not parsing a stream, then this is an error\n\t\tif(this.eos) this.eos();\n\t\treturn;\n\t}\n\n\n// in case eos happens twice during prefix / base (extremely unlikely)\n\n\n\t// parse state for full_stop\n\tfull_stop() {\n\t\t// destruct chunk, length, and index\n\t\tlet {s, n, i} = this;\n\n\t\t// start labeled loop, run while there are characters\n\t\twhile(i < n) {  // eslint-disable-line no-unmodified-loop-condition\n\t\t\t// prepare sticky regex index\n\t\t\tR_CHAR_STOP.lastIndex = i;\n\n\t\t\tif(R_CHAR_STOP.exec(s)) {\n\t\t\t\t// advance index\n\t\t\t\tthis.i = R_CHAR_STOP.lastIndex;\n\t\t\t\t// resume statement\n\t\t\t\treturn this.block();\n\n\t\t\t// poorly-placed comment\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// prepare sticky regex index\n\t\t\t\tR_COMMENT.lastIndex = i;\n\t\t\t\t// execute regex\n\t\t\t\tlet m_comment = R_COMMENT.exec(s);\n\n\t\t\t\t// regex was a match\n\t\t\t\tif(m_comment) {\n\t\t\t\t\t// advance index\n\t\t\t\t\ti = R_COMMENT.lastIndex;\n\t\t\t\t\tif(this.emit_comments) this.emit_comments(m_comment[0]);\n\t\t\t\t\t// try again\n\t\t\t\t\tcontinue;\n\n\t\t\t// possibly interrupted by eos\n\t\t\t// match counter: 1\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// break loop to retry on next chunk if eos\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t} // brace #1\n\t\t}\n\n\t\t\t\t// ran out of characters\n\t\t\t\t// update index value\n\t\tthis.i = i;\n\n\t\t// not yet eos\n\t\tif(i < this.n) {\n\t\t\t// expected token was not found\n\t\t\tif(0 === i) {\n\t\t\t\t// we've exceeded the maximum token length\n\t\t\t\tif(this.n > this.max_token_length) {\n\t\t\t\t\treturn this.parse_error('full_stop');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// save state before pausing\n\t\tthis._f_state = this.full_stop;\n\n\t\t// store what is unparsed\n\t\tthis.pre = s.slice(i);\n\n\t\t// if we're not parsing a stream, then this is an error\n\t\tif(this.eos) this.eos();\n\t\treturn;\n\t}\n\n\n\n\t// parse state for collection_subject\n\tcollection_subject() {\n\t\t// destruct chunk, length, and index\n\t\tlet {s, n, i} = this;\n\n\t\t// start labeled loop, run while there are characters\n\t\twhile(i < n) {  // eslint-disable-line no-unmodified-loop-condition\n\t\t\t// ref char\n\t\t\tlet x = s[i];\n\n\t\t\t// end of collection\n\t\t\tif(')' === x) {\n\t\t\t\t// consume whitespace (and incidentally reset index)\n\t\t\t\tR_WS.lastIndex = i+1;\n\t\t\t\tR_WS.exec(s);\n\t\t\t\tthis.i = R_WS.lastIndex;\n\n\t\t\t\t// no items in collection subject\n\t\t\t\tif(null === this._kt_subject) {\n\t\t\t\t\t// prepare subject\n\t\t\t\t\tthis._kt_subject = this._kt_rdf_nil;\n\n\t\t\t\t\t// state was never pushed to stack, jump to post_subject state\n\t\t\t\t\treturn this.post_blank_subject();\n\t\t\t\t}\n// otherwise, there must be items in collection\n\n\t\t\t\t// commit collection end\n\t\t\t\tthis._kt_object = this._kt_rdf_nil;\n\t\t\t\tthis.data();\n\n\n\t\t\t\t// restore state from stack\n\t\t\t\tlet s_resume_state;\n\t\t\t\t[this._kt_subject, this._kt_predicate, s_resume_state] = this._a_nested.pop();\n\t\t\t\treturn this[s_resume_state]();\n\t\t\t}\n\n\n\n\t\t\t// otherwise, pre-emptively secure the next blank node label\n\t\t\tlet s_pointer_label;\n\n\t\t\t// very first collection object\n\t\t\tlet b_pushed = false;\n\t\t\tif(null === this._kt_subject) {\n\t\t\t\t// set quasi subject (really for resume state)\n\t\t\t\ts_pointer_label = this.next_label();\n\t\t\t\tthis._kt_subject = this.anonymous_blank_node(s_pointer_label);\n\t\t\t\tthis._a_nested.push([this._kt_subject, this._kt_predicate, 'pairs']);\n\t\t\t\t// reset subject for later conditional branch\n\t\t\t\tthis._kt_subject = null;\n\t\t\t\tb_pushed = true;\n\t\t\t}\n\n// iriref\n\n\t\t\t// prepare sticky regex index\n\t\t\tR_IRIREF_ESCAPELESS.lastIndex = i;\n\t\t\t// execute regex\n\t\t\tlet m_iriref_e_object = R_IRIREF_ESCAPELESS.exec(s);\n\n\t\t\t// regex was a match\n\t\t\tif(m_iriref_e_object) {\n\t\t\t\t// advance index\n\t\t\t\ti = R_IRIREF_ESCAPELESS.lastIndex;\n\n\t\t\t\t// ref iri\n\t\t\t\tlet s_iri = m_iriref_e_object[1];\n\t\t\t\t// absolute iri\n\t\t\t\tif(!this._s_base_url || RT_IRI_ABSOLUTE.test(s_iri)) {\n\t\t\t\t\t// set object\n\t\t\t\t\tthis._kt_object = this.check_named_node_escapeless(s_iri);\n\t\t\t\t}\n\t\t\t\t// relative iri\n\t\t\t\telse {\n\t\t\t\t\tthis._kt_object = this.check_named_node_escapeless(uri.resolve(this._s_base_url, s_iri));\n\t\t\t\t}\n\n\t\t\t// prefixed name\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// try match\n\t\t\t\tlet aw_valid_this_match_prefixed_name_escapeless = this.match_prefixed_name_escapeless(s, i);\n\t\t\t\t// stack bail out\n\t\t\t\tif(!aw_valid_this_match_prefixed_name_escapeless) return true;\n\t\t\t\tlet [m_prefixed_named_e_object, im_prefixed_named_e_object] = aw_valid_this_match_prefixed_name_escapeless;\n\t\t\t\tif(m_prefixed_named_e_object) {\n\t\t\t\t\t// advance index\n\t\t\t\t\ti = im_prefixed_named_e_object;\n\t\t\t\t\t// check valid prefix\n\t\t\t\t\tlet s_prefix_id = m_prefixed_named_e_object[1] || '';\n\t\t\t\t\t// invalid prefix\n\t\t\t\t\tif(!OPHOP.call(this._h_prefixes, s_prefix_id)) return this.error(`no such prefix \"${s_prefix_id}\"`);\n\n\n\t\t\t\t\t// commit object iri from resolve prefixed name\n\t\t\t\t\tthis._kt_object = this.prefixed_name(s_prefix_id, m_prefixed_named_e_object[2]);\n\n\t\t\t\t// string literal\n\t\t\t\t}\n\t\t\t\telse \tif('\"' === x || '\\'' === x) {\n\t\t\t\t\t// first item in list\n\t\t\t\t\tif(null === this._kt_subject) {\n\t\t\t\t\t\ts_pointer_label = this.next_label();\n\t\t\t\t\t\tthis._kt_subject = this.anonymous_blank_node(s_pointer_label);\n\t\t\t\t\t\tthis._kt_predicate = this._kt_rdf_first;\n\t\t\t\t\t}\n\t\t\t\t\t// not first item in list\n\t\t\t\t\telse {\n\t\t\t\t\t\t// make nest list item\n\t\t\t\t\t\ts_pointer_label = this.next_label();\n\t\t\t\t\t\tlet kt_blank_node = this._kt_object = this.anonymous_blank_node(s_pointer_label);\n\t\t\t\t\t\tthis.data();\n\n\n\t\t\t\t\t\t// setup for object literal\n\t\t\t\t\t\tthis._kt_subject = kt_blank_node;\n\t\t\t\t\t\tthis._kt_predicate = this._kt_rdf_first;\n\t\t\t\t\t}\n\n\t\t\t\t\t// how to resume collection subject state after object literal\n\t\t\t\t\tthis.after_end_of_statement = function() {\n\t\t\t\t\t\tthis._kt_predicate = this._kt_rdf_rest;\n\t\t\t\t\t\tthis.after_end_of_statement = this.post_object;\n\t\t\t\t\t\treturn this.collection_subject();\n\t\t\t\t\t};\n\t\t\t\t\treturn this.string_literal();\n\n\t\t\t\t// numeric literal\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\tR_NUMERIC_LITERAL.lastIndex = i;\n\t\t\t\t\t// execute regex\n\t\t\t\t\tlet m_numeric_literal = R_NUMERIC_LITERAL.exec(s);\n\n\t\t\t\t\t// regex was a match\n\t\t\t\t\tif(m_numeric_literal) {\n\t\t\t\t\t\t// advance index\n\t\t\t\t\t\ti = R_NUMERIC_LITERAL.lastIndex;\n\t\t\t\t\t\t// it has exponent term, xsd:double\n\t\t\t\t\t\tif(m_numeric_literal[4]) {\n\t\t\t\t\t\t\tthis._kt_object = this._dc_factory.double(m_numeric_literal[1]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// contains decimal point, xsd:decimal\n\t\t\t\t\t\telse if(m_numeric_literal[2] || m_numeric_literal[3]) {\n\t\t\t\t\t\t\tthis._kt_object = this._dc_factory.decimal(m_numeric_literal[1]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// otherwise, it is an integer\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tthis._kt_object = this._dc_factory.integer(m_numeric_literal[1]);\n\t\t\t\t\t\t}\n\n\n\t\t\t\t\t// boolean literal\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\t\tR_BOOLEAN_LITERAL.lastIndex = i;\n\t\t\t\t\t\t// execute regex\n\t\t\t\t\t\tlet m_boolean_literal = R_BOOLEAN_LITERAL.exec(s);\n\n\t\t\t\t\t\t// regex was a match\n\t\t\t\t\t\tif(m_boolean_literal) {\n\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\ti = R_BOOLEAN_LITERAL.lastIndex;\n\t\t\t\t\t\t\t// make literal\n\t\t\t\t\t\t\tthis._kt_object = this._dc_factory.boolean(!!m_boolean_literal[1]);\n\n\t\t\t\t\t\t// blank node property list\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse \tif('[' === x) {\n\t\t\t\t// advance index to next token\n\t\t\t\t// consume whitespace (and incidentally reset index)\n\t\t\t\t\t\t\tR_WS.lastIndex = i+1;\n\t\t\t\t\t\t\tR_WS.exec(s);\n\t\t\t\t\t\t\tthis.i = R_WS.lastIndex;\n\n\t\t\t\t\t\t\t// this blank node is just the next item in the list\n\t\t\t\t\t\t\ts_pointer_label = this.next_label();\n\t\t\t\t\t\t\tlet kt_blank_node;\n\t\t\t\t\t\t\tif(null !== this._kt_subject) {\n\t\t\t\t\t\t\t\tkt_blank_node = this._kt_object = this.anonymous_blank_node(s_pointer_label);\n\t\t\t\t\t\t\t\tthis.data();\n\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t// subject needs to be set\n\t\t\t\t\t\t\tthis._kt_subject = kt_blank_node || this.anonymous_blank_node(s_pointer_label);\n\t\t\t\t\t\t\tthis._kt_predicate = this._kt_rdf_first;\n\t\t\t\t\t\t\tlet s_label = this.next_label();\n\t\t\t\t\t\t\tkt_blank_node = this._kt_object = this.anonymous_blank_node(s_label);\n\t\t\t\t\t\t\tthis.data();\n\n\n\t\t\t\t\t\t\t// when resume\n\t\t\t\t\t\t\tthis._kt_predicate = this._kt_rdf_rest;\n\n\t\t\t\t\t\t\t// push state\n\t\t\t\t\t\t\tthis._a_nested.push([this._kt_subject, this._kt_predicate, 'collection_subject']);\n\n\t\t\t\t\t\t\t// prepare next triple\n\t\t\t\t\t\t\tthis._kt_subject = kt_blank_node;\n\n\t\t\t\t\t\t\t// goto parsing pairs state\n\t\t\t\t\t\t\treturn this.pairs();\n\n\t\t\t\t\t\t// new collection\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse \tif('(' === x) {\n\t\t\t\t\t\t\t// consume whitespace (and incidentally reset index)\n\t\t\t\t\t\t\tR_WS.lastIndex = i+1;\n\t\t\t\t\t\t\tR_WS.exec(s);\n\t\t\t\t\t\t\ti = R_WS.lastIndex;\n\n\t\t\t\t\t\t\t// empty collection\n\t\t\t\t\t\t\tif(')' === s[i]) {\n\t\t\t\t\t\t\t\tthis.i = i;\n\t\t\t\t\t\t\t\tthis._kt_subject = this._a_nested[this._a_nested.length-1][0];\n\t\t\t\t\t\t\t\tthis._kt_predicate = this._kt_rdf_first;\n\t\t\t\t\t\t\t\tthis._a_nested.push([\n\t\t\t\t\t\t\t\t\tthis._kt_subject,\n\t\t\t\t\t\t\t\t\tthis._kt_rdf_rest,\n\t\t\t\t\t\t\t\t\t'collection_subject',\n\t\t\t\t\t\t\t\t]);\n\t\t\t\t\t\t\t\treturn this.collection_object();\n\t\t\t\t\t\t\t}\n\n\n\n\t\t\t\t\t\t\t// commit list item pointer\n\t\t\t\t\t\t\ts_pointer_label = this.next_label();\n\t\t\t\t\t\t\tlet kt_blank_node = this._kt_object = this.anonymous_blank_node(s_pointer_label);\n\t\t\t\t\t\t\tthis.data();\n\n\n\t\t\t\t\t\t\t// add this list as an item to the outer list\n\t\t\t\t\t\t\tthis._kt_subject = kt_blank_node;\n\t\t\t\t\t\t\tthis._kt_predicate = this._kt_rdf_rest;\n\t\t\t\t\t\t\tthis._a_nested.push([this._kt_subject, this._kt_predicate, 'collection_object']);\n\n\t\t\t\t\t\t\t// prepare next triple\n\t\t\t\t\t\t\tthis._kt_predicate = this._kt_rdf_first;\n\n\n\n\t\t\t\t\t\t\t// flowing\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\t// labeled blank node\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\t\t\tR_BLANK_NODE_LABEL.lastIndex = i;\n\t\t\t\t\t\t\t// execute regex\n\t\t\t\t\t\t\tlet m_blank_node_label_object = R_BLANK_NODE_LABEL.exec(s);\n\n\t\t\t\t\t\t\t// regex was a match\n\t\t\t\t\t\t\tif(m_blank_node_label_object) {\n\t\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\t\ti = R_BLANK_NODE_LABEL.lastIndex;\n\t\t\t\t\t\t\t\t// ref blank node label\n\t\t\t\t\t\t\t\tlet s_label = m_blank_node_label_object[1];\n\n\t\t\t\t\t\t\t\t// make object\n\t\t\t\t\t\t\t\tthis._kt_object = this.blank_node(s_label);\n\n\t\t\t\t\t\t\t// iriref\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\t\t\t\tR_IRIREF.lastIndex = i;\n\t\t\t\t\t\t\t\t// execute regex\n\t\t\t\t\t\t\t\tlet m_iriref_object = R_IRIREF.exec(s);\n\n\t\t\t\t\t\t\t\t// regex was a match\n\t\t\t\t\t\t\t\tif(m_iriref_object) {\n\t\t\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\t\t\ti = R_IRIREF.lastIndex;\n\n\t\t\t\t\t\t\t\t\t// ref iri\n\t\t\t\t\t\t\t\t\tlet s_iri = m_iriref_object[1].replace(R_UNICODE_ANY, F_REPLACE_UNICODE_ANY);\n\t\t\t\t\t\t\t\t\t// absolute iri\n\t\t\t\t\t\t\t\t\tif(!this._s_base_url || RT_IRI_ABSOLUTE.test(s_iri)) {\n\t\t\t\t\t\t\t\t\t\t// set object\n\t\t\t\t\t\t\t\t\t\tthis._kt_object = this.check_named_node(s_iri);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t// relative iri\n\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\tthis._kt_object = this.check_named_node(uri.resolve(this._s_base_url, s_iri));\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// prefixed name\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t// try match\n\t\t\t\t\t\t\t\t\tlet aw_valid_this_match_prefixed_name = this.match_prefixed_name(s, i);\n\t\t\t\t\t\t\t\t\t// stack bail out\n\t\t\t\t\t\t\t\t\tif(!aw_valid_this_match_prefixed_name) return true;\n\t\t\t\t\t\t\t\t\tlet [m_prefixed_named_object, im_prefixed_named_object] = aw_valid_this_match_prefixed_name;\n\t\t\t\t\t\t\t\t\tif(m_prefixed_named_object) {\n\t\t\t\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\t\t\t\ti = im_prefixed_named_object;\n\t\t\t\t\t\t\t\t\t\t// check valid prefix\n\t\t\t\t\t\t\t\t\t\tlet s_prefix_id = m_prefixed_named_object[1] || '';\n\t\t\t\t\t\t\t\t\t\t// invalid prefix\n\t\t\t\t\t\t\t\t\t\tif(!OPHOP.call(this._h_prefixes, s_prefix_id)) return this.error(`no such prefix \"${s_prefix_id}\"`);\n\n\n\t\t\t\t\t\t\t\t\t\t// escape local escapes\n\t\t\t\t\t\t\t\t\t\tlet s_suffix = m_prefixed_named_object[2]\n\t\t\t\t\t\t\t\t\t\t\t.replace(R_UNICODE_ANY, F_REPLACE_UNICODE_ANY)\n\t\t\t\t\t\t\t\t\t\t\t.replace(R_PN_LOCAL_ESCAPES, '$1');\n\n\t\t\t\t\t\t\t\t\t\t// commit object iri from resolve prefixed name\n\t\t\t\t\t\t\t\t\t\tthis._kt_object = this.prefixed_name(s_prefix_id, s_suffix);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\t\t\t\t\t\tR_COMMENT.lastIndex = i;\n\t\t\t\t\t\t\t\t\t\t// execute regex\n\t\t\t\t\t\t\t\t\t\tlet m_comment = R_COMMENT.exec(s);\n\n\t\t\t\t\t\t\t\t\t\t// regex was a match\n\t\t\t\t\t\t\t\t\t\tif(m_comment) {\n\t\t\t\t\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\t\t\t\t\ti = R_COMMENT.lastIndex;\n\t\t\t\t\t\t\t\t\t\t\tif(this.emit_comments) this.emit_comments(m_comment[0]);\n\t\t\t\t\t\t\t\t\t\t\tcontinue;\n\n\t\t\t// not iriref, not prefixed name, not string literal, not numeric literal, not boolean literal, not blank node property list, not collection\n\t\t\t// match counter: 7\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t\t// ran out of characters after pushing state, pop it\n\t\t\t\t\t\t\t\t\t\t\tif(b_pushed) this._a_nested.pop();\n\n\t\t\t\t\t\t\t\t\t\t\t// break loop to retry on next chunk if eos\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t} // brace #7\n\t\t\t\t\t\t\t\t} // brace #6\n\t\t\t\t\t\t\t} // brace #5\n\t\t\t\t\t\t} // brace #4\n\t\t\t\t\t} // brace #3\n\t\t\t\t} // brace #2\n\t\t\t} // brace #1\n\n\n\t\t\tlet kt_blank_node_outer;\n\t\t\tif(!s_pointer_label) s_pointer_label = this.next_label();\n\n\t\t\t// not the very first item of collection subject\n\t\t\tif(this._kt_subject !== null) {\n\t\t\t\t// ref object\n\t\t\t\tlet w_object = this._kt_object;\n\n\t\t\t\t// create blanknode to embed list\n\t\t\t\tkt_blank_node_outer = this._kt_object = this.anonymous_blank_node(s_pointer_label);\n\n\t\t\t\t// emit statement that functions as collection's head \"pointer\"\n\t\t\t\tthis.data();\n\n\n\t\t\t\t// swap back object\n\t\t\t\tthis._kt_object = w_object;\n\t\t\t}\n\n\t\t\t// emit statement that is item\n\t\t\tthis._kt_subject = kt_blank_node_outer || this.anonymous_blank_node(s_pointer_label);\n\t\t\tthis._kt_predicate = this._kt_rdf_first;\n\t\t\tthis.data();\n\n\n\t\t\t// prepare next predicate\n\t\t\tthis._kt_predicate = this._kt_rdf_rest;\n\t\t}\n\n\t\t\t\t// ran out of characters\n\t\t\t\t// update index value\n\t\tthis.i = i;\n\n\t\t// not yet eos\n\t\tif(i < this.n) {\n\t\t\t// expected token was not found\n\t\t\tif(0 === i) {\n\t\t\t\t// we've exceeded the maximum token length\n\t\t\t\tif(this.n > this.max_token_length) {\n\t\t\t\t\treturn this.parse_error('collection_subject');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// save state before pausing\n\t\tthis._f_state = this.collection_subject;\n\n\t\t// store what is unparsed\n\t\tthis.pre = s.slice(i);\n\n\t\t// if we're not parsing a stream, then this is an error\n\t\tif(this.eos) this.eos();\n\t\treturn;\n\t}\n\n\n\n\t// parse state for collection_object\n\tcollection_object() {\n\t\t// destruct chunk, length, and index\n\t\tlet {s, n, i} = this;\n\n\t\t// start labeled loop, run while there are characters\n\t\twhile(i < n) {  // eslint-disable-line no-unmodified-loop-condition\n\t\t\t// ref char\n\t\t\tlet x = s[i];\n\n\t\t\t// end of collection\n\t\t\tif(')' === x) {\n\t\t\t\t// consume whitespace (and incidentally reset index)\n\t\t\t\tR_WS.lastIndex = i+1;\n\t\t\t\tR_WS.exec(s);\n\t\t\t\tthis.i = R_WS.lastIndex;\n\n\t\t\t\t// make & emit collection's tail \"pointer\"\n\t\t\t\tthis._kt_object = this._kt_rdf_nil;\n\t\t\t\tthis.data();\n\n\n\t\t\t\t// restore previous state\n\t\t\t\tlet s_resume_state;\n\t\t\t\t[this._kt_subject, this._kt_predicate, s_resume_state] = this._a_nested.pop();\n\t\t\t\treturn this[s_resume_state]();\n\t\t\t}\n\n\n\n\t\t\t// otherwise, pre-emptively secure the next blank node label\n\t\t\tlet s_pointer_label;\n\n// iriref\n\n\t\t\t// prepare sticky regex index\n\t\t\tR_IRIREF_ESCAPELESS.lastIndex = i;\n\t\t\t// execute regex\n\t\t\tlet m_iriref_e_object = R_IRIREF_ESCAPELESS.exec(s);\n\n\t\t\t// regex was a match\n\t\t\tif(m_iriref_e_object) {\n\t\t\t\t// advance index\n\t\t\t\ti = R_IRIREF_ESCAPELESS.lastIndex;\n// commit object iri as is\n\n\t\t\t\t// ref iri\n\t\t\t\tlet s_iri = m_iriref_e_object[1];\n\t\t\t\t// absolute iri\n\t\t\t\tif(!this._s_base_url || RT_IRI_ABSOLUTE.test(s_iri)) {\n\t\t\t\t\t// set object\n\t\t\t\t\tthis._kt_object = this.check_named_node_escapeless(s_iri);\n\t\t\t\t}\n\t\t\t\t// relative iri\n\t\t\t\telse {\n\t\t\t\t\tthis._kt_object = this.check_named_node_escapeless(uri.resolve(this._s_base_url, s_iri));\n\t\t\t\t}\n\n\t\t\t// prefixed name\n\t\t\t}\n\t\t\telse {\n\t\t\t\t// try match\n\t\t\t\tlet aw_valid_this_match_prefixed_name_escapeless = this.match_prefixed_name_escapeless(s, i);\n\t\t\t\t// stack bail out\n\t\t\t\tif(!aw_valid_this_match_prefixed_name_escapeless) return true;\n\t\t\t\tlet [m_prefixed_named_e_object, im_prefixed_named_e_object] = aw_valid_this_match_prefixed_name_escapeless;\n\t\t\t\tif(m_prefixed_named_e_object) {\n\t\t\t\t\t// advance index\n\t\t\t\t\ti = im_prefixed_named_e_object;\n\t\t\t\t\t// check valid prefix\n\t\t\t\t\tlet s_prefix_id = m_prefixed_named_e_object[1] || '';\n\t\t\t\t\t// invalid prefix\n\t\t\t\t\tif(!OPHOP.call(this._h_prefixes, s_prefix_id)) return this.error(`no such prefix \"${s_prefix_id}\"`);\n\n\n\t\t\t\t\t// commit object iri from resolve prefixed name\n\t\t\t\t\tthis._kt_object = this.prefixed_name(s_prefix_id, m_prefixed_named_e_object[2]);\n\n\t\t\t\t// string literal\n\t\t\t\t}\n\t\t\t\telse \tif('\"' === x || '\\'' === x) {\n\t\t\t\t\t// update index before changing states\n\t\t\t\t\tthis.i = i;\n\n\t\t\t\t\t// create blanknode to embed list\n\t\t\t\t\tlet kt_blank_node = this._kt_object = this.anonymous_blank_node(this.next_label());\n\n\t\t\t\t\t// emit statement that functions as collection's head \"pointer\"\n\t\t\t\t\tthis.data();\n\n\n\t\t\t\t\t// prepare statement that is item\n\t\t\t\t\tthis._kt_subject = kt_blank_node;\n\t\t\t\t\tthis._kt_predicate = this._kt_rdf_first;\n\n\t\t\t\t\tthis.after_end_of_statement = function() {\n\t\t\t\t\t\tthis._kt_predicate = this._kt_rdf_rest;\n\t\t\t\t\t\tthis.after_end_of_statement = this.post_object;\n\t\t\t\t\t\treturn this.collection_object();\n\t\t\t\t\t};\n\t\t\t\t\treturn this.string_literal();\n\n\t\t\t\t// numeric literal\n\t\t\t\t}\n\t\t\t\telse {\n\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\tR_NUMERIC_LITERAL.lastIndex = i;\n\t\t\t\t\t// execute regex\n\t\t\t\t\tlet m_numeric_literal = R_NUMERIC_LITERAL.exec(s);\n\n\t\t\t\t\t// regex was a match\n\t\t\t\t\tif(m_numeric_literal) {\n\t\t\t\t\t\t// advance index\n\t\t\t\t\t\ti = R_NUMERIC_LITERAL.lastIndex;\n\t\t\t\t\t\t// it has exponent term, xsd:double\n\t\t\t\t\t\tif(m_numeric_literal[4]) {\n\t\t\t\t\t\t\tthis._kt_object = this._dc_factory.double(m_numeric_literal[1]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// contains decimal point, xsd:decimal\n\t\t\t\t\t\telse if(m_numeric_literal[2] || m_numeric_literal[3]) {\n\t\t\t\t\t\t\tthis._kt_object = this._dc_factory.decimal(m_numeric_literal[1]);\n\t\t\t\t\t\t}\n\t\t\t\t\t\t// otherwise, it is an integer\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\tthis._kt_object = this._dc_factory.integer(m_numeric_literal[1]);\n\t\t\t\t\t\t}\n\n\n\t\t\t\t\t// boolean literal\n\t\t\t\t\t}\n\t\t\t\t\telse {\n\t\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\t\tR_BOOLEAN_LITERAL.lastIndex = i;\n\t\t\t\t\t\t// execute regex\n\t\t\t\t\t\tlet m_boolean_literal = R_BOOLEAN_LITERAL.exec(s);\n\n\t\t\t\t\t\t// regex was a match\n\t\t\t\t\t\tif(m_boolean_literal) {\n\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\ti = R_BOOLEAN_LITERAL.lastIndex;\n\t\t\t\t\t\t\t// make literal\n\t\t\t\t\t\t\tthis._kt_object = this._dc_factory.booelan(!!m_boolean_literal[1]);\n\n\t\t\t\t\t\t// blank node property list\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse \tif('[' === x) {\n\t\t\t\t// advance index to next token\n\t\t\t\t// consume whitespace (and incidentally reset index)\n\t\t\t\t\t\t\tR_WS.lastIndex = i+1;\n\t\t\t\t\t\t\tR_WS.exec(s);\n\t\t\t\t\t\t\tthis.i = R_WS.lastIndex;\n\n\t\t\t\t\t\t\t// commit head of list pointer\n\t\t\t\t\t\t\tlet kt_blank_node = this._kt_object = this.anonymous_blank_node(this.next_label());\n\t\t\t\t\t\t\tthis.data();\n\n\n\t\t\t\t\t\t\t// setup state to resume and push\n\t\t\t\t\t\t\tthis._kt_subject = kt_blank_node;\n\t\t\t\t\t\t\tthis._kt_predicate = this._kt_rdf_rest;\n\t\t\t\t\t\t\tthis._a_nested.push([this._kt_subject, this._kt_predicate, 'collection_object']);\n\n\t\t\t\t\t\t\t// enter blank node\n\t\t\t\t\t\t\tthis._kt_predicate = this._kt_rdf_first;\n\t\t\t\t\t\t\tkt_blank_node = this._kt_object = this.anonymous_blank_node(this.next_label());\n\t\t\t\t\t\t\tthis.data();\n\n\n\t\t\t\t\t\t\t// prepare next triple\n\t\t\t\t\t\t\tthis._kt_subject = kt_blank_node;\n\t\t\t\t\t\t\tthis._kt_predicate = this._kt_rdf_first;\n\n\t\t\t\t\t\t\t// goto parsing pairs state\n\t\t\t\t\t\t\treturn this.pairs();\n\n\t\t\t\t\t\t// new collection\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse \tif('(' === x) {\n\t\t\t\t\t\t\t// consume whitespace (and incidentally reset index)\n\t\t\t\t\t\t\tR_WS.lastIndex = i+1;\n\t\t\t\t\t\t\tR_WS.exec(s);\n\t\t\t\t\t\t\ti = R_WS.lastIndex;\n\n\t\t\t\t\t\t\t// commit list item pointer\n\t\t\t\t\t\t\ts_pointer_label = this.next_label();\n\t\t\t\t\t\t\tlet kt_blank_node = this._kt_object = this.anonymous_blank_node(s_pointer_label);\n\t\t\t\t\t\t\tif(null === this._kt_subject) {\n\t\t\t\t\t\t\t\tlet a_recent = this._a_nested[this._a_nested.length-1];\n\t\t\t\t\t\t\t\tthis._kt_subject = a_recent[0];\n\t\t\t\t\t\t\t\tthis._kt_predicate = a_recent[1];\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\tthis.data();\n\n\n\t\t\t\t\t\t\t// add this list as an item to the outer list\n\t\t\t\t\t\t\tthis._kt_subject = kt_blank_node;\n\t\t\t\t\t\t\tthis._kt_predicate = this._kt_rdf_rest;\n\t\t\t\t\t\t\tthis._a_nested.push([this._kt_subject, this._kt_predicate, 'collection_object']);\n\n\t\t\t\t\t\t\t// prepare next triple\n\t\t\t\t\t\t\tthis._kt_predicate = this._kt_rdf_first;\n\n\t\t\t\t\t\t\t// flowing\n\t\t\t\t\t\t\tcontinue;\n\n\t\t\t\t\t\t// labeled blank node\n\t\t\t\t\t\t}\n\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\t\t\tR_BLANK_NODE_LABEL.lastIndex = i;\n\t\t\t\t\t\t\t// execute regex\n\t\t\t\t\t\t\tlet m_blank_node_label_object = R_BLANK_NODE_LABEL.exec(s);\n\n\t\t\t\t\t\t\t// regex was a match\n\t\t\t\t\t\t\tif(m_blank_node_label_object) {\n\t\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\t\ti = R_BLANK_NODE_LABEL.lastIndex;\n\t\t\t\t\t\t\t\t// ref blank node label\n\t\t\t\t\t\t\t\tlet s_label = m_blank_node_label_object[1];\n\n\t\t\t\t\t\t\t\t// make collection pointer label first\n\t\t\t\t\t\t\t\ts_pointer_label = this.next_label();\n\n\t\t\t\t\t\t\t\t// make object\n\t\t\t\t\t\t\t\tthis._kt_object = this.blank_node(s_label);\n\n\t\t\t\t\t\t\t// iriref\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\t\t\t\tR_IRIREF.lastIndex = i;\n\t\t\t\t\t\t\t\t// execute regex\n\t\t\t\t\t\t\t\tlet m_iriref_object = R_IRIREF.exec(s);\n\n\t\t\t\t\t\t\t\t// regex was a match\n\t\t\t\t\t\t\t\tif(m_iriref_object) {\n\t\t\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\t\t\ti = R_IRIREF.lastIndex;\n// commit object iri as is\n\n\t\t\t\t\t\t\t\t\t// ref iri\n\t\t\t\t\t\t\t\t\tlet s_iri = m_iriref_object[1].replace(R_UNICODE_ANY, F_REPLACE_UNICODE_ANY);\n\t\t\t\t\t\t\t\t\t// absolute iri\n\t\t\t\t\t\t\t\t\tif(!this._s_base_url || RT_IRI_ABSOLUTE.test(s_iri)) {\n\t\t\t\t\t\t\t\t\t\t// set object\n\t\t\t\t\t\t\t\t\t\tthis._kt_object = this.check_named_node(s_iri);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t// relative iri\n\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\tthis._kt_object = this.check_named_node(uri.resolve(this._s_base_url, s_iri));\n\t\t\t\t\t\t\t\t\t}\n\n\t\t\t\t\t\t\t\t// prefixed name\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t// try match\n\t\t\t\t\t\t\t\t\tlet aw_valid_this_match_prefixed_name = this.match_prefixed_name(s, i);\n\t\t\t\t\t\t\t\t\t// stack bail out\n\t\t\t\t\t\t\t\t\tif(!aw_valid_this_match_prefixed_name) return true;\n\t\t\t\t\t\t\t\t\tlet [m_prefixed_named_object, im_prefixed_named_object] = aw_valid_this_match_prefixed_name;\n\t\t\t\t\t\t\t\t\tif(m_prefixed_named_object) {\n\t\t\t\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\t\t\t\ti = im_prefixed_named_object;\n\t\t\t\t\t\t\t\t\t\t// check valid prefix\n\t\t\t\t\t\t\t\t\t\tlet s_prefix_id = m_prefixed_named_object[1] || '';\n\t\t\t\t\t\t\t\t\t\t// invalid prefix\n\t\t\t\t\t\t\t\t\t\tif(!OPHOP.call(this._h_prefixes, s_prefix_id)) return this.error(`no such prefix \"${s_prefix_id}\"`);\n\n\n\t\t\t\t\t\t\t\t\t\t// escape local escapes\n\t\t\t\t\t\t\t\t\t\tlet s_suffix = m_prefixed_named_object[2]\n\t\t\t\t\t\t\t\t\t\t\t.replace(R_UNICODE_ANY, F_REPLACE_UNICODE_ANY)\n\t\t\t\t\t\t\t\t\t\t\t.replace(R_PN_LOCAL_ESCAPES, '$1');\n\n\t\t\t\t\t\t\t\t\t\t// commit object iri from resolve prefixed name\n\t\t\t\t\t\t\t\t\t\tthis._kt_object = this.prefixed_name(s_prefix_id, s_suffix);\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t// prepare sticky regex index\n\t\t\t\t\t\t\t\t\t\tR_COMMENT.lastIndex = i;\n\t\t\t\t\t\t\t\t\t\t// execute regex\n\t\t\t\t\t\t\t\t\t\tlet m_comment = R_COMMENT.exec(s);\n\n\t\t\t\t\t\t\t\t\t\t// regex was a match\n\t\t\t\t\t\t\t\t\t\tif(m_comment) {\n\t\t\t\t\t\t\t\t\t\t\t// advance index\n\t\t\t\t\t\t\t\t\t\t\ti = R_COMMENT.lastIndex;\n\t\t\t\t\t\t\t\t\t\t\tif(this.emit_comments) this.emit_comments(m_comment[0]);\n\t\t\t\t\t\t\t\t\t\t\tcontinue;\n\n\t\t\t// not iriref, not prefixed name, not string literal, not numeric literal, not boolean literal, not blank node property list, not collection\n\t\t\t// match counter: 7\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t\telse {\n\t\t\t\t\t\t\t\t\t\t\t// break loop to retry on next chunk if eos\n\t\t\t\t\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t\t} // brace #7\n\t\t\t\t\t\t\t\t} // brace #6\n\t\t\t\t\t\t\t} // brace #5\n\t\t\t\t\t\t} // brace #4\n\t\t\t\t\t} // brace #3\n\t\t\t\t} // brace #2\n\t\t\t} // brace #1\n\n\n\n\t\t\t// ref object\n\t\t\tlet w_object = this._kt_object;\n\n\t\t\t// create blanknode to embed list\n\t\t\tif(!s_pointer_label) s_pointer_label = this.next_label();\n\t\t\tlet kt_blank_node_outer = this._kt_object = this.anonymous_blank_node(s_pointer_label);\n\n\t\t\t// emit statement that functions as collection's head \"pointer\"\n\t\t\tthis.data();\n\n\n\t\t\t// emit statement that is item\n\t\t\tthis._kt_subject = kt_blank_node_outer;\n\t\t\tthis._kt_predicate = this._kt_rdf_first;\n\t\t\tthis._kt_object = w_object;\n\t\t\tthis.data();\n\n\n\t\t\t// prepare next predicate\n\t\t\tthis._kt_predicate = this._kt_rdf_rest;\n\t\t}\n\n\t\t\t\t// ran out of characters\n\t\t\t\t// update index value\n\t\tthis.i = i;\n\n\t\t// not yet eos\n\t\tif(i < this.n) {\n\t\t\t// expected token was not found\n\t\t\tif(0 === i) {\n\t\t\t\t// we've exceeded the maximum token length\n\t\t\t\tif(this.n > this.max_token_length) {\n\t\t\t\t\treturn this.parse_error('collection_object');\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t// save state before pausing\n\t\tthis._f_state = this.collection_object;\n\n\t\t// store what is unparsed\n\t\tthis.pre = s.slice(i);\n\n\t\t// if we're not parsing a stream, then this is an error\n\t\tif(this.eos) this.eos();\n\t\treturn;\n\t}\n\n\n\tdestroy(e_destroy) {\n\t\tthis.post_blank_subject = () => {};\n\n\t\tthis.statement = () => {};\n\n\t\tthis.block = () => {};\n\n\t\tthis.graph_or_subject = () => {};\n\n\t\tthis.graph_or_subject_property_list = () => {};\n\n\t\tthis.graph_or_subject_anon = () => {};\n\n\t\tthis.graph_keyword = () => {};\n\n\t\tthis.graph_post_name = () => {};\n\n\t\tthis.pairs = () => {};\n\n\t\tthis.object_list = () => {};\n\n\t\tthis.string_literal_short_double = () => {};\n\n\t\tthis.string_literal_short_single = () => {};\n\n\t\tthis.string_literal_long_double = () => {};\n\n\t\tthis.string_literal_long_single = () => {};\n\n\t\tthis.string_literal = () => {};\n\n\t\tthis.datatype_or_langtag = () => {};\n\n\t\tthis.datatype = () => {};\n\n\t\tthis.post_object = () => {};\n\n\t\tthis.base_iri = () => {};\n\n\t\tthis.prefix_id = () => {};\n\n\t\tthis.prefix_iri = () => {};\n\n\t\tthis.full_stop = () => {};\n\n\t\tthis.collection_subject = () => {};\n\n\t\tthis.collection_object = () => {};\n\n\n\t\tthis.eof = () => {\n\t\t\tthis.s = null;\n\t\t};\n\n\t\tthis._b_destroyed = true;\n\n\t\t// propagate input destroy\n\t\tif(!e_destroy && this._ds_input) {\n\t\t\tthis._ds_input.destroy(e_destroy);\n\t\t}\n\n\t\tthis.transform.demolish(e_destroy);\n\t}\n}\n\nmodule.exports = function(...a_args) {\n\tlet g_config = {};\n\n\t// at least one argument\n\tif(a_args.length) {\n\t\tlet z_arg_0 = a_args[0];\n\n\t\t// input given unspecified\n\t\tif(z_arg_0 && z_arg_0.input && 'undefined' === typeof z_arg_0.input.string && !z_arg_0.input.stream) {\n\t\t\tz_arg_0 = z_arg_0.input;\n\t\t}\n\n\t\t// string\n\t\tif('string' === typeof z_arg_0) {\n\t\t\tg_config.input = {string:z_arg_0};\n\t\t}\n\t\t// null\n\t\telse if(null === z_arg_0) {\n\t\t\tg_config.input = null;\n\t\t}\n\t\t// node stream\n\t\telse if('function' === typeof z_arg_0.setEncoding) {\n\t\t\tg_config.input = {stream:z_arg_0};\n\t\t}\n\t\t// whatwg stream\n\t\telse if('function' === typeof z_arg_0.pipeTo) {\n\t\t\tthrow new TypeError(`Sorry, WHATWG streams are currently not supported :(`);\n\t\t// g_config.input = {stream:z_arg_0};\n\t\t}\n\t\t// config struct\n\t\telse if(z_arg_0 && 'object' === typeof z_arg_0 && '[object Object]' === Object.prototype.toString.call(z_arg_0)) {\n\t\t\tg_config = z_arg_0;\n\n\t\t\t// more args; invalid\n\t\t\tif(a_args.length > 1) {\n\t\t\t\tthrow new TypeError(`unexpected argument(s) after config struct: ${a_args.slice(1)}`);\n\t\t\t}\n\t\t}\n\t\t// unknown\n\t\telse {\n\t\t\tthrow new TypeError(`unexpected input type: ${z_arg_0}`);\n\t\t}\n\n\t\t// more args\n\t\tif(a_args.length > 1) {\n\t\t\t// copy onto struct\n\t\t\tObject.assign(g_config, a_args[1]);\n\n\t\t\t// more args\n\t\t\tif(a_args.length > 2) {\n\t\t\t\tthrow new TypeError(`unexpected argument(s) after input and config struct: ${a_args.slice(2)}`);\n\t\t\t}\n\t\t}\n\t}\n\n\t// create reader, return transform stream\n\treturn (new Reader(g_config)).transform;\n};\n"],"sourceRoot":""}